# Hey Emacs, this is a -*- sh -*- file
## .shellrc --- Shell agnostic configuration file

# Copyright (C) 2009-2023 Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config

uname -s -n -r -m

die() {
    msg="${1:-"Unknown error"}"
    logger "${msg}"
    printf '%s: Fatal error: %s\n' "$(basename $0)" "${msg}" > /dev/stderr
    exit 2                              # An error occurred.
}

has() {
    if ! command -v "$1" > /dev/null 2>&1; then
        echo "$1 not found."
        return 2                        # An error occurred.
    fi
}

# Cd to the directory of the current buffer in Emacs.
cde() {
    if ! command -v emacsclient > /dev/null 2>&1; then
        printf >&2 "Error: emacsclient not found.\n"
        printf >&2 "Please install Emacs and ensure the binary is in your PATH.\n"
        return 2
    fi

    local dir
    dir="$(emacsclient -e '(with-current-buffer
                               (window-buffer (selected-window))
                             (replace-regexp-in-string "^~" (getenv "HOME")
                                default-directory))' | tr -d '"')"

    if [ ! -d "$dir" ]; then
        printf >&2 "Error: directory not found: %s\n" "$dir"
        return 2
    fi

    builtin cd "$dir"
    #! The change in working directory will persist after the function has
    #! completed.
}

# Add a directory to PATH if it exists.
add_to_path() {
  if [[ -d "$1" ]]; then
    PATH="$1:$PATH"
  fi
}

# Add directories to PATH.
add_to_path "$HOME/bin"
add_to_path "$HOME/expect"
add_to_path "$HOME/R"

# Add $HOME/winbin to the end of PATH if it exists.
if [[ -d "$HOME/winbin" ]]; then
  PATH="$PATH:$HOME/winbin"
fi

# Add the current directory to PATH if not running as root.
if [[ "$UID" -ne 0 ]]; then
    PATH="$PATH:."
fi

# Add the current directory and home directory to CDPATH.
export CDPATH=".:$HOME"

# If user's private man directory exists, add it to MANPATH.
if [[ -d "$HOME/man" ]]; then
    export MANPATH="$HOME/man:$MANPATH"
fi

# Add directories to INFOPATH.
export INFOPATH="/usr/share/info:$INFOPATH"

# Set umask based on the user's EUID.
umask 022                               # Prevent new dirs and files from being
                                        # group and world writable.

if [[ "$UID" -eq 0 ]]; then
    umask 077                           # Stricter.
fi

# # For Bash on Ubuntu on Windows.
# export BROWSER='/mnt/c/Windows/explorer.exe' # does not work.
# export BROWSER='/mnt/c/Program Files (x86)/Mozilla Firefox/firefox.exe'

export LANG=C.UTF-8

# # For scripts in R language.
# export LC_CTYPE=

# For Unicode ruler in diff-so-fancy.  See issue #364.
unset LC_CTYPE

# Find a suitable editor.
if [ -z "$SSH_CONNECTION" ]; then
    export EDITOR="emacsclient"
    export ALTERNATE_EDITOR=""
    alias e="emacsclient -n" # 'e .' opens the current directory in Emacs.
    alias ee="emacsclient -n --alternate-editor=emacs"
    alias bgemacs='emacs &'
else
    EDITOR=$(command -v emacs \
                 || command -v subl \
                 || command -v atom \
                 || command -v nano)
    alias e='$EDITOR'
fi

# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"

export PAGER="less"

alias more='less'

export LESS_TERMCAP_mb=$'\e[01;31m'     # Begin bold.
export LESS_TERMCAP_md=$'\e[01;36m'     # Begin blink (section titles in cyan).
export LESS_TERMCAP_me=$'\e[0m'         # Reset bold/blink.
export LESS_TERMCAP_so=$'\e[01;44;33m'  # Begin reverse video.
export LESS_TERMCAP_se=$'\e[0m'         # Reset reverse video.
export LESS_TERMCAP_us=$'\e[01;32m'     # Begin underline.
export LESS_TERMCAP_ue=$'\e[0m'         # Reset underline.

export LESS='-R'

# Format for displaying non-printable, non-control characters (see `man less').
export LESSBINFMT="*n<%02X>"            # Do not use reverse video.
export LESSBINFMT="*d?"                 # Use bold ?.

export LESS='-F -i -M -R -X'
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'

alias hgrep='history | grep -i'

alias which-shell='ps -p $$'

# Set time style (ISO 8601 format) for `ls` command.
export TIME_STYLE=long-iso

# Determine if the terminal supports colors.
if [[ "$TERM" != "dumb" ]]; then
    # Add `--show-control-chars` option.
    LS_OPTIONS="${LS_OPTIONS} --show-control-chars"

    # Create aliases for `ls` and `ll` commands.
    alias ls='ls --color=auto -F'
    alias ll='ls --color=auto -a --group-directories-first -G -h -l'
                                        # Long listing and hidden files.

    # Set directory colors if `.dircolors` file exists in the home directory.
    if [[ -f "$HOME"/.dircolors ]]; then
        eval "$(dircolors -b $HOME/.dircolors)"
        # See https://github.com/seebi/dircolors-solarized.
    else
        eval "$(dircolors -b)"
    fi
else
    alias ls='ls -CF'
fi

alias dirtree='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'

alias df='df -kTh'

alias du='du -h'
alias du1='du -h --max-depth=1'

alias dusort='du -ms * | sort -rn'

alias du-summary='du --max-depth=1 -k | sort -nr | cut -f2 | xargs -d '\n' du -sh'

alias mount='mount | column -t'

# Play safe!  Prevent some accidental mistakes.
alias rm='rm -i'                        # Confirm removing file.
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.

# Make an extract function!
alias tgz='tar -zxvf'
alias tbz2='tar -jxvf'

# Display the contents of $PATH with each directory separated by a newline character.
alias path='echo "$PATH" | tr ":" "\n"'

# Path.
alias where='type -a'

alias mkall='./configure && make && sudo make install'

# Enable aliases to be sudoâ€™ed.
alias sudo='sudo '

# Become root.
alias root='sudo -i'

# Upgrade everything.
alias upgrade-system='sudo apt update -y \
    && sudo apt full-upgrade -y \
    && sudo apt autoremove -y \
    && sudo apt clean -y \
    && sudo apt autoclean -y'

alias poweroff="systemctl poweroff"
alias reboot="systemctl reboot"

# Make executable.
alias exe='chmod +x'

# Recursively change the owner of all files and directories to the current user.
alias own='sudo chown -R $USER'

alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

alias -- -='cd -'                       # Alias '-' to 'cd -'.

# Print the current directory stack (list directory history).
alias d='dirs -v | head -n 10'

alias 1='cd -'
alias 2='cd +2'
alias 3='cd +3'
alias 4='cd +4'
alias 5='cd +5'
alias 6='cd +6'
alias 7='cd +7'
alias 8='cd +8'
alias 9='cd +9'

# For WSL.
alias c:='cd /mnt/c'
alias d:='cd /mnt/d'

alias explorer='explorer.exe'

# For Cygwin.
if [[ "$OSTYPE" = cygwin* ]]; then
    alias c:='cd /cygdrive/c'
    alias d:='cd /cygdrive/d'
    alias open='cygstart'
    alias xdg-open='cygstart'
fi

alias c='clear'
alias j='jobs -l'
alias l='ls'                            # xx
alias m='man'
# alias p='$PAGER'
alias q='exit'
alias s='sudo'
alias t='tail -f'
# alias x='exit' # Conflict with extract (from Oh-my-Zsh?)

# Make `diff' automatically call `colordiff' (Install `colordiff' package...).
has colordiff && alias diff='colordiff'

alias g='git'

# Go to the root directory of your Git repo.
alias cdroot='git rev-parse && cd "$(git rev-parse --show-toplevel)"'
                                        # That will not blow up cd if you aren't
                                        # in a Git directory.

#! The change in working directory will persist after the function has
#! completed.

alias tigs='tig status'                 # Use it all of the time!
alias tigb='tig blame'
alias tigall='tig --all'
alias tigreleases='tig --all --simplify-by-decoration'

alias keylist='ssh-add -l'              # List all identities.
alias keyon='ssh-add -t 4h'             # Add identity.
alias keyoff='ssh-add -D'               # Remove all identities.

org_test() {
    (
        cd "$HOME"/Public/Repositories/org-mode
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest \
            emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}

# Display the matched pattern in color.
alias grep='grep --color=auto'
alias egrep='grep -E --color=auto'
alias fgrep='grep -F --color=auto'

# export GREP_COLOR='0;33;1;44'         # Bold Yellow on blue.
export GREP_COLORS="sl=:cx=:mt=01;33;1;44:ms=01;33;1;44:mc=01;33;1;44:fn=35:ln=32:bn=32:se=36"

# Grep through the running processes.
alias pgrep='pgrep -fl'
alias 'ps?'='ps ax | grep '

alias rg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold'"
alias srg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold' --sort-files"

# GraphicsMagick.
alias GIF='gm convert -verbose -interlace LINE'
alias thumb='gm convert -geometry 100x100 -interlace LINE -verbose'
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize() {
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES; do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # Obscure but useful string operations.
        # (See http://www.arachnoid.com/linux/shell_programming.html.)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"

export GS_OPTIONS='-sPAPERSIZE=a4'
alias pdfmerge='gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./pdf-joined.pdf' # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c

# clean [-r] - Remove useless files (recursively).
clean() {
    if [[ "$1" = "-r" ]]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" \
             -o -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" \
             -o -name "*.~BASE~" -o -name ".*.~BASE~" \) \
             -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}

saneperms() {
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod "${1:=644}"
}

# # Search for various types or README file in dir and display them in $PAGER.
# readme() {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }

safetmp() {
    test -d "$HOME" || exit 1
    test -d "$HOME"/tmp || mkdir "$HOME"/tmp
    echo "$HOME/tmp/safetmp.$(hostname).$(date +%s).$$"
}

# Open immediately the first match.
texman() {
    locate "$*" | grep pdf | grep texlive | head -1 | xargs open
}

texlist() {
    locate "$*" | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)"
}

# Commandline Fu
cmdfu() {
    curl "http://www.commandlinefu.com/commands/matching/$(echo "$@" \
        | sed 's/ /-/g')/$(echo -n $@ | base64)/plaintext" ;
}

# Check if websites are down
down4me() {
    curl -s "http://www.downforeveryoneorjustme.com/$1" | sed '/just you/!d;s/<[^>]*>//g';
}

## Google Translate Functions ##

say() {
   find ~/Downloads/en -name "$1.ogg" -exec ogg123 {} \;
   # mplayer -user-agent Mozilla -prefer-ipv4 \
   # "http://translate.google.md/translate_tts?ie=UTF-8&tl="$1"&q=$(echo "$@" \
   # | cut -d ' ' -f2- | sed 's/ /\+/g')" > /dev/null 2>&1 ;
}

say-translation() {
   lang=$1
   trans=$(translate {=$lang} "$(echo "$@" | cut -d ' ' -f2- | sed 's/ /\+/g')" )
   echo $trans
   mplayer -user-agent Mozilla \
   "http://translate.google.com/translate_tts?ie=UTF-8&tl=$lang&q=$trans" > /dev/null 2>&1 ;
}
