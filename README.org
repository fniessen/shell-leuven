#+TITLE:     ShellRC
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   num:nil ^:{}

#+PROPERTY:  header-args :eval no
#+SETUPFILE: ~/.dotfiles/org/theme-readtheorg.setup

Look at https://github.com/jlevy/the-art-of-command-line!

* Summary

ShellRC is a set of configuration files to take advantage of Bash and Zsh on Mac
OS X, Linux and Windows (with Cygwin).

* COMMENT Tasks

** TODO Test performance of branch name and merge status in Bash prompt

Should go to local or global bash profile:

#+begin_src shell
function parse_git_dirty {
    [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit, working directory clean" ]] && echo "*"
}
function parse_git_branch {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/[\1$(parse_git_dirty)]/"
}
export PS1='\u@\h \[\033[0;36m\]\w \[\033[0;32m\]$(parse_git_branch)\[\033[0m\]$ '
#+end_src

** TODO Look at shell scripts

https://bitbucket.org/ambrevar/dotfiles/src/ac47e01e1b25942d5a3f83616a91f9eab6382823/.scripts/?at=master

(pdfscan, etc.)

* Getting started

** Prerequisites for Windows

Install [[https://www.cygwin.com/][Cygwin]] (http://mirrors.kernel.org).

*** ~PATH~

After Cygwin is installed, modify the System ~PATH~ variable: prepend it with
=C:\cygwin64\bin= (before ~%SystemRoot%\system32~).

#+begin_warning
If you add other directories (such as =~/bin= or =~/winbin=) in the ~PATH~ before
Cygwin, please check that those directories don't contain =cygwin1.dll= or
such. That was why I had troubles running ~git~ commands...
#+end_warning

In =c:/cygwin64/etc/profile=,

- =/usr/local/bin= is appended to the ~PATH~!!

  And, except when root, it is almost always wrong to have =/usr/local/bin= after
  any system path.

- ~TZ~ (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from =c:/cygwin/Cygwin.bat=!!

*** Add an ~HOME~ environment variable

No trailing backslash!

*** Change your Cygwin ~HOME~ folder

Programs like ~ssh~ don't rely on your environment variable ~HOME~ for the location
of your *home directory*.

Starting with Cygwin 1.7.34, the recommended way to do this is to add a custom
~db_home~ setting (comment the example line) to =/etc/nsswitch.conf=.

#+begin_note
If you installed Cygwin prior to 1.7.34 or have run its ~mkpasswd~ utility so that
you have an =/etc/passwd= file, you can change your Cygwin ~HOME~ directory by
editing your user's entry in that file. Your ~HOME~ directory is the penultimate
element on your user's line in =/etc/passwd= (the ~HOME~ environment variable is set
from that field).
#+end_note

*** Packages

*************** TODO See http://www.4thinker.com/cygwin-setup.html
*************** END

[[http://cygwin.com/cgi-bin2/package-grep.cgi][Cygwin Package Search]]

In order to *install Cygwin's packages* through the terminal instead of running
the setup every single time you need one, you can install ~apt-cyg~.  As
a requirement, you'll need to install ~lynx~ through the cygwin setup first.
After that, just run the following commands:

#+begin_src shell
lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg > apt-cyg
install apt-cyg /bin
#+end_src

- Archive
  + [X] ~unzip~
  + [X] ~zip~ (used by the "Org to ODT" exporter)

- Database
  + [X] ~freetds~ (for ~tsql~)

- Devel
  + [ ] ~autoconf~
  + [ ] ~bzr~
  + [ ] ~ctags~ (Exuberant Ctags)
  + [ ] ~gcc-core~ (C compiler)
  + [ ] ~gcc4~ (needed for installing some Perl packages, for CSV2Ledger)
  + [X] ~gdb~
  + [X] ~git~
  + [X] ~make~ (for making info for Git Org mode)
  + [X] ~meld~ (for diffing -- requires ~xinit~)
  + [ ] ~mercurial~ (for ~hg~ command, used by Beamer)
  + [X] ~patch~
  + [X] ~patchutils~
  + [X] ~subversion~ (for ~svn~ command)

- Editors
  + [X] ~emacs~
  + [X] ~emacs-el~ (needed to get more up-to-date sources, such as for Org)
  + [X] ~emacs-w32~ (for graphical Cygwin Emacs with the w32 graphics toolkit)

- Graphics
  + [X] ~ghostscript~ (needed by various utilities -- ~texlive~ for example)
  + [ ] ~gnuplot~
  + [X] ~graphviz~ (~dot~)
  + [X] ~poppler~ (for ~pdftotext~)

- Interpreters
  + [ ] ~m4~

- Libs
  + [ ] ~libbz2-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiconv~
  + [ ] ~libicu-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiodbc-devel~ (needed for installing RODBC inside R)

- Math
  + [X] ~R~

- Net
  + [X] ~bind-utils~ (for ~dig~, ~host~, ~nslookup~, etc.)
  + [X] ~curl~
  + [X] ~inetutils~ (for getting ~telnet~ to work with expect)
  + [ ] ~nc~ (see socat)
  + [ ] ~openssh~
  + [ ] ~ping~ (Note: Allow to "Run this program as an administrator")
  + [ ] ~rsync~
  + [X] ~sitecopy~
  + [ ] ~socat~ (see ~nc~)

- Perl
  + [ ] ~perl~

- Publishing
  + [X] ~texlive~ (= TeX only, not LaTeX!  It requires ~fontconfig~ and ~ghostscript~)
  + [X] ~texlive-collection-binextra~ (for ~latexmk~)
  + [X] ~texlive-collection-fontsextra~ (for =libertine.sty=)
  + [X] ~texlive-collection-fontsrecommended~ (for =marvosym.sty=, etc.)
  + [X] ~texlive-collection-genericrecommended~ (for =ulem.sty=, etc.)
  + [X] ~texlive-collection-langfrench~ (for ~frenchb~)
  + [X] ~texlive-collection-latex~
  + [X] ~texlive-collection-latexextra~ (for =draftwatermark.sty=, etc.)
  + [X] ~texlive-collection-science~ (for =siunitx.sty=, etc.)

- Python
  + [X] ~python~

- Ruby
  + [ ] ~ruby~

- Shells
  + [ ] ~rxvt~
  + [X] ~zsh~

- System
  + [X] ~procps-ng~ (to get ~top~ and ~pkill~)
  + [ ] ~psmisc~ (to get ~killall~)

- Tcl
  + [ ] ~expect~

- Text
  + [ ] ~antiword~
  + [X] ~aspell~ (Note that the Win32 binary has *much* more dictionaries! Use that
    one instead if you need "nl" language...)
  + [ ] ~most~
  + [ ] ~opensp~ (for ~nsgmls~ validator)
  + [X] ~texinfo~ (for ~makeinfo~)
  + [ ] ~tidy~

- Utils
  + [X] ~colordiff~ (for ~svn~)
  + [ ] ~dos2unix~
  + [ ] ~fdupes~
  + [ ] ~file~ to determine file type
  + [ ] ~flog~ (logger, to syslog)
  + [X] ~gnupg~ (for ~gpg~) -- requiring ~libusb0~ (though you don't need to install
    the Win32 driver which is adviced!)
  + [X] ~ncurses~ (provides ~tput~ and the ~clear~ command used by the TeX Live
    installer, though you can use ~C-l~ to get the same result)
  + [ ] ~screen~
  + [ ] ~sgrep~ (installs the XPath command ~xmllint~, with ~libxml2~)
  + [X] ~the_silver_searcher~ (ag)
  + [X] ~tig~ (Git browser)
  + [X] ~xmlstarlet~

- X11
  + [ ] ~fontconfig~ (needed by XeTeX)
  + [X] ~xinit~ (needed by ~meld~)
    See [[id:02ba0b6b-f205-42e2-a801-4271aa4691eb][Display]].

- Web
  + [ ] ~wget~

Many Unix commands have already newer and more feature-rich
replacements:

- df :: pydf
- less :: most
- tail :: multitail
- top :: htop
- tracepath :: mtr
- traceroute :: mtr

*** Terminal emulators

For a better Emacs experience than with the Cygwin console, use:

- MinTTY
- (u)rxvt
- xterm

#+begin_tip
*Searching text in scrollback buffer (in Cygwin MinTTY)*

In mintty, ~Alt-F3~ opens a search bar with an input field for a search string.
Matches are highlighted in the scrollback buffer.  ~Enter~ / ~Shift+Enter~ find the
~next~ / ~previous~ position of the match and scrolls the scrollback buffer
accordingly.  The appearance of the search bar and the matching highlight
colours can be customized.

See [[https://mintty.github.io/mintty.1.html][man page]].
#+end_tip

*** GnuPG

When first running ~gpg~:

- Directory =~/.gnupg= created
- New configuration file =~/.gnupg/gpg.conf= created
- Keyring =~/.gnupg/secring.gpg= created
- Keyring =~/.gnupg/pubring.gpg= created

*** Suppress the Cygwin DOS path warning

When first running ~M-x ediff-buffers~, I got this Cygwin warning:

#+begin_example
MS-DOS style path detected: c:/Users/...
Preferred POSIX equivalent is: /cygdrive/c/Users/...
CYGWIN environment variable option "nodosfilewarning" turns off this warning.
Consult the user's guide for more details about POSIX paths:
  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
#+end_example

Though, setting it in =.bashrc= or something like that does not work. A good
place to set it is in the global *Windows environment variables*.

** Basic installation

ShellRC is installed by doing the following:

1. *Clone the repository:*

   #+begin_src shell
   git clone git@github.com:fniessen/dotfiles.git ~/.dotfiles
   ~/.dotfiles/install
   #+end_src

2. *Source ShellRC configuration files*

   #+begin_src shell
   . ./bash_profile
   #+end_src

   #+begin_src shell
   . .zprofile
   #+end_src

   Or...

   #+begin_src shell :results silent
   if [ -d "$HOME/.dotfiles/files" ]; then
       PATH="$HOME/.dotfiles/files:$PATH"
   fi
   #+end_src

Once you open up a new terminal window with Bash or Zsh, it should load with
ShellRC's configuration.

** Custom directory

If you'd like to change the install directory with the ~ZSH~ environment variable,
either by running export ZSH=/your/path before installing,

* About portability

To look for existing commands, don't use ~which~ (because it is not in POSIX so
its output format is unspecified, and it complains when nothing is found instead
of being silent):

#+begin_src shell
if $(which ag 2>&1 /dev/null); then alias grep='ag'; fi
#+end_src

As well, don't use the non-portable ~(())~ and ~[[]]~ constructs:

#+begin_src shell
if (( $+commands[ag] )) ; then alias grep='ag'; fi
[[ -s $(which ag) ]] && alias grep='ag'
#+end_src

Instead use:

#+begin_src shell
type ag > /dev/null && alias grep='ag'
#+end_src

* Startup files

# See http://zsh.sourceforge.net/Guide/zshguide02.html

There are 3 *types of shells*:

- (interactive) *login*

  (for which =c:/cygwin/etc/profile= and =.profile= are read, which sources =.bashrc=
  as well)

  #+begin_note
  Launching Cygwin Terminal (login shell) does not load =.bashrc= on its own, it
  only loads =.bash_profile=. Hence, the need to have a =.bash_profile= sourcing
  =.bashrc=...
  #+end_note

- *interactive* (non-login)

  (for which =.bashrc= is read)

- normal shell

  i.e. one that's running a *script* (Bash does not execute any initialization
  file in this case!)

  ~$tty~ is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For Bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.

#+begin_src shell :tangle ../../home/.bash_profile
# User dependent .bash_profile file

# Source the user's .bashrc if it exists.
if [ -f "${HOME}/.bashrc" ]; then
    . "${HOME}/.bashrc"
fi
#+end_src

- For Zsh, put stuff in =~/.zprofile=, which is always executed.

To recover the default Bash configuration files, get their copy from
=/etc/skel=.

See http://blog.flowblok.id.au/2013-02/shell-startup-scripts.html for a Dotty
graph of the files...

#+begin_note
If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.
#+end_note

** What to put where?

Login shell runs =.profile= (or =.bash_profile= or =.bash_login=) on startup. Set your
env variables in there, because sub-shells will inherit the env vars. Then make
=.profile= run your =.bashrc=:

#+begin_src shell
. .bashrc
#+end_src

Interactive runs =.bashrc=. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare minimum. Therefore
your ~PATH~ won't work very well so you often have to give an absolute pathname
like in ~crontab~:

#+begin_src shell
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** What to put in your Zsh startup files

See http://zsh.sourceforge.net/Guide/zshguide02.html.

* Configuration related to Bash
:PROPERTIES:
:header-args+: :tangle ../../home/.bashrc
:END:

Le ~!~ en shell permet plein de trucs sympa.

- ~!!~ refait la dernière commande
- ~!cmd~ refait la dernière commande commençant par ~cmd~
- ~!cmd:p~ permet de visualiser sans éxecuter la dernière commande commençant
  par ~cmd~
- ~!$~ est le dernier mot de la ligne de commande précédente
- ~!cmd:$~ est le dernier mot du dernier ligne de commande commençant par ~cmd~
- ~!*~ est l'ensemble de la dernière ligne de commande à part le premier mot

Pourquoi ce dernier est-il utile ?  Pense à ceci :

#+begin_src shell :tangle no
$ gm convret -size 120x120 input.png -resize 120x120 -draw "gravity southeast text 0,0 'Dave Neary'" output.jpg
bash: convret: command not found
$ gm convert !*
#+end_src

** Preamble

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src shell :noweb yes
## bash_profile --- Bourne Again Shell configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

#* Code:
#+end_src

#+begin_src shell :noweb yes
# If running in terminal...
if test -t 1; then
    # ... start Zsh directly (when I open "Bash on Ubuntu on Windows" for example)
    echo "Execute Zsh..."
    which zsh && exec zsh
fi
#+end_src

To test, open the Terminal and type the following, and it should say zsh.

#+begin_src shell :tangle no
echo $0
#+end_src

Prevent "stdin is not a tty" errors when ~ssh~'ing to a remote machine (or using
~scp~, ~rcp~ or ~rsync~):

#+begin_src shell
# If not running interactively, don't do anything.
[[ "$-" != *i* ]] && return
#+end_src

it's important to refrain from outputting anything in those cases.

** Source global rc file (if any)

#+begin_src shell
# Source global definitions only if the session is interactive.
if ([ $(expr index "$-" i) -ne 0 ] && [ -f /etc/bashrc ]); then
    . /etc/bashrc
fi
#+end_src

A common cause is ~mesg y~ in =/etc/bashrc= on the remote machine, hence the user
has to try avoiding sourcing it (on the *remote* machine) in non-interactive
sessions.

** Command history

Access and modify commands that you had previously typed at the command line.

#+begin_src shell
# History.
# HISTFILE="$HOME/.bash_history"        # If paranoiac, `/dev/null'.
HISTSIZE=1000
HISTFILESIZE=2000
HISTIGNORE="&:[bf]g:exit"
HISTCONTROL=ignoredups
#+end_src

** Prompt

Appearance of the prompt.

Note ~\[...\]~ used by the shell to count proper length.

#+begin_src shell :tangle no
if tput setaf 1 &> /dev/null; then
    tput sgr0
    if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
      MAGENTA=$(tput setaf 9)
      ORANGE=$(tput setaf 172)
      GREEN=$(tput setaf 190)
      PURPLE=$(tput setaf 141)
      WHITE=$(tput setaf 256)
    else
      MAGENTA=$(tput setaf 5)
      ORANGE=$(tput setaf 4)
      GREEN=$(tput setaf 2)
      PURPLE=$(tput setaf 1)
      WHITE=$(tput setaf 7)
    fi
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
#+end_src

#+begin_src shell
#** Controlling the Prompt

# Regular colors.
green="\[$(tput setaf 2)\]"
yellow="\[$(tput setaf 3)\]"

# Bold colors.
BLACK="\[$(tput setaf 0; tput bold)\]"
RED="\[$(tput setaf 1; tput bold)\]"
GREEN="\[$(tput setaf 2; tput bold)\]"

reset_color="\[$(tput sgr0)\]"

#*** PROMPT_COMMAND + PS1 --- Default interaction prompt

# To be called just before the prompt is printed.
leuven-before-prompt ()
{
    RET=$?

    # Set a color prompt (unless in Emacs).
    case $TERM in
        cygwin|xterm*|rxvt-unicode)
            # `M-x shell' under Cygwin Emacs.
            # `M-x term' under Cygwin Emacs.
            local color_prompt=yes
            ;;
        emacs)
            # `M-x shell' under EmacsW32.
            local color_prompt=no
            ;;
    esac

    # Colorful prompt, based on whether the previous command succeeded or not.
    if [ $RET -eq 0 ]; then
        HILIT_RET=${GREEN}
    else
        HILIT_RET=${RED}
    fi

    # Replace the `$HOME' prefix by `~' in the current directory.
    if [ "$HOME" = "${PWD:0:${#HOME}}" ]; then
        myPWD="~${PWD:${#HOME}}"
    else
        myPWD=$PWD
    fi

    # How many characters of the path should be kept.
    local pwd_max_length=15

    if [ ${#myPWD} -gt $pwd_max_length ]; then
        local pwd_offset=$(( ${#myPWD} - $pwd_max_length ))
        myPWD="...${myPWD:$pwd_offset:$pwd_max_length}"
    fi

    # Prompt character.
    if [[ $EUID -eq 0 ]]; then
        local PROMPTCHAR="#"
    else
        local PROMPTCHAR="$"
    fi

    if [ "$color_prompt" = "yes" ]; then
        PS1="${green}\u@\h${BLACK}:${reset_color}${yellow}${myPWD}${HILIT_RET} ${RET}${reset_color}${PROMPTCHAR} "
    else
        PS1="\u@\h:${myPWD} ${RET}${PROMPTCHAR} "
    fi
}

# Execute the content of the `PROMPT_COMMAND' just before displaying the `PS1'
# variable.
case "$TERM" in
    "dumb")
        # No fancy multi-line prompt for TRAMP (see `tramp-terminal-type').
        # Don't confuse it!
        PS1="> "
        ;;
    ,*)
        PROMPT_COMMAND=leuven-before-prompt
        ;;
esac

#*** PS2 --- Continuation interactive prompt

#*** PS3 --- Prompt used by "select" inside shell script

#*** PS4 --- Used by "set -x" to prefix tracing output

# Get line numbers when you run with `-x'.
PS4='+'${green}'[$0:${LINENO}]+ '${reset_color}
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

#+begin_tip
Single quotes around ~LINENO~ in ~PS4~; otherwise, *this* line number is taken...
#+end_tip

#+begin_tip
If you are looking at performance issues, put ~$SECONDS~ in the PS4 prompt as
well.
#+end_tip

** Default permissions

#+begin_src shell
# Permissions on newly created files.
umask 022                               # Prevent new dirs and files from being
                                        # group and world writable.
if [[ $EUID -eq 0 ]]; then
    umask 077                           # Stricter.
fi
#+end_src

** Shell options

#+begin_src shell
# Correct minor misspellings of cd pathnames.
shopt -s cdspell
#+end_src

** Miscellaneous

#+begin_src shell
#** 8.6 Programmable Completion

complete -A helptopic help
complete -A hostname ssh telnet nmap ftp ping host traceroute nslookup
#+end_src

#+begin_src shell
# # Get a file's basename, dirname, extension, etc
#
# # Get extension; everything after last '.'.
# ext=${file##*.}
#
# # Basename.
# basename=$(basename "$file")
# # Everything after last '/'.
# basename=${file##*/}
#
# # Dirname.
# dirname=$(dirname "$file")
# # Everything before last '/'.
# basename=${file%/*}
#+end_src

** Source common file

=.shellrc= contains miscellaneous settings common to Bash and Zsh.

An *alias* is a simple string substitution.

#+begin_note
By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).
#+end_note

In general, it should not do more than *change the default options of a command*.

#+begin_src shell
# Source common settings.
. ${HOME}/.shellrc                      # Error displayed if not found.
#+end_src

** Postamble

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: sh
# mode: outline-minor
# sh-shell: bash
# End:

## bash_profile ends here
#+end_src

** InputRC
:PROPERTIES:
:header-args+: :tangle ../../home/.inputrc
:END:

This file controls the behavior of line input editing for programs that use
the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

#+begin_note
Zsh doesn't use the =inputrc= file.
#+end_note

See https://code.google.com/p/mintty/wiki/Tips#Readline_configuration.

#+begin_src shell :noweb yes
## .inputrc --- my Readline Init File

# Copyright (C) 2005-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: readline, dotfile, config

# First, include any system-wide settings (ignored if one has his own
# `.inputrc').
$include /etc/skel/.inputrc
$include /etc/inputrc

# Allow Meta (Alt) key bindings [line added to the top of my `.inputrc'].
set convert-meta on

# Behave like Emacs when editing.
set editing-mode emacs                  # Ctrl-a/e      Start/End of line.
                                        # Ctrl-f/b      Forward/Backward one character.
                                        # Ctrl-d        Delete one character.
                                        # Ctrl-k        Kill line.
                                        # Ctrl-p/n      Previous/Next command in history.
                                        # Ctrl-r        Search for command in history.
                                        # Ctrl-i/TAB    File name completion.

# Some defaults / modifications for the Emacs mode.
$if mode=emacs

# <C-up/down> for searching matching commands from the history.
"\e[1;5A": history-search-backward
"\e[1;5B": history-search-forward

# <C-left/right> to move by whole words.
"\e[1;5C": forward-word
"\e[1;5D": backward-word

Meta-p: history-search-backward
Meta-n: history-search-forward

$endif

# Ignore case while completing.
set completion-ignore-case on

# # Display all alternatives for completion after one tab keypress.
# set show-all-if-ambiguous on

# #* Get Bash to display accented characters (Emacs *Meta Key* Problems in XTerm)

# # Don't strip characters to 7 bits when reading.
# set input-meta on
# # (Synonym of 'meta-flag'.)

# # Display characters with the eighth bit set directly rather than as
# # meta-prefixed characters.
# set output-meta on

## .inputrc ends here
#+end_src

* Configuration related to Zsh
:PROPERTIES:
:header-args+: :tangle ../../home/.zshrc
:END:

Documentation: [[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]].

** Examples

- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)
- [[http://grml.org/zsh/zsh-lovers.html][zsh-lovers]]

** Prerequisites

Install Zsh.

** Preamble

#+begin_src shell :noweb yes
## .zshrc --- Z Shell configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

#* Code:
#+end_src

#+begin_src shell
# Don't inherit the value of PS1 from the previous shell (Zsh from Bash).
PS1=$'%{\e]0;%d\a%}\n%F{green}%n@%m %F{yellow}%d%f\n%# '
#+end_src

** Add a new theme: Solarized

- [[https://github.com/altercation/solarized/issues/90][How should bold/bright be handled by terminal emulators?]]
- [[https://github.com/mintty/mintty/issues/683][Solarized bold colors are gray]]

Karlin Fox ported the Solarized theme to MinTTY (the terminal which comes by
default with Cygwin), and it is available at [[https://github.com/karlin/mintty-colors-solarized][karlin/mintty-colors-solarized]].

#+begin_src shell :tangle no
git clone https://github.com/karlin/mintty-colors-solarized.git \
    "$HOME/.dotfiles/plugins/mintty-colors-solarized"
#+end_src

#+begin_src shell
FILE="$HOME/.dotfiles/plugins/mintty-colors-solarized/mintty-solarized-dark.sh" && test -f $FILE && . $FILE

# XXX Check for MinTTY
if [ -d /cygdrive/c/ ]; then
    echo -ne '\e]4;8;#404040\a'     # bold blk
    echo -ne '\e]4;9;#FF4040\a'     # bold red
    echo -ne '\e]4;10;#40FF40\a'    # bold grn
    echo -ne '\e]4;11;#FFFF40\a'    # bold yel
    echo -ne '\e]4;12;#6060FF\a'    # bold blu
    echo -ne '\e]4;13;#FF40FF\a'    # bold mag
    echo -ne '\e]4;14;#40FFFF\a'    # bold cyn
    echo -ne '\e]4;15;#FFFFFF\a'    # bold wht
fi
#+end_src

https://github.com/oumu/mintty-color-schemes
https://github.com/mintty/mintty/wiki/Tips
http://mintty.github.io/mintty.1.html#CONFIGURATION
https://stackoverflow.com/questions/24229406/how-to-get-vim-on-cygwin-to-display-right-colors

See great (more portable) stuff at
https://github.com/jimeh/git-aware-prompt/blob/master/colors.sh!

** Install Powerline-patched fonts

*Powerline patched* versions of the most popular mono *fonts* are available at
[[https://github.com/powerline/fonts][powerline/fonts]].

Make sure to change the font of MinTTY:

- Right click the title bar of the Terminal, click Options.
- Change your font to a Powerline patched font you installed.

#+begin_note
If you right-click them, there should be install option in the menu. Or you can
drag it straight to Windows Fonts folder
#+end_note

Test if it's working correctly by running:

#+begin_src shell :tangle no
echo "\ue0b0 \u00b1 \ue0a0 \u27a6 \u2718 \u26a1 \u2699"
#+end_src

Good-looking fonts:
- UbuntuMono
- DejaVuSansMono
- DroidSansMono (bad?)

For Consolas, use: https://github.com/runsisi/consolas-font-for-powerline.

** Install "Oh My Zsh"

Oh My Zsh is just awesome!

#+begin_src shell :tangle no
git clone ...
#+end_src

#+begin_note
We put Oh My Zsh at the very beginning, so that it does not override our own
settings.
#+end_note

#+begin_src shell
if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then
    ZSH="$HOME/.dotfiles/plugins/oh-my-zsh"
    # ${ZSH_CUSTOM:-~/.dotfiles/plugins/oh-my-zsh/custom}
    ZSH_CUSTOM="$ZSH/custom"

    HIST_STAMPS="yyyy-mm-dd"            # See command `history'.

    COMPLETION_WAITING_DOTS="true"
fi
#+end_src

http://marc-abramowitz.com/archives/2012/04/10/fix-for-oh-my-zsh-git-svn-prompt-slowness/

** Change the Oh My Zsh theme to "agnoster"

# I am fan of ~agnoster~.
#
# #+begin_src shell
# if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then
#     ZSH_THEME="agnoster"
# fi
# #+end_src

*** Agnoster Theme Adaption for SVN

#+begin_src shell
if [ -r "$ZSH" ]; then
    prompt_svn() {
        local rev branch
        if in_svn; then
            rev=$(svn_get_rev_nr)
            branch=$(svn_get_branch_name)
            if [[ $(svn_dirty_choose_pwd 1 0) -eq 1 ]]; then
                prompt_segment yellow black
                echo -n "$rev@$branch"
                echo -n " ±"
            else
                prompt_segment green black
                echo -n "$rev@$branch"
            fi
        fi
    }
fi
#+end_src

** Install Powerlevel9k!

#+begin_src shell :tangle no
git clone https://github.com/bhilburn/powerlevel9k.git \
    ${ZSH_CUSTOM}/themes/powerlevel9k
#+end_src

#+begin_src shell
if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then
    ZSH_THEME="powerlevel9k/powerlevel9k"

    # Single-line prompt.
    POWERLEVEL9K_PROMPT_ON_NEWLINE=false
    POWERLEVEL9K_RPROMPT_ON_NEWLINE=false

    POWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=''
    POWERLEVEL9K_MULTILINE_LAST_PROMPT_PREFIX=''

    # Customise the Powerlevel9k prompts.
    POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(ssh dir vcs)
    POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status command_execution_time time background_jobs)

    POWERLEVEL9K_STATUS_VERBOSE=false
    POWERLEVEL9K_STATUS_OK_IN_NON_VERBOSE=true
    POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=10
    POWERLEVEL9K_TIME_FORMAT="%D{%H:%M}"
fi
#+end_src

** Plugins

#+begin_src shell
if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then

    plugins=(
        colored-man-pages
        extract
        # git                           # Provide many aliases and a few useful functions.
        history
        history-substring-search
        svn
        zshmarks
    )
fi
#+end_src

*** Display colored man pages

#+begin_seealso
[[file:~/.minttyrc][.minttyrc]] to *fix colors* and fonts.  See [[http://mintty.googlecode.com/svn-history/r1065/trunk/docs/mintty.1.html][mintty Manual Reference Pages]] for more
information.
#+end_seealso

#+begin_src shell
if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then
    # Fix Colorize man pages (with `less` pager) not working in Cygwin MinTTY
    export MANROFFOPT="-c"
    # in your shell rc file. This has the same effect as
    # export GROFF_NO_SGR=1
    # but only affects man. I'm not sure if groff is used for anything else
    # besides man pages, but this seems safer to prevent unintended side
    # effects.
fi
#+end_src

*** Zsh Syntax Highlighting

Besides the syntax highlighting for your shell, this plugin has the capability
to verify the correctness of your command.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \
    ${ZSH_CUSTOM}/plugins/zsh-syntax-highlighting
#+end_src

#+begin_src shell
if [ -r "$ZSH_CUSTOM/plugins/zsh-syntax-highlighting" ]; then
    plugins+=(zsh-syntax-highlighting)
fi
#+end_src

*** Zsh Autosuggestions

It suggests commands based on your command history.  Very useful!  To select the
proposed command, press the right arrow key.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-autosuggestions \
    ${ZSH_CUSTOM}/plugins/zsh-autosuggestions
#+end_src

#+begin_src shell
if [ -r "$ZSH_CUSTOM/plugins/zsh-autosuggestions" ]; then
    plugins+=(zsh-autosuggestions)
fi
#+end_src

*** Load Zsh tools

#+begin_src shell
if [ -r "$HOME/.dotfiles/plugins/oh-my-zsh" ]; then
    . $ZSH/oh-my-zsh.sh
fi
#+end_src

** Command history

#+begin_src shell
# History.
HISTSIZE=1000
SAVEHIST=2000

# Append new history lines instead of overwriting (important for multiple
# parallel Zsh sessions!).
setopt appendhistory

# Don't save command more than once when occuring more often.
setopt HIST_IGNORE_DUPS

# Use the same history file for all sessions.
setopt SHARE_HISTORY

# Change directory given just path.
setopt autocd

# Beep when there's an error with the command text you're typing in (e.g. if you
# hit tab and there are no matching files) -- not as a result of normal commands
# returning errors.
setopt beep

# Use additional pattern matching features.
setopt extendedglob

# Unmatched patterns cause an error.
setopt nomatch

# Immediately report changes in background job status.
setopt notify
#+end_src

** Zsh line editor

Useful keybindings:

- ~M-q~ ::
     Type another command in the middle of a long command (look at ~man~, etc.):
     you can push the current command to the buffer stack, and after executing
     another command, you can see the top of the stack popped.

- ~M-.~ ::
     Recall the last argument of the previous command, and so on.

- ~C-r~ ::
     Do an interactive search across all of the *command history*.

Useful commands:

- ~vared VAR~ ::
     Interactively edit variable ~VAR~.

#+begin_note
See [[file:~/.dotfiles/plugins/oh-my-zsh/lib/key-bindings.zsh]] for extra key bindings.
#+end_note

#+begin_src shell
# Behave like Emacs when editing.
bindkey -e

# Mappings for `Ctrl-up/down' for matching commands from the history.
bindkey ';5A' history-search-backward
bindkey ';5B' history-search-forward

# Mappings for `Ctrl-left/right' for word moving.
bindkey ';5C' forward-word
bindkey ';5D' backward-word

# Make Zsh beep like Bash when backspacing on an empty command line.
backward-delete-char-beep ()
{
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep
#+end_src

** Completion Widgets

Zsh will attempt to complete wildcards by expanding them in the command line.

#+begin_src shell
# zstyle :compinstall filename '/cygdrive/d/Users/fni/.zshrc'

# Load general completion.
autoload -Uz compinit
# compinit                                # Security check (insecure directories)!
#+end_src

#+begin_src shell
# Display a list of completions when you give an ambiguous choice (like Bash).
setopt autolist
#+end_src

** Prompt

Zsh expects that every character in ~PS1~ will advance the cursor one space.  Wrap
any non-printing escape sequences in ~%{...%}~, and it should work. So use
~%{\e[31m%}~, etc.

#+begin_src shell :tangle no
# Some colors.
BLACK=$(tput setaf 0; tput bold)
RED=$(tput setaf 1; tput bold)
green=$(tput setaf 2)
GREEN=$(tput setaf 2; tput bold)
yellow=$(tput setaf 3)
reset_color=$(tput sgr0)
#+end_src

*************** TODO Define colors using ~terminfo~
See http://superuser.com/questions/239290/how-can-i-make-zsh-show-that-there-are-stashed-revisions-on-a-git-repo-whenever
*************** END

For the prompt, the tricky part was getting the syntax for testing the exit
code.  The syntax is ~%(x.true-string.false-string)~, where ~x~ is some arbitrary
testing condition, in this case, ~?~ for exit codes.  After the first dot, if the
test passes, show ~true-string~; if it fails, show ~false-string~ after the second
dot.

#+begin_src shell :tangle no
# Custom prompt settings.
PROMPT="$green%n@%m$BLACK:$yellow%2. %(?.$GREEN.$RED)%?$reset_color%(!.#.$) "
                                        # ? - Exit code of the previous command.
                                        # n - User name.
                                        # m - Machine name.
                                        # . - Abbreviated pwd.
                                        # ! - su?
#+end_src

Insert beep when last command has failed.

#+begin_tip
For portability and readability, we use the ~tput~ command.

But since it's an external command, we run it once to get the bel sequence, and
then stick that sequence in the relevant part of our prompt -- for performance,
to avoid an unnecessary shellout at each prompt evaluation.
#+end_tip

#+begin_src shell
BEL=$(tput bel)
PROMPT+='%(?::$BEL)'
# Does not work on Bash on Ubuntu on Windows.
#+end_src

To get a blank line before the prompt, you can write a function to echo a blank
line and adding it to your ~preexec~ or ~precmd~ hooks.

Technically, it doesn't insert a line after each commands output, but inserts
a blank line before building the prompt. However, the end result is the
same.

#+begin_src shell
function echo_blank() {
    echo
}

# preexec_functions+=echo_blank
precmd_functions+=echo_blank
#+end_src

Don't confuse TRAMP:

#+begin_src shell
[ "$TERM" = "dumb" ] && PROMPT="> "
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

*** Right prompt

Don't confuse TRAMP:

#+begin_src shell
[ "$TERM" = "dumb" ] && RPROMPT=""
#+end_src

** Aliasing

Some global aliases (expand whatever their position).

*** Common aliases

#+begin_src shell
# Command line head / tail shortcuts
alias -g H='| head' ###
alias -g T='| tail' ###
alias -g G='| grep -E' ######
alias -g L="| less" #######
alias -g M="| less"
alias -g CA="| cat -A"
alias -g 21="2>&1"
alias -g NUL='> /dev/null 2>&1'
#+end_src

#+begin_src shell
alias -g W='| wc -l' ####
alias -g C='| wc -l'
alias -g S='| sort' ###
alias -g F=' | fmt -' ##

alias -g A='| awk'
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g ,1="| awk -F, '{print \$1}'"
alias -g ,2="| awk -F, '{print \$2}'"
alias -g ,3="| awk -F, '{print \$3}'"
alias -g ,4="| awk -F, '{print \$4}'"
alias -g ,5="| awk -F, '{print \$5}'"
alias -g ,6="| awk -F, '{print \$6}'"
alias -g ,7="| awk -F, '{print \$7}'"
alias -g ,8="| awk -F, '{print \$8}'"
alias -g ,9="| awk -F, '{print \$9}'"
alias -g :1="| awk -F: '{print \$1}'"
alias -g :2="| awk -F: '{print \$2}'"
alias -g :3="| awk -F: '{print \$3}'"
alias -g :4="| awk -F: '{print \$4}'"
alias -g :5="| awk -F: '{print \$5}'"
alias -g :6="| awk -F: '{print \$6}'"
alias -g :7="| awk -F: '{print \$7}'"
alias -g :8="| awk -F: '{print \$8}'"
alias -g :9="| awk -F: '{print \$9}'"
alias -g T1="| awk -F $'\t' '{print \$1}'"
alias -g T2="| awk -F $'\t' '{print \$2}'"
alias -g T3="| awk -F $'\t' '{print \$3}'"
alias -g T4="| awk -F $'\t' '{print \$4}'"
alias -g T5="| awk -F $'\t' '{print \$5}'"
alias -g T6="| awk -F $'\t' '{print \$6}'"
alias -g T7="| awk -F $'\t' '{print \$7}'"
alias -g T8="| awk -F $'\t' '{print \$8}'"
alias -g T9="| awk -F $'\t' '{print \$9}'"

alias -g ND='$(ls -d *(/om[1]))'        # Newest directory.
alias -g NF='$(ls *(.om[1]))'           # Newest file.
#+end_src

#+begin_src shell
alias -- cdwd='cd $(pwd)'
alias -- cwd='echo $cwd'
#+end_src

*** Git

Git last week / month / year:

#+begin_src shell
alias -g GLWEEK=' --since=1.week.ago'
alias -g GLMONTH=' --since=1.month.ago'
alias -g GLYEAR=' --since=1.year.ago'
#+end_src

*** Directories

#+begin_src shell
# When entering a directory, list the contents.
cd() { builtin cd "$@" && ls; }
#+end_src

** Ledger

#+begin_src shell
export LEDGER=ledger
export LEDGER_FILE=/Users/fni/Personal/Business/Accounting/LEDGER.dat

# hledger print [REGEXP]... - Show entries in Ledger format.
    #! `hledger' is better than `ledger' in the sense that it does output
    #! 2 decimals whatever the figure, and that it does not output trailing
    #! spaces. There is no other difference (not even in indentation).

# Other problem with ledger: reports onto 81 columns when using other DATEFMT...

alias -g LG="\$LEDGER -f \$LEDGER_FILE"
alias -g DATEFMT='-y %Y/%m/%d'  # for output
alias -g DAILY='--period "daily"'
alias -g DLM='--display "d>=[last month]"'  # display of last month
alias -g CLM='-p "last month"'  # computed total of last month
alias -g D1='--display "l<=1" --depth 1'
alias -g D2='--display "l<=2" --depth 2'
alias -g BALANCE_SHEET='^Assets ^Liabilities'
alias -g PROFIT_LOSS='^Expenses ^Income'

alias lastmonth='LG reg TLM'

# Ledger -f FILE [OPTIONS] [COMMAND [PATTERNS]]
# Ledger using `ledger', `hledger' or `beancount' (see `$LEDGER')
Ledger ()
{
    if [ $# -lt 1 ]; then
        cat << EOF > /dev/stderr
Usage: $(basename $0) -f FILE [OPTIONS] [COMMAND [PATTERNS]]
    or $(basename $0) FILE   (if LEDGER=beancount)
EOF
    fi

    case ${LEDGER} in
        "beancount" )
            ;;

        * )   # default option
            shift;  # for the useless (but expected) `-f'
            ;;
    esac
    local LEDGER_M4_FILE=$1; shift;

    local LEDGER_FILE=sample-ledger.dat;
    case ${LEDGER} in
        "beancount" )
            m4 -D LEDGER=beancount ${LEDGER_M4_FILE} |\
            sed -e 's/\(.*\)(\(.*\)) \(.*\)/\1\3 | \2/g' > ${LEDGER_FILE}
            bean-web ${LEDGER_FILE} $@   # beancount Web interface
            ;;

        * )   # default option
            m4 ${LEDGER_M4_FILE} |\
            sed -e 's/^@/;@/' > ${LEDGER_FILE}
            ${LEDGER} -f ${LEDGER_FILE} $@
            ;;
    esac
    rm ${LEDGER_FILE}
}
#+end_src

#+begin_src shell :tangle no
# cat file.ledger | sed -e 's/@check/;@check/' | xargs bean-web

# Use wrapper scripts around gpg with armor on (The --armor option means ascii
# versus binary). You'll have to enter a password every time you want to run
# ledger.
#+end_src

** 20. Completion System

#+begin_src shell
# Case-insensitive completion.
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
#+end_src

Launch Windows applications from CLI (with ~start~ script -- see
https://github.com/babun/babun/issues/299#issuecomment-123925935):

#+begin_src shell
compdef '_files -g "*"' start
#+end_src

** Zsh Modules

#+begin_src shell
# Coloring stderr.
STDERRRED=$'\e[1;31m'
zmodload zsh/system
color_err () {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    while sysread
    do
        syswrite -o 2 "${STDERRRED}${REPLY}$terminfo[sgr0]"
    done
}

exec 2> >( color_err )
#+end_src

** Source common file

#+begin_src shell
# Source common settings.
. ${HOME}/.shellrc                      # Error displayed if not found.
#+end_src

#+begin_src shell
# Enable overriding.
if [ -f ${HOME}/.zshrc_local ]; then
    . ${HOME}/.zshrc_local
fi
#+end_src

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: sh
# mode: outline-minor
# End:

## .zshrc ends here
#+end_src

* Configuration related to both shells
:PROPERTIES:
:header-args+: :tangle ../../home/.shellrc
:END:

Everything in common between Bash and Z shell will come here, since it is read
by both shells.

** Preamble

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .shellrc --- Common features between Bash and Z Shell

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

** Paths

*** Search path

Specify the directories that the shell is to look through to find a command.
These directories are searched in the order in which they appear.

The global search ~PATH~ is defined in the file =/etc/environment=.

#+begin_src shell
#* PATH

# Extend the PATH var (where to look for executable files).
for MAYBE_PATH in "${HOME}/.dotfiles/bin" \
                  "${HOME}/.dotfiles/expect";
do
    # `-e' or `-x'?
    if [ -d "$MAYBE_PATH" ]; then
        PATH="$MAYBE_PATH:$PATH"
    fi
done

# Extend the PATH var (where to look for executable files).  For Cygwin only.
case $(uname -s) in
    CYGWIN*)
        for MAYBE_CYG_PATH in "${HOME}/.dotfiles/winbin";
        do
            # `-e' or `-x'?
            if [ -d "$MAYBE_CYG_PATH" ]; then
                PATH="$MAYBE_CYG_PATH:$PATH"
            fi
        done
        ;;
esac
#+end_src

#+begin_note
~PATH~ should already be marked as exported, so reexporting is not needed.

Run ~export~ to see a list of exported variables (names marked to be passed to
child processes in the environment).

Since ~env~ is an independent executable (=/usr/bin/env=), it only sees the
variables that the shell passes to it, or */exported/ environment variables*
(which are passed on to every executed program).

~set~ on the other hand is a /built-in/ shell command, it also *sees local shell
variables* (which are only accessible from the current shell) -- including shell
functions.
#+end_note

By default, the ~root~ shell does not load commands from the current location.  If
you're ~root~ and if you trust those commands, type ~./whatever-command~ instead.

If you add the ~CWD~ (~.~) to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src shell
# Add the current directory as last component in the search path (not to include
# for `root', for security reasons).
if [[ $EUID -ne 0 ]]; then
    PATH="$PATH:."
fi
#+end_src

*** Cdpath

Much like the ~PATH~ environment variable defines a search order for the
executable you want, ~CDPATH~ provides a selection of directories which will be
checked for the folder you are trying to ~cd~ into.

#+begin_src shell
# Search current directory, home directory, and Tomcat folder
export CDPATH=".:~:/cygdrive/d/Dev/Tools/Tomcat"
#+end_src

#+begin_tip
To go to the directory ~1-Clients~, for example, simply type ~c~.
#+end_tip

*** Manpath

#+begin_src shell
#* MANPATH

# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
#if [ -d "$HOME/man" ]; then
#    MANPATH="$HOME/man":"${MANPATH}"
#    export MANPATH
#fi

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'
#+end_src

*** Infopath

#+begin_src shell
#* INFOPATH

# Info readers (standalone + Emacs Info mode)
INFOPATH="/usr/share/info:$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
# INFOPATH="$HOME/texlive/2014/texmf/doc/info:$INFOPATH"
#+end_src

** Pager

Set the user's preferred *text viewer* (~cat~, ~more~ or ~less~) that will be used by
programs such as ~man~ or ~git diff~.

~less~ is faster than anything else around (with exception of possibly ~more~, but
this one feels really archaic).

#+begin_src shell
PAGER="less"
#+end_src

With the ~less~ command, you can *scroll up* in the file as well as down; with the
~more~ command, you can only *scroll down* the file.

#+begin_src shell
alias more="less"
#+end_src

*** Less

Color any command with man-like output, including ~git help~:

#+begin_src shell
export LESS_TERMCAP_mb=$'\e[1;31m'
export LESS_TERMCAP_md=$'\e[1;31m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[1;44;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;32m'
#+end_src

~less~ options:

- ~-e~ or ~--quit-at-eof~ ::
     Causes ~less~ to automatically exit the second time it reaches end-of-file.
     By default, the only way to exit ~less~ is via the ~q~ command.

- ~-F~ ::
     Causes ~less~ to automatically *exit if the entire file can be displayed on
     the first screen*.

     #+begin_warning
     After quitting so, the screen is reset and you end up not seeing the
     content; the ~-X~ option does away with that behavior.
     #+end_warning

- ~-i~ or ~--ignore-case~ ::
     Causes searches to ignore case; that is, uppercase and lowercase are
     considered identical.  This option is ignored if any uppercase letters
     appear in the search pattern; in other words, if a pattern contains
     uppercase letters, then that search does not ignore case.

- ~-m~ or ~--long-prompt~ ::
     Causes less to prompt verbosely (like ~more~), with the percent into the
     file.  By default, ~less~ prompts with a colon.

- ~-M~ or ~--LONG-PROMPT~ ::
     Causes ~less~ to prompt even more verbosely than ~more~.

- ~-r~ or ~--raw-control-chars~ ::
     Causes "raw" control characters to be displayed.  The default is to display
     control characters using the caret notation; for example, a ~control-A~
     (octal ~001~) is displayed as ~^A~.

     #+begin_warning
     When the ~-r~ option is used, ~less~ cannot keep track of the actual appearance
     of the screen (since this depends on how the screen responds to each type
     of control character).  Thus, various display problems may result, such as
     long lines being split in the wrong place.
     #+end_warning

- ~-R~ or ~--RAW-CONTROL-CHARS~ ::
     (Only) ANSI "*color*" escape sequences (sequences of the form ~ESC[...m~ where
     the ~...~ is zero or more color specification characters, and ~m~ ends ANSI
     color escape sequences) are *output* in "raw" form.

     #+begin_note
     Without ~--RAW-CONTROL-CHARS~ (or ~--raw-control-chars~), ~less~ outputs the
     colors as raw escape codes, that is it does not *interpret colors*. With it,
     ~git diff~ finally shows colors...
     #+end_note

- ~-X~ or ~--no-init~ ::
     *Disables* sending the termcap initialization and deinitialization strings to
     the terminal.  This is sometimes desirable if the deinitialization string
     does something unnecessary, like *clearing the screen*.

     #+begin_note
     If you want that ~less~ does not *clear the terminal* when quitting, use the ~-X~
     option.
     #+end_note

#+begin_src shell
# Tailor `less'.
LESS="-F -i -M -R -X"
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'
#+end_src

--quit-if-one-screen or -F: Exit if the entire file can be displayed in one screen. This is usually desirable as there is no incentive to stay in less if a single screen can display all the contents.
--ignore-case or -i: Cause search in less to ignore case unless an uppercase letter is present in the search pattern.
--status-column or -J: Display a status column on the left to indicate lines that match current search or indicate the first unread line after moving a full page.
--LONG-PROMPT or -M: Prompt more verbosely.
--RAW-CONTROL-CHARS or -R: Cause ANSI "color" escape sequences to be displayed in their raw form. This is for the color display explained later in the next section.
--HILITE-UNREAD or -W: Highlight the first unread line after scrolling the screen for more than one lines.
--tabs=4 or -x4: Display a tab as 4-character width, since most modern text files assume 4-character width for a tab. However, you can still change this to your preference if, for example, you frequently read Linux kernel source code which uses 8-character width for a tab.
--no-init or -X: Disable sending the termcap initialization and deinitialization strings to the terminal. The purpose here is to prevent clearing screen after exiting. If you do not want this feature and want to remove it, please keep in mind that --quit-if-one-screen also relies on this option to work properly. For a workaround, please check out here.
--window=-4 or -z-4: Change the default scrolling size to 4 lines fewer than the current screen size, so always keep 4 lines overlapping with previous screen when scrolling with the space key.

**** Searching

- ~/pattern~ ::
     Search forward for (~N~-th) matching line.

- ~?pattern~ ::
     Search backward for (~N~-th) matching line.

- ~n~ ::
     Repeat previous search (for ~N~-th occurrence).

- ~N~ ::
     Repeat previous search in reverse direction.

- ~ESC-u~ ::
     Undo (toggle) search highlighting.

- ~&pattern~ ::
     Display only matching lines. \\
     If pattern is empty (if you type & immediately followed by ENTER), any
     filtering is turned off, and all lines are displayed.

*** Most

To add a bit of color to your man pages, you can install ~most~.

See http://www.cyberciti.biz/faq/unix-linux-color-man-pages-configuration/.

#+begin_note
~most~ does not *highlight search results*: when searching using ~/~, it only scrolls
to the location...
#+end_note

** Display
:PROPERTIES:
:ID:       02ba0b6b-f205-42e2-a801-4271aa4691eb
:END:

#+begin_src shell
# Start x11 server (if a process instance is not already running).
# ps -ae | grep XWin || startxwin >/dev/null 2>&1 &   # XXX For Cygwin only!
# To check that have the package xinit installed, try 'startxwin' without redirecting anything.

# Set DISPLAY environment variable.
export DISPLAY=:0.0
#+end_src

** Alert

Add an "alert" alias for long running commands.

Use like so:

: sleep 10; alert

#+begin_src shell
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

** Misc

You may need to manually set your language environment (among others, for ~svn~
with accented file names in the repository).

#+begin_src shell
export LANG=C.UTF-8
#+end_src

** Terminal types

- ~dumb~
- ~cygwin~
- ~emacs~
- ~screen~
- ~xterm~
- ~xterm-256color~
- ~eterm-color~

Set the *terminal type* explicitly to get a nice *256 color* palette (instead of the
ugly default 8 colors):

#+begin_src shell :tangle no
export TERM=xterm-256color
#+end_src

#+begin_tip
In fact, we are advised to *NOT* set ~TERM~ variable in dotfiles that are related to
the shell, as opposed to dotfiles related to the terminal emulator program.
This is because a shell may be used with multiple terminal emulators, and
setting ~TERM~ there is obviously a misplacement mistake, an all too common one...
The proper place to override the ~TERM~ value is in a terminal emulator dotfile,
something like =~/.minttyrc=.
#+end_tip

Initialize the terminal according to the type of terminal in the environmental
variable ~TERM~.

#+begin_src shell
# tput init                             # This resets the Solarized color theme!!!
#+end_src

#+begin_note
This command should be included in everyone's =.profile= after the environmental
variable ~TERM~ has been exported.
#+end_note

#+begin_seealso
Use the script ~colortest~ (on Linux distros) to output the default colors.
#+end_seealso

See what your color palet is for the terminal session:

#+begin_src shell :tangle no
tput colors
#+end_src

** Emacs (default editor)

Be sure one of these *editors* is *in your search path*!

#+begin_warning
Right now, I have instead hard-coded the path to Emacs in the
[[file:~/.dotfiles/local/bin/emacsclient]] script.
#+end_warning

#+begin_src shell
# Find a suitable editor.
for editor in emacsclientw emacsclient emacs; do
    if $(type $editor >& /dev/null); then
        # Set EDITOR.
        case $editor in
            emacsclient*)
                # # doesn't bother waiting for a response
                # export EDITOR="$editor --no-wait"

                # From the man page for emacsclient(1):
                # If the Emacs server is not running, run `emacs --daemon' to
                # start Emacs in daemon mode, and try to connect to it.
                export EDITOR="$editor --alternate-editor=''"
                ;;
            ,*)
                export EDITOR="$editor"
                ;;
        esac

        alias e="$EDITOR"
        break
    fi
done
#+end_src

#+begin_src shell :tangle no
alias e="emacsclient --alternate-editor=emacs --no-wait" # --no-wait is an essential part.
alias e="emacsclient --tty --alternate-editor=''"
#+end_src

#+begin_src shell
alias ek="emacsclient -e '(kill-emacs)'"
#+end_src

#+begin_note
Shouldn't we alias ~EDITOR~ to ~emacs --tty~?
#+end_note

#+begin_src shell
# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"                 # For `crontab'.
export CVSEDITOR="$EDITOR"
export SVN_EDITOR="$EDITOR"
export EDIT="$EDITOR"
export ERROR_EDITOR="$EDITOR"
export FCEDIT="$EDITOR"                 # For the `fc' (fix command) builtin
                                        # command.
#+end_src

#+begin_src shell
alias em=emacs-minimal
#+end_src

#+begin_src shell
# ec FILE - open FILE in a running Emacs
ec ()
{
    emacsclient --no-wait "$1"
}
#+end_src

I connect to the server with either a terminal or a GUI client like this:

#+begin_example
alias et=emacsclient --tty              # New GUI frame.
alias ec=emacsclient --create-frame     # New terminal frame.
#+end_example

A good way to start emacsclient is with this line:

#+begin_example
alias e="emacsclient --no-wait --alternate-editor=\"\" --create-frame"
#+end_example

You may also set the environment variables =EDITOR= and/or =VISUAL=, but then you
better omit the "=--no-wait=" option.

** Plugins

Aliases are abbreviations or alternative names (usually mnemonics) for
commands. They are commonly used to specify a few options to commands, and
then include the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like ~$1~.

#+begin_src shell
# Grep through the aliases.
alias agrep='alias | grep -i'
#+end_src

*** Common aliases

~ls~ options:

- ~-a~ ::
     Do not ignore entries starting with ~.~.

- ~-C~ ::
     List entries by *columns*.

- ~-F~ ::
     Append indicator (one of ~*/=>@|~) to entries.

- ~-g~ ::
     Like ~-l~, but do not list owner.

- ~--group-directories-first~ ::
     Group directories before files.

- ~-G~ ::
     In a long listing, don't print *group* names.

- ~-h~ ::
     With ~-l~ and/or ~-s~, print *human readable* sizes (e.g., ~1K~ ~234M~ ~2G~).

- ~-l~ ::
     Use a *long* listing format.

- ~-s~ ::
     Print the allocated *size* of each file, in blocks.

#+begin_src shell
LS_OPTIONS="$LS_OPTIONS --show-control-chars"

# Make `ls' produce ISO 8601 format.
export TIME_STYLE=long-iso

# Enable color support of `ls'.
if [ "$TERM" != "dumb" ]; then

    # Add my coloration scheme to directory listings.
    if [ -f "$HOME/.dircolors" ]; then
        eval "$(dircolors -b $HOME/.dircolors)"
        # See https://github.com/seebi/dircolors-solarized.
    else
        eval "$(dircolors -b)"
    fi

    alias ls='ls --color=auto -F'
    alias ll='ls --color=auto -a --group-directories-first -G -h -l'
                                        # Long listing and hidden files.
else
    alias ls='ls -CF'
fi
#+end_src

*************** TODO Beautify the terminal's ls command, with color and font-awesome icons
https://github.com/athityakumar/colorls
*************** END

Sort of tree:

#+begin_src shell
alias dirf='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'
#+end_src

~df~ options:

- ~-h~ ::
     Print sizes in powers of 1024 (e.g., ~1023M~).

- ~-k~ ::
     Like ~--block-size=1K~.

- ~-T~ ::
     Print file system type.

Make ~df~ human readable.

#+begin_src shell
alias df='df -kTh'
#+end_src

Make ~du~ human readable.

#+begin_src shell
alias du='du -kh'

alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'         # Ordered by size.
#+end_src

List all the files in this directory, and sort by human-readable file size.

#+begin_src shell
alias sizes="du --max-depth=1 -k | sort -nr | cut -f2 | xargs -d '\n' du -sh"
#+end_src

#+begin_src shell
alias fd='find . -type d -name'
alias ff='find . -type f -name'
#+end_src

#+begin_src shell
# Play safe!  Prevent some accidental mistakes.
alias rm='rm -i'                        # Confirm removing file.
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.
#+end_src

#+begin_note
The above aliases *alter* the *original* meaning of existing commands -- that
scripts don't expect to see modified!
#+end_note

#+begin_src shell
# Make an extract function!
alias tgz="tar -zxvf"
alias tbz2="tar -jxvf"
#+end_src

Interesting alias in Oh My Zsh: ~x~ / ~extract~ to extract an archive of types
tar.{bz2,gz,xz,lzma}, bz2, rar, gz, tbz2, tgz, zip, Z, 7z.

#+begin_src shell
# Print a more readable PATH (each directory on a new line).
alias path='echo $PATH | sed -e "s/:/\n/g"'
alias path='echo -e ${PATH//:/\\n}'

# Path.
alias where='type -a'
#+end_src

#+begin_src shell
alias mkall="./configure && make && sudo make install"

# sudo'ers
alias root="su - root"

# Make executable.
alias exe='chmod +x'

# Chown current dir and subdirs.
alias own='sudo chown -R $USER'
#+end_src

*** Directories

#+begin_src shell
alias up='cd ..'
alias -- ..='cd ..'

alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# Aliases '-' to 'cd -'.
alias -- -='cd -'
#+end_src

#+begin_src shell
# list last used directories (directory history).
alias d='dirs -v'
#+end_src

Normally, you can use ~cd +1~ to go to the previous directory and so on.
Oh My Zsh made this even more straightforward, now you can use just the number
of the entry in the directory history you want to visit... ~1~.

*** Single char shortcuts for some commands

#+begin_src shell
alias t='tail -f'
alias p="$PAGER"
alias m='man'
alias s='sudo'

alias j='jobs -l'
alias l='ls'
#+end_src

*** Git

#+begin_src shell
alias g='git'
#+end_src

Go to the top of your Git repo.

#+begin_src shell
# alias gitroot="cd $(git rev-parse --show-toplevel)" # Conflict with Oh My Zsh?

# Good alias that will not blow up cd if you aren't in a Git directory.
alias cdroot='git rev-parse && cd "$(git rev-parse --show-toplevel)"'
#+end_src

http://jonas.nitro.dk/tig/manual.html

#+begin_src shell
alias tigs='tig status'                 # Use it all of the time!
alias tigb='tig blame'
alias tigall='tig --all'
alias tigreleases='tig --all --simplify-by-decoration'
#+end_src

http://stackoverflow.com/tags/tig/hot

*** SVN

#+begin_src shell
# Search through files, ignoring .svn directories.
alias svn-find="find . -not \( -name .svn -prune \)"

# Grep a string in every SVN revision of a file.
# Usage: svn-grep-all-rev PATTERN FILE
svn-grep-all-rev() {
    svn log $2 | perl -n -e 'print "$1\n" if m/^r(\d*)\s+/' | (
        while read revision; do
            printf "\e[0;33m%s\e[0m\n" "Revision $revision:"
            svn cat -r $revision $2 | grep $1
            printf "\n"
        done
    )
}
#+end_src

#+begin_src shell
# SVN repository path
alias svn-remote-get-url="svn info | egrep '^URL: (.*)' | sed s/URL\:\ //"
#+end_src

This alias can be used as:

#+begin_src shell :tangle no
svn COMMAND $(svn-remote-get-url)       # Retrieve the full RepoURL.
#+end_src

See [[file:~/.dotfiles/plugins/git-config/SVN.org][SVN aliases]] for more information about these:

#+begin_src shell
alias svn-log="svn log | perl -l40pe 's/^-+/\n/' | less"
#+end_src

#+begin_src shell
# svn-show release-number
function svn-show {
    svn diff -c $1 | less
}

# svn-showtool 123 path/to/file
function svn-showtool {
    svn diff --diff-cmd='meld' -c $1 $2
}
#+end_src

#+begin_src shell
# svn-whatchanged [path/to/file]
alias svn-whatchanged="svn log -v"
#+end_src

#+begin_src shell
# svn-logfile path/to/file
function svn-logfile {
    svn log -q $1 | grep "^r"
}
#+end_src

#+begin_src shell
# svn-unmodify path/to/file
function svn-unmodify {
    svn revert $1
}
#+end_src

#+begin_src shell
# svn-logfile-p path/to/file
function svn-logfile-p {
    svn log --diff $1 | less
}
#+end_src

#+begin_src shell
alias svn-nevermind='read -p "Destroy all local changes? [y/N]" && [[ $REPLY =~ ^[yY] ]] && svn revert . -R && rm -rf $(awk -f <(echo "/^?/{print \$2}") <(svn status) ;)'
#+end_src

Nuclear version which:
- reverts tracked files (discards changes in the working directory), and
- cleans untracked files and directories (removes any new files).

See https://stackoverflow.com/questions/6204572/is-there-a-subversion-command-to-reset-the-working-copy.

**** TODO Color lines in shell (GRC, Supercat, Highlight, etc.)

http://stackoverflow.com/questions/4267400/colour-highlighting-output-based-on-regex-in-shell

highlight-lines-matching-regexp "ERROR"

*Highlight SVN diffs in the Shell (in Cygwin)???*

*** History

Print the history lines matching a pattern.

#+begin_src shell
alias hgrep="history | grep -i"
#+end_src

#+begin_warning
We can't call this alias ~hg~ as that conflicts with the Mercurial prompt of the
Agnoster theme (checking for the presence of the ~hg~ command).
#+end_warning

Show the top 10 most used commands in your history.

#+begin_src shell :tangle no
history | awk '{print $2}' | awk 'BEGIN {FS="|"} {print $1}' | sort | uniq -c | sort -nr | head -10
#+end_src

*** Screen

Connect to a host in a new screen tab, with the device name as the tab title.

#+begin_src shell :tangle no
function s()
{
    screen -t "$@" /usr/bin/ssh "$@"
}

alias screen="screen -U"
alias resume='screen -D -R'
alias sr='screen -r'
#+end_src

*** SSH agent / GPG agent
:PROPERTIES:
:header-args+: :tangle no
:END:

Most of our servers don't listen to SSH on a public VLAN. I can't be bothered to
keep a tunnel open on my laptop when away from the office:

#+begin_src shell
zugzug() { ssh -A -p <non_standard_port> -t <proxy_server> ssh $1; }
#+end_src

While it's a function and not an alias, I find it invaluable.

#+begin_src shell
alias keyon="ssh-add -t 10800"          # Add identity.
alias keyoff="ssh-add -D"               # Remove all identities.
alias keylist="ssh-add -l"              # List all identities.
#+end_src

#+begin_src shell
# gpg.
searchkey ()
{
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@";
}
#+end_src

#+begin_src shell
# Get gpg-key from keyserver.
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'
#+end_src

*** Debian
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
alias aps='aptitude search'
#+end_src

*** System admin (NMAP, etc.)
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
# Use `pkill' (which is pgrep + kill in a single command).

# Show only my processes.
alias mytop='top -u $USERNAME'
#+end_src

#+begin_src shell
# My traceroute.
type mtr >& /dev/null && alias ping=mtr

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 Compare /proc with ps (against rootkits).
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# # 040210 Grep.
# alias g='find . -type f -print0 | xargs -0 grep'
#+end_src

#+begin_src shell
# Echo my current external IP address.
type curl >& /dev/null && alias whatismyip='curl -s http://whatismyip.org'
#+end_src

#+begin_src shell
# 040319 Send files via `netcat'.
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/}|nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'
#+end_src

#+begin_src shell
# Honor embedded linefeeds when displaying packets.
alias ngrep='ngrep -W byline'

# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23

alias sniff='sudo ngrep -d "enp6s0" -t "^(GET|POST) " "tcp and port 80"'
#+end_src

#+begin_src shell
alias ports="netstat -alpe --ip"
#+end_src

#+begin_src shell
# alias scan="nmap -sS -O"
alias nm="nmap -sS -O -PI -PT"
alias portscan="nmap -sT -PT -R "
alias nmap_fast="nmap -F -T5 --top-ports 300"
#+end_src

#+begin_src shell
# nmap ()
# {
#     echo "Enter port #"
#     read port
#     echo "Enter IP range"
#     read range
#     sudo nmap -sT -p $port -P0 -v -T 4 -oG dump-$port-${range////_}.txt $range
#     grep -i open dump-$port-${range////_}.txt
# }
#+end_src

#+begin_src shell :tangle no
inpath() { [[ -x "$(which "$1" 2>/dev/null)" ]]; }

inpath nmap && {
    # -- [ nmap ] ---------------------------------------------------
    #  -sS - TCP SYN scan
    #  -v - verbose
    #  -T1 - timing of scan. Options are paranoid (0), sneaky (1), polite (2), normal (3), aggressive (4), and insane (5)
    #  -sF - FIN scan (can sneak through non-stateful firewalls)
    #  -PE - ICMP echo discovery probe
    #  -PP - timestamp discovery probe
    #  -PY - SCTP init ping
    #  -g - use given number as source port
    #  -A - enable OS detection, version detection, script scanning, and traceroute (aggressive)
    #  -O - enable OS detection
    #  -sA - TCP ACK scan
    #  -F - fast scan
    #  --script=vulscan - also access vulnerabilities in target
    alias nmap_open_ports="nmap --open"
    alias nmap_list_interfaces="nmap --iflist"
    alias nmap_slow="nmap -sS -v -T1"
    alias nmap_fin="nmap -sF -v"
    alias nmap_full="nmap -sS -T4 -PE -PP -PS80,443 -PY -g 53 -A -p1-65535 -v"
    alias nmap_check_for_firewall="nmap -sA -p1-65535 -v -T4"
    alias nmap_ping_through_firewall="nmap -PS -PA"
    alias nmap_fast="nmap -F -T5 --version-light --top-ports 300"
    alias nmap_detect_versions="nmap -sV -p1-65535 -O --osscan-guess -T4 -Pn"
    alias nmap_check_for_vulns="nmap --script=vulscan"
    alias nmap_full_udp="nmap -sS -sU -T4 -A -v -PE -PS22,25,80 -PA21,23,80,443,3389 "
    alias nmap_traceroute="nmap -sP -PE -PS22,25,80 -PA21,23,80,3389 -PU -PO --traceroute "
    alias nmap_full_with_scripts="sudo nmap -sS -sU -T4 -A -v -PE -PP -PS21,22,23,25,80,113,31339 -PA80,113,443,10042 -PO --script all "
    alias nmap_web_safe_osscan="sudo nmap -p 80,443 -O -v --osscan-guess --fuzzy "
}
#+end_src

#+begin_src shell
# localnet - Find the local network in CIDR notation.
localnet ()
{
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}

# whoisonline [TARGET] - List hosts that are online.
whoisonline ()
{
    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Discovering online hosts in $net..."
    sudo nmap -sP $net | awk '/Host / && / up/ { print $0; }'
}

# localps [TARGET] - List open ports on hosts that are online.
localps ()
{
    local hostip
    local t1
    local t2
    local t3

    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi

    for hostip in $(nmap -sP $net | grep -E 'Host .* up' | cut -d " " -f2-2);
    do
        t1=$(ping -c 4 $hostip | grep -e PING | cut -d " " -f1-2 | cut -d " " -f2-4) ;
        t2=$(ping -c 4 $hostip | grep -e rtt | cut -d "/" -f5-5) ;
        t3=$(sudo nmap -sS $hostip | grep " open ") ;
        echo -e $t1 " " $t2 "ms\n" $t3 "\n";
    done
}

# watchport HOST PORT - Watch TCP port PORT on machine HOST.
watchport ()
{
    while true; do clear; nmap $1 -PN -p $2; sleep 5; done
}

# rdns [TARGET] - Perform reverse DNS lookups.
rdns ()
{
    local net
    if [ -n "$1" ]; then
      net="$1"
    else
      net=$(localnet)
    fi
    echo "Performing reverse DNS lookups in $net..."
    nmap -R -sL $net |\
    awk '{if ($3 != "not") print "Host " $3 " is " $2}' | grep '('
    # You could add "--dns-servers x.x.x.x" after the "-sL" if you need the
    # lookups to be performed on a specific DNS server.
}
#+end_src

#+begin_src shell
# Resume getting a partially-downloaded file.
alias wget='wget -c'

# Anonymous wget (using Privoxy and Tor).
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror="wget -v --tries=0 --continue --force-directories --mirror --no-parent"
#+end_src

#+begin_src shell
alias off='sudo shutdown -h now'
#+end_src

*** Org

#+begin_src shell
org_test () {
    (
        cd "$HOME/Public/Repositories/org-mode";
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

*** Grep

#+begin_note
~GREP_OPTIONS~ is dangerous because it applies in scripts that may be relying on
the exact set of options that they pass to ~grep~ (~--color=auto~ is about the only
safe thing you can put there); it's even officially *deprecated* since ~grep~ 2.21.
It is better to make ~grep~ itself an alias (and also ~egrep~ and ~fgrep~ if you use
them).
#+end_note

#+begin_src shell
# Display the matched pattern in color.
alias grep='grep --color=auto'
alias egrep='grep -E --color=auto'
alias fgrep='grep -F --color=auto'
#+end_src

#+begin_warning
If you use ~--color=always~, it'll use color even when piping, which confuses
things.
#+end_warning

Change the color of ~grep~:

#+begin_src shell
export GREP_COLOR="0;30;43"
#+end_src

#+begin_note
The colors are defined by the environment variable ~GREP_COLORS~ (used in ~grep~
2.5.2 and later versions). The *deprecated* environment variable ~GREP_COLOR~ (used
in ~grep~ 2.5.1) is still supported, but its setting does not have priority.

But apparently, this is not the case on my system. ~GREP_COLOR~ is the one that
worked...
#+end_note

#+begin_src shell
# Grep through the running processes.
alias pgrep='pgrep -fl'
#+end_src

*** Ripgrep

#+begin_src shell
alias rg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold'"
alias srg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold' --sort-files"
#+end_src

*** Ag, the Silver Searcher

[[https://blog.kowalczyk.info/software/the-silver-searcher-for-windows.html][The Silver Searcher windows port]]

#+begin_src shell :tangle no
type ag 2>&1 /dev/null && alias grep=ag
#+end_src

*** GraphicsMagick

#+begin_src shell
# GraphicsMagick.
alias GIF="gm convert -verbose -interlace LINE"
alias thumb="gm convert -geometry 100x100 -interlace LINE -verbose"
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize ()
{
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES
    do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # Obscure but useful string operations.
        # (See http://www.arachnoid.com/linux/shell_programming.html.)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

*** Other things to sort

#+begin_src shell
# List all files modified in the last 24 hours (last full day).
alias oneday='find . -mtime -1 -print'

# List all files modified today only (since start of day only, i.e. 00:00).
today ()
{
    touch -t $(date +%m%d0000) /tmp/$$
    find . -type f -newer /tmp/$$
    rm -f /tmp/$$
}
#+end_src

#+begin_src shell
export GS_OPTIONS="-sPAPERSIZE=a4"
alias pdfmerge="gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./pdf-joined.pdf" # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

#+begin_src shell
# clean [-r] - Remove useless files (recursively).
clean ()
{
    if [ "$1" = "-r" ]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" -o \
            -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" -o \
            -name "*.~BASE~" -o -name ".*.~BASE~" \) -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}

# swap FILE1 FILE2 - Swap FILE1 and FILE2.
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap ()
{
    if [ $# != 2 ]; then
        return 1
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f $1 $tmpfile
    mv -f $2 $1
    mv -f $tmpfile $2
    return 0
}
#+end_src

#+begin_src shell
saneperms ()
{
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod ${1:=644}
}
#+end_src

#+begin_src shell
# # Search for various types or README file in dir and display them in $PAGER.
# readme ()
# {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }
#+end_src

#+begin_src shell
safetmp ()
{
    test -d "$HOME" || exit 1
    test -d "$HOME/tmp" || mkdir "$HOME/tmp"
    echo "$HOME/tmp/safetmp.$(hostname).$(date +%s).$$"
}
#+end_src

#+begin_src shell
# Immediately opens the first match.
texman ()
{
    locate $* | grep pdf | grep texlive | head -1 | xargs open;
}

texlist ()
{
    locate $* | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)";
}
#+end_src

*** MCit tools

#+begin_src shell
alias sp=sendpatch
#+end_src

*** Extra

#+begin_src shell :tangle no
function console {
    if [[ $# > 0 ]]; then
        query=$(echo "$*" | tr -s ' ' '|')
        tail -f /var/log/system.log | grep -i --color=auto -E "$query"
    else
        tail -f /var/log/system.log
    fi
}
#+end_src

** NMAP

** Postamble

#+begin_src shell
# This is for the sake of Emacs.
# Local Variables:
# End:

# .shellrc ends here
#+end_src

* Java

- Download Ant and add its =/bin= directory to ~PATH~.

- Add =C:\Program Files\Java\jdk1.7.0_80= to ~JAVA_HOME~ and add ~%JAVA_HOME%/bin~
  to ~PATH~.

* FAQ

** How to fix "zsh compinit: insecure directories"?

Stripping these directories of the group write permission:

#+begin_src shell
compaudit | xargs chmod g-w
#+end_src

will do the trick, see [[http://www.wezm.net/technical/2008/09/zsh-cygwin-and-insecure-directories/][zsh, Cygwin and Insecure Directories]].

** How to run Emacs without showing a terminal window?

Use the ~run~ command:

#+begin_src shell
C:\cygwin64\bin\run.exe /usr/bin/emacs
#+end_src
