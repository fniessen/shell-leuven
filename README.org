#+TITLE:     ShellRC-Leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   num:nil ^:{}

#+PROPERTY:  header-args :eval no
# #+SETUPFILE: bigblow-pirilampo.setup
#+SETUPFILE: ~/src/org-html-themes/setup/theme-readtheorg-local-abs.setup

* Summary

ShellRC-Leuven is a set of configuration files to take advantage of Bash and
Zsh on Mac OS X, Linux and Windows (with Cygwin).

* Getting started

** Prerequisites for Windows

Install [[https://www.cygwin.com/][Cygwin]].

*** Notes

- After Cygwin is installed, modify the System ~PATH~ variable: append
  =C:\cygwin\bin= before ~%SystemRoot%\system32~

- If you add other directories (such as =~/bin= or =~/winbin=) in the ~PATH~ before
  Cygwin, please check that those directories don't contain =cygwin1.dll= or
  such. That was why I had troubles running ~git~ commands...

In =c:/cygwin64/etc/profile=,

- =/usr/local/bin= is appended to the ~PATH~!!

  And, except when root, it is almost always wrong to have =/usr/local/bin= after
  any system path.

- ~TZ~ (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from =c:/cygwin/Cygwin.bat=!!

*** Change your Cygwin ~HOME~ folder

Programs like ~ssh~ don't rely on your environment variable ~HOME~ for the location
of your *home directory*.

If you installed Cygwin prior to 1.7.34 or have run its ~mkpasswd~ utility so that
you have an =/etc/passwd= file, you can change your Cygwin ~HOME~ directory by
editing your user's entry in that file. Your ~HOME~ directory is the penultimate
element on your user's line in =/etc/passwd= (the ~HOME~ environment variable is set
from that field).

Starting with Cygwin 1.7.34, the recommended way to do this is to add a custom
~db_home~ setting to =/etc/nsswitch.conf=.

*** Packages

*************** TODO See http://www.4thinker.com/cygwin-setup.html
*************** END

[[http://cygwin.com/cgi-bin2/package-grep.cgi][Cygwin Package Search]]

Install extra packages:

- Archive
  + [ ] ~zip~ used by the "Org to ODT" exporter
  + [ ] ~unzip~

- Devel
  + [X] ~git~
  + [X] ~subversion~ (for ~svn~ command)
  + [X] ~gdb~
  + [X] ~make~ (for making info for Git Org mode)
  + [X] ~patch~ and ~patchutils~
  + [ ] ~autoconf~
  + [ ] ~bzr~
  + [ ] ~cvs~
  + [ ] ~ctags~ (Exuberant Ctags)
  + [ ] ~gcc-core~ (C compiler)
  + [ ] ~gcc4~ (needed for installing some Perl packages, for CSV2Ledger)
  + [ ] ~mercurial~ (for ~hg~ command, used by Beamer)

- Editors
  + [X] ~emacs~
  + [X] ~emacs-w32~ (for graphical Cygwin Emacs with the w32 graphics toolkit)
  + [X] ~emacs-el~ (needed to get more up-to-date sources, such as for Org)

- Graphics
  + [X] ~ghostscript~ (needed by various utilities -- ~texlive~ for example)
  + [ ] ~gnuplot~

- Interpreters
  + [ ] ~m4~

- Libs
  + [ ] ~libbz2-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiconv~
  + [ ] ~libicu-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiodbc-devel~ (needed for installing RODBC inside R)

- Math
  + [X] ~R~

- Net
  + [ ] ~bind-utils~ (for ~dig~, ~host~, ~nslookup~, etc.)
  + [ ] ~inetutils~ (for getting ~telnet~ to work with expect)
  + [ ] ~nc~ (see socat)
  + [ ] ~openssh~
  + [ ] ~ping~ (Note: Allow to "Run this program as an administrator")
  + [ ] ~rsync~
  + [ ] ~socat~ (see nc)

- Perl
  + [ ] ~perl~

- Publishing
  + [X] ~texlive~ (= TeX only, not LaTeX!  It requires ~fontconfig~ and ~ghostscript~)
  + [X] ~texlive-collection-latex~
  + [X] ~texlive-collection-latexextra~ (for =draftwatermark.sty=, etc.)
  + [X] ~texlive-collection-genericrecommended~ (for =ulem.sty=, etc.)
  + [X] ~texlive-collection-fontsrecommended~ (for =marvosym.sty=, etc.)
  + [X] ~texlive-collection-science~ (for =siunitx.sty=, etc.)
  + [X] ~texlive-collection-binextra~ (for ~latexmk~)
  + [X] ~texlive-collection-langfrench~ (for ~frenchb~)
  + [X] ~texlive-collection-fontsextra~ (for =libertine.sty=)

- Python
  + [X] ~python~

- Ruby
  + [ ] ~ruby~

- Shells
  + [X] ~zsh
  + [ ] ~rxvt~

- System
  + [ ] ~procps~ (to get ~top~)
  + [ ] ~psmisc~ (to get ~killall~)

- Tcl
  + [ ] ~expect~

- Text
  + [X] ~texinfo~ (for ~makeinfo~)
  + [ ] ~antiword~
  + [ ] ~aspell~ (Note that the Win32 binary has *much* more dictionaries! Use that
    one instead...)
  + [ ] ~most~
  + [ ] ~opensp~ (for ~nsgmls~ validator)
  + [ ] ~tidy~

- Utils
  + [X] ~gnupg~ (~gpg~)
  + [X] ~ncurses~ (provides the ~clear~ command used by the TeX Live installer,
    though you can use ~C-l~ to get the same result)
  + [X] ~cygutils~ (for ~unix2dos~)
  + [X] ~tig~ (Git browser)
  + [ ] ~fdupes~
  + [ ] ~file~ to determine file type
  + [ ] ~flog~ (logger, to syslog)
  + [ ] ~screen~

- X11
  + [ ] ~fontconfig~ (needed by XeTeX)

- Web
  + [X] ~curl~
  + [ ] ~w3m~
  + [ ] ~wget~

*** Terminal emulators

For a better Emacs experience than with the Cygwin console, use:

- MinTTY
- (u)rxvt
- xterm

*** GnuPG

When first running ~gpg~:

- Directory =~/.gnupg= created
- New configuration file =~/.gnupg/gpg.conf= created
- Keyring =~/.gnupg/secring.gpg= created
- Keyring =~/.gnupg/pubring.gpg= created

*** Suppress the Cygwin DOS path warning

When first running ~M-x ediff-buffers~, I got this Cygwin warning:

#+begin_example
MS-DOS style path detected: c:/Users/...
Preferred POSIX equivalent is: /cygdrive/c/Users/...
CYGWIN environment variable option "nodosfilewarning" turns off this warning.
Consult the user's guide for more details about POSIX paths:
  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
#+end_example

Though, setting it in =.bashrc= or something like that does not work. A good
place to set it is in the global *Windows environment variables*.

*** Suppress the annoying "tty option" warning

#+begin_example
"tty" option detected in CYGWIN environment variable.
CYGWIN=tty is no longer supported.  Please remove it from your
CYGWIN environment variable and use a terminal emulator like mintty,
xterm, or rxvt.
#+end_example

This is not a Cygwin problem: ~Emacs-w3m~ used to set the ~CYGWIN~ environment
variable in =w3m.el=. Just edit that file and remove the setting. Alternatively,
it looks like you could solve the problem by customizing
~w3m-command-environment~.

Though, downloading (via the anonymous CVS server) the latest source code from
http://emacs-w3m.namazu.org/ also solves the problem.

** Basic installation

ShellRC-Leuven is installed by doing the following:

1. *Clone the repository:*

   #+begin_src shell
   git clone git@github.com:fniessen/shellrc-leuven.git ~/.shellrc-leuven
   #+end_src

2. *Source ShellRC-Leuven configuration files*

   #+begin_src shell
   . ~/.shellrc-leuven/etc/bash_profile
   #+end_src

   #+begin_src shell
   . ~/.shellrc-leuven/etc/zprofile
   #+end_src

   Or...

   #+begin_src shell :results silent
   if [ -d "$HOME/.shellrc-leuven/etc" ]; then
       PATH="$HOME/.shellrc-leuven/etc:$PATH"
   fi
   #+end_src

Once you open up a new terminal window with Bash or Zsh, it should load with
ShellRC-Leuven's configuration.

** Custom directory

If you'd like to change the install directory with the ~ZSH~ environment variable,
either by running export ZSH=/your/path before installing,

* Startup files

# See http://zsh.sourceforge.net/Guide/zshguide02.html

There are 3 *types of shells*:

- (interactive) *login*

  (for which =c:/cygwin/etc/profile= and =.profile= are read, which sources =.bashrc=
  as well)

  #+begin_note
  Launching Cygwin Terminal (login shell) does not load =.bashrc= on its own, it
  only loads =.bash_profile=. Hence, the need to have a =.bash_profile= sourcing
  =.bashrc=...
  #+end_note

- *interactive* (non-login)

  (for which =.bashrc= is read)

- normal shell

  i.e. one that's running a *script* (Bash does not execute any initialization
  file in this case!)

  ~$tty~ is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For Bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.

#+begin_src shell :tangle ./etc/.bash_profile
# User dependent .bash_profile file

# Source the user's .bashrc if it exists.
if [ -f "${HOME}/.bashrc" ]; then
  source "${HOME}/.bashrc"
fi
#+end_src

- For Zsh, put stuff in =~/zprofile=, which is always executed.

To recover the default Bash configuration files, get their copy from
=/etc/skel=.

#+begin_note
If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.
#+end_note

** What to put where?

Login shell runs =.profile= (or =.bash_profile= or =.bash_login=) on startup. Set your
env variables in there, because sub-shells will inherit the env vars. Then make
=.profile= run your =.bashrc=:

#+begin_src shell
. .bashrc
#+end_src

Interactive runs =.bashrc=. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare minimum. Therefore
your ~PATH~ won't work very well so you often have to give an absolute pathname
like in ~crontab~:

#+begin_src shell
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** What to put in your Zsh startup files

See http://zsh.sourceforge.net/Guide/zshguide02.html.

* Bash specific
  :PROPERTIES:
  :header-args+: :tangle ./etc/bash_profile
  :END:

Le ~!~ en shell permet plein de trucs sympa.

- ~!!~ refait la dernière commande
- ~!cmd~ refait la dernière commande commençant par ~cmd~
- ~!cmd:p~ permet de visualiser sans éxecuter la dernière commande commençant
  par ~cmd~
- ~!$~ est le dernier mot de la ligne de commande précédente
- ~!cmd:$~ est le dernier mot du dernier ligne de commande commençant par ~cmd~
- ~!*~ est l'ensemble de la dernière ligne de commande à part le premier mot

Pourquoi ce dernier est-il utile ?  Pense à ceci :

#+begin_src shell :tangle no
$ gm convret -size 120x120 input.png -resize 120x120 -draw "gravity southeast text 0,0 'Dave Neary'" output.jpg
bash: convret: command not found
$ gm convert !*
#+end_src

** Preamble

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src shell :noweb yes
## bash_profile --- Bourne Again Shell configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

#* Code:
#+end_src

Prevent "stdin is not a tty" errors when ~ssh~'ing to a remote machine (or using
~rsync~):

#+begin_src shell
# If not running interactively, don't do anything.
[[ "$-" != *i* ]] && return
#+end_src

** Source global rc file (if any)

#+begin_src shell
# Source global definitions only if the session is interactive.
if ([ $(expr index "$-" i) -ne 0 ] && [ -f /etc/bashrc ]); then
    . /etc/bashrc
fi
#+end_src

A common cause is ~mesg y~ in =/etc/bashrc= on the remote machine, hence the user
has to try avoiding sourcing it (on the *remote* machine) in non-interactive
sessions.

** Command history

Access and modify commands that you had previously typed at the command line.

#+begin_src shell
# History.
HISTFILE=$HOME/.bash_history            # If paranoiac, `/dev/null'.
HISTSIZE=1000
HISTFILESIZE=1000
HISTIGNORE="&:[bf]g:exit"
HISTCONTROL=ignoredups
#+end_src

** Prompt

Appearance of the prompt.

Note ~\[...\]~ used by the shell to count proper length.

#+begin_src shell
#** Controlling the Prompt

# Regular colors.
green="\[\e[0;32m\]"
yellow="\[\e[0;33m\]"

# Bold colors.
BLACK="\[\e[1;30m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"

reset="\[\e[0m\]"

#*** PROMPT_COMMAND + PS1 --- Default interaction prompt

# To be called just before the prompt is printed.
leuven-before-prompt ()
{
    RET=$?

    # Set a color prompt (unless in Emacs).
    case $TERM in
        cygwin|xterm*|rxvt-unicode)
            # `M-x shell' under Cygwin Emacs.
            # `M-x term' under Cygwin Emacs.
            local color_prompt=yes
            ;;
        emacs)
            # `M-x shell' under EmacsW32.
            local color_prompt=no
            ;;
    esac

    # Colorful prompt, based on whether the previous command succeeded or not.
    if [ $RET -eq 0 ]; then
        HILIT_RET=${GREEN}
    else
        HILIT_RET=${RED}
    fi

    # Replace the `$HOME' prefix by `~' in the current directory.
    if [ "$HOME" = "${PWD:0:${#HOME}}" ]; then
        myPWD="~${PWD:${#HOME}}"
    else
        myPWD=$PWD
    fi

    # How many characters of the path should be kept.
    local pwd_max_length=15

    if [ ${#myPWD} -gt $pwd_max_length ]; then
        local pwd_offset=$(( ${#myPWD} - $pwd_max_length ))
        myPWD="...${myPWD:$pwd_offset:$pwd_max_length}"
    fi

    # Prompt character.
    if [[ $EUID -eq 0 ]]; then
        local PROMPTCHAR="#"
    else
        local PROMPTCHAR="$"
    fi

    if [ "$color_prompt" = "yes" ]; then
        PS1="${green}\u@\h${BLACK}:${yellow}${myPWD}${HILIT_RET} ${RET}${reset}${PROMPTCHAR} "
    else
        PS1="\u@\h:${myPWD} ${RET}${PROMPTCHAR} "
    fi
}

# Execute the content of the `PROMPT_COMMAND' just before displaying the `PS1'
# variable.
case "$TERM" in
    "dumb")
        # No fancy multi-line prompt for TRAMP (see `tramp-terminal-type').
        # Don't confuse it!
        PS1="> "
        ;;
    ,*)
        PROMPT_COMMAND=leuven-before-prompt
        ;;
esac

#*** PS2 --- Continuation interactive prompt

#*** PS3 --- Prompt used by "select" inside shell script

#*** PS4 --- Used by "set -x" to prefix tracing output

# Get line numbers when you run with `-x'.
PS4='+'${green}'[$0:${LINENO}]+ '${reset}
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

#+begin_tip
Single quotes around ~LINENO~ in ~PS4~; otherwise, *this* line number is taken...
#+end_tip

#+begin_tip
If you are looking at performance issues, put ~$SECONDS~ in the PS4 prompt as
well.
#+end_tip

** Default permissions

#+begin_src shell
# Permissions on newly created files.
umask 022                               # Prevent new dirs and files from being
                                        # group and world writable.
if [[ $EUID -eq 0 ]]; then
    umask 077                           # Stricter.
fi
#+end_src

** Shell options

#+begin_src shell
# Correct minor misspellings of cd pathnames.
shopt -s cdspell
#+end_src

** Miscellaneous

#+begin_src shell
#** 8.6 Programmable Completion

complete -A helptopic help
complete -A hostname ssh telnet nmap ftp ping host traceroute nslookup
#+end_src

#+begin_src shell
# # Get a file's basename, dirname, extension, etc
#
# # Get extension; everything after last '.'.
# ext=${file##*.}
#
# # Basename.
# basename=`basename "$file"`
# # Everything after last '/'.
# basename=${file##*/}
#
# # Dirname.
# dirname=`dirname "$file"`
# # Everything before last '/'.
# basename=${file%/*}
#+end_src

** Source common file

=commonprofile= contains miscellaneous settings common to Bash and Zsh.

An *alias* is a simple string substitution.

#+begin_note
By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).
#+end_note

In general, it should not do more than *change the default options of a command*.

#+begin_src shell
# Source common settings.
: ${SHELLRC_LEUVEN:="$HOME/src/shellrc-leuven"} # Necessary to use $HOME!
. $SHELLRC_LEUVEN/etc/commonprofile
#+end_src

** Postamble

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: sh
# mode: outline-minor
# sh-shell: bash
# End:

## bash_profile ends here
#+end_src

** InputRC
   :PROPERTIES:
   :header-args+: :tangle ./etc/.inputrc
   :END:

This file controls the behavior of line input editing for programs that use
the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

#+begin_note
Zsh doesn't use the =inputrc= file.
#+end_note

See https://code.google.com/p/mintty/wiki/Tips#Readline_configuration.

#+begin_src shell :noweb yes
## .inputrc --- my Readline Init File

# Copyright (C) 2005-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: readline, dotfile, config

# First, include any system-wide settings (ignored if one has his own
# `.inputrc').
$include /etc/skel/.inputrc
$include /etc/inputrc

# Allow Meta (Alt) key bindings [line added to the top of my `.inputrc'].
set convert-meta on

# Behave like Emacs when editing.
set editing-mode emacs                  # Ctrl-a/e      Start/End of line.
                                        # Ctrl-f/b      Forward/Backward one character.
                                        # Ctrl-d        Delete one character.
                                        # Ctrl-k        Kill line.
                                        # Ctrl-p/n      Previous/Next command in history.
                                        # Ctrl-r        Search for command in history.
                                        # Ctrl-i/TAB    File name completion.

# Some defaults / modifications for the Emacs mode.
$if mode=emacs

# <C-up/down> for searching matching commands from the history.
"\e[1;5A": history-search-backward
"\e[1;5B": history-search-forward

# <C-left/right> to move by whole words.
"\e[1;5C": forward-word
"\e[1;5D": backward-word

Meta-p: history-search-backward
Meta-n: history-search-forward

$endif

# Ignore case while completing.
set completion-ignore-case on

# # Display all alternatives for completion after one tab keypress.
# set show-all-if-ambiguous on

# #* Get Bash to display accented characters (Emacs *Meta Key* Problems in XTerm)

# # Don't strip characters to 7 bits when reading.
# set input-meta on
# # (Synonym of 'meta-flag'.)

# # Display characters with the eighth bit set directly rather than as
# # meta-prefixed characters.
# set output-meta on

## .inputrc ends here
#+end_src

* Zsh specific
  :PROPERTIES:
  :header-args+: :tangle ./etc/zprofile
  :END:

Documentation: [[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]].

** Examples

- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)
- [[http://grml.org/zsh/zsh-lovers.html][zsh-lovers]]

** Preamble

#+begin_src shell :noweb yes
## zprofile --- Z Shell configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

#* Code:
#+end_src

** Oh-my-Zsh Agnoster theme

#+begin_note
We put Oh-my-Zsh at the very beginning, so that it does not override our own
settings.

In fact, we should just take the theme, and explicitly disable plugins we're not
interested in...
#+end_note

I am fan of ~agnoster~.

Make sure to use a [[https://github.com/Lokaltog/powerline-fonts][patched up font]] though.

#+begin_note
If you right click them, there should be install option in the menu. Or you can
drag it straight to Windows Fonts folder
#+end_note

Good-looking fonts:
- UbuntuMono
- DejaVuSansMono
- DroidSansMono (bad?)

For Consolas, use: https://github.com/runsisi/consolas-font-for-powerline.

#+begin_src shell
if [ -r "$HOME/.oh-my-zsh" ]; then
    ZSH=$HOME/.oh-my-zsh
    ZSH_THEME="agnoster"
    # plugins=(git osx rails ruby github node rbenv npm brew byte)
    . $ZSH/oh-my-zsh.sh
fi
#+end_src

** Command history

#+begin_src shell
# History.
HISTFILE=$HOME/.histfile
HISTSIZE=1000
SAVEHIST=1000

# Append new history lines instead of overwriting (important for multiple
# parallel Zsh sessions!).
setopt appendhistory

# Don't save command more than once when occuring more often.
setopt HIST_IGNORE_DUPS

# Use the same history file for all sessions.
setopt SHARE_HISTORY
#+end_src

** Prompt

Zsh expects that every character in ~PS1~ will advance the cursor one space.  Wrap
any non-printing escape sequences in ~%{...%}~, and it should work. So use
~%{\e[31m%}~, etc.

#+begin_src shell :tangle no
# Some colors.
local BLACK=$'%{\e[1;30m%}'
local RED=$'%{\e[1;31m%}'
local green=$'%{\e[0;32m%}'
local GREEN=$'%{\e[1;32m%}'
local yellow=$'%{\e[0;33m%}'
local reset=$'%{\e[0m%}'
#+end_src

*************** TODO Define colors using ~terminfo~
See http://superuser.com/questions/239290/how-can-i-make-zsh-show-that-there-are-stashed-revisions-on-a-git-repo-whenever
*************** END

For the prompt, the tricky part was getting the syntax for testing the exit
code.  The syntax is ~%(x.true-string.false-string)~, where ~x~ is some arbitrary
testing condition, in this case, ~?~ for exit codes.  After the first dot, if the
test passes, show ~true-string~; if it fails, show ~false-string~ after the second
dot.

#+begin_src shell :tangle no
# Custom prompt settings.
PROMPT="$green%n@%m$BLACK:$yellow%2. %(?.$GREEN.$RED)%?$reset%(!.#.$) "
                                        # ? - Exit code of the previous command.
                                        # n - User name.
                                        # m - Machine name.
                                        # . - Abbreviated pwd.
                                        # ! - su?
#+end_src

Insert beep when last command has failed.

#+begin_tip
For portability and readability, we use the ~tput~ command.

But since it's an external command, we run it once to get the bel sequence, and
then stick that sequence in the relevant part of our prompt -- for performance,
to avoid an unnecessary shellout at each prompt evaluation.
#+end_tip

#+begin_src shell
BEL=$(tput bel)
PROMPT+='%(?::$BEL)'
#+end_src

To get a blank line before the prompt, you can write a function to echo a blank
line and adding it to your ~preexec~ or ~precmd~ hooks.

Technically, it doesn't inset a line after each commands output, but inserts
a blank line before building the prompt. However, the end result is the
same.

#+begin_src shell
function echo_blank() {
    echo
}

# preexec_functions+=echo_blank
precmd_functions+=echo_blank
#+end_src

Don't confuse TRAMP:

#+begin_src shell
[ "$TERM" = "dumb" ] && PROMPT="> "
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

*** Right prompt with Zsh-Git-prompt

https://github.com/olivierverdier/zsh-git-prompt

#+begin_src shell :tangle no
# Prompt on the right hand side of the screen (Git info).
. ~/Public/Repositories/zsh-git-prompt/zshrc.sh
RPROMPT='$(git_super_status)'
#+end_src

*** Right prompt with Git-prompt

*************** TODO See predefined functions provided by =git-prompt.sh=
http://www.railstips.org/blog/archives/2009/02/02/bedazzle-your-bash-prompt-with-git-info/
*************** END

#+begin_src shell
# . "/cygdrive/c/Program Files (x86)/Git/etc/git-prompt.sh"
. "/cygdrive/d/Users/fni/.oh-my-zsh/plugins/gitfast/git-prompt.sh"
setopt prompt_subst
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true
export GIT_PS1_SHOWUPSTREAM=verbose
export GIT_PS1_DESCRIBE_STYLE=branch
export GIT_PS1_SHOWCOLORHINTS=true
export RPROMPT=$'%{$fg[magenta]%}■%{$reset_color%} $(__git_ps1 "%s")'
#+end_src

Don't confuse TRAMP:

#+begin_src shell
[ "$TERM" = "dumb" ] && RPROMPT=""
#+end_src

** Aliasing

Some global aliases (expand whatever their position).

*** Common aliases

#+begin_src shell
# Command line head / tail shortcuts
alias -g H='| head' ###
alias -g T='| tail' ###
alias -g G='| grep -E' ######
alias -g L="| less" #######
alias -g M="| less"
alias -g CA="| cat -A"
alias -g 21="2>&1"
alias -g DN1='1> /dev/null' #
alias -g DN2='2> /dev/null' #
#+end_src

#+begin_src shell
alias -g W='| wc -l' ####
alias -g C='| wc -l'
alias -g S='| sort' ###
alias -g F=' | fmt -' ##
alias -g A='| awk'
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g ND='$(ls -d *(/om[1]))'        # Newest directory.
alias -g NF='$(ls *(.om[1]))'           # Newest file.
#+end_src

#+begin_src shell
alias -- cdwd='cd `pwd`'
alias -- cwd='echo $cwd'
# alias h='history 1 | less +G'
#+end_src

*** Directories

#+begin_src shell
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
#+end_src

#+begin_src shell
# When entering a directory, list the contents.
cd() { builtin cd "$@" && ls; }
#+end_src

** Ledger

#+begin_src shell
export LEDGER=ledger
export LEDGER_FILE=/Users/fni/Personal/Business/Accounting/LEDGER.dat

# hledger print [REGEXP]... - Show entries in Ledger format.
    #! `hledger' is better than `ledger' in the sense that it does output
    #! 2 decimals whatever the figure, and that it does not output trailing
    #! spaces. There is no other difference (not even in indentation).

# Other problem with ledger: reports onto 81 columns when using other DATEFMT...

alias -g LG="\$LEDGER -f \$LEDGER_FILE"
alias -g DATEFMT='-y %Y/%m/%d'  # for output
alias -g DAILY='--period "daily"'
alias -g DLM='--display "d>=[last month]"'  # display of last month
alias -g CLM='-p "last month"'  # computed total of last month
alias -g D1='--display "l<=1" --depth 1'
alias -g D2='--display "l<=2" --depth 2'
alias -g BALANCE_SHEET='^Assets ^Liabilities'
alias -g PROFIT_LOSS='^Expenses ^Income'

alias lastmonth='LG reg TLM'

# Ledger -f FILE [OPTIONS] [COMMAND [PATTERNS]]
# Ledger using `ledger', `hledger' or `beancount' (see `$LEDGER')
Ledger ()
{
    if [ $# -lt 1 ]; then
        cat << EOF 1>&2
Usage: $(basename $0) -f FILE [OPTIONS] [COMMAND [PATTERNS]]
    or $(basename $0) FILE   (if LEDGER=beancount)
EOF
    fi

    case ${LEDGER} in
        "beancount" )
            ;;

        * )   # default option
            shift;  # for the useless (but expected) `-f'
            ;;
    esac
    local LEDGER_M4_FILE=$1; shift;

    local LEDGER_FILE=sample-ledger.dat;
    case ${LEDGER} in
        "beancount" )
            m4 -D LEDGER=beancount ${LEDGER_M4_FILE} |\
            sed -e 's/\(.*\)(\(.*\)) \(.*\)/\1\3 | \2/g' > ${LEDGER_FILE}
            bean-web ${LEDGER_FILE} $@   # beancount Web interface
            ;;

        * )   # default option
            m4 ${LEDGER_M4_FILE} |\
            sed -e 's/^@/;@/' > ${LEDGER_FILE}
            ${LEDGER} -f ${LEDGER_FILE} $@
            ;;
    esac
    rm ${LEDGER_FILE}
}
#+end_src

#+begin_src shell :tangle no
# cat file.ledger | sed -e 's/@check/;@check/' | xargs bean-web

# Use wrapper scripts around gpg with armor on (The --armor option means ascii
# versus binary). You'll have to enter a password every time you want to run
# ledger.
#+end_src

** Zsh line editor

Useful keybindings:

- ~M-q~ ::
     Type another command in the middle of a long command (look at ~man~, etc.).

- ~M-.~ ::
     Recall the last argument of the previous command, and so on.

- ~C-r~ ::
     Do an interactive search across all of the *command history*.

Useful commands:

- ~vared VAR~ ::
     Interactively edit variable ~VAR~.

#+begin_note
See [[file:~/.oh-my-zsh/lib/key-bindings.zsh]] for extra key bindings.
#+end_note

#+begin_src shell
# Behave like Emacs when editing.
bindkey -e

# Mappings for `Ctrl-up/down' for matching commands from the history.
bindkey ';5A' history-search-backward
bindkey ';5B' history-search-forward

# Mappings for `Ctrl-left/right' for word moving.
bindkey ';5C' forward-word
bindkey ';5D' backward-word

# Beep when there's an error with the command text you're typing in (e.g. if you
# hit tab and there are no matching files) -- not as a result of normal commands
# returning errors.
setopt beep

# Make Zsh beep like Bash when backspacing on an empty command line.
backward-delete-char-beep ()
{
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep
#+end_src

** 19. Completion Widgets

Zsh will attempt to complete wildcards by expanding them in the command line.

#+begin_src shell
# Load general completion.
autoload -Uz compinit && compinit

# Display a list of completions when you give an ambiguous choice (like Bash).
setopt autolist
#+end_src

** 20. Completion System

#+begin_src shell
# Case-insensitive completion.
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
#+end_src

** Zsh Modules

#+begin_src shell
# Coloring stderr.
STDERRRED=$'\e[1;31m'
zmodload zsh/system
color_err () {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    while sysread
    do
        syswrite -o 2 "${STDERRRED}${REPLY}$terminfo[sgr0]"
    done
}

exec 2> >( color_err )
#+end_src

** Others

#+begin_src shell
# Change directory given just path.
setopt autocd

# Use additional pattern matching features.
setopt extendedglob

# Unmatched patterns cause an error.
setopt nomatch

# Immediately report changes in background job status.
setopt notify
#+end_src

** Source common file

#+begin_src shell
# Source common settings.
: ${SHELLRC_LEUVEN:="$HOME/src/shellrc-leuven"} # Necessary to use $HOME!
. $SHELLRC_LEUVEN/etc/commonprofile
#+end_src

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: sh
# mode: outline-minor
# End:

## zprofile ends here
#+end_src

* System-wide configuration file
  :PROPERTIES:
  :header-args+: :tangle ./etc/commonprofile
  :END:

Everything in common between Bash and Z shell will come here, since it is read
by both shells.

** Preamble

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## commonprofile --- Common features between Bash and Z Shell

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

** Paths

*** Search path

Specify the directories that the shell is to look through to find a command.
These directories are searched in the order in which they appear.

The global search ~PATH~ is defined in the file =/etc/environment=.

#+begin_src shell
#* PATH

# Extend the PATH var (where to look for executable files).
for MAYBE_PATH in "$HOME/bin" \
                  "$HOME/expect" \
                  "$HOME/winbin";
do
    # `-e' or `-x'?
    if [ -d "$MAYBE_PATH" ]; then
        PATH="$MAYBE_PATH:$PATH"
    fi
done
#+end_src

#+begin_note
~PATH~ should already be marked as exported, so reexporting is not needed.

Run ~export~ to see a list of exported variables (names marked to be passed to
child processes in the environment).

Since ~env~ is an independent executable (=/usr/bin/env=), it only sees the
variables that the shell passes to it, or */exported/ environment variables*
(which are passed on to every executed program).

~set~ on the other hand is a /built-in/ shell command, it also *sees local shell
variables* (which are only accessible from the current shell) -- including shell
functions.
#+end_note

By default, the ~root~ shell does not load commands from the current location.  If
you're ~root~ and if you trust those commands, type ~./whatever-command~ instead.

If you add the ~CWD~ (~.~) to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src shell
# Add the current directory as last component in the search path (not to include
# for `root', for security reasons).
if [[ $EUID -ne 0 ]]; then
    PATH="$PATH:."
fi
#+end_src

*** Manpath

#+begin_src shell
#* MANPATH

# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
#if [ -d $HOME/man ]; then
#    MANPATH=$HOME/man:"${MANPATH}"
#    export MANPATH
#fi

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'
#+end_src

*** Infopath

#+begin_src shell
#* INFOPATH

# Info readers (standalone + Emacs Info mode)
INFOPATH="/usr/share/info:$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
# INFOPATH="$HOME/texlive/2014/texmf/doc/info:$INFOPATH"
#+end_src

** Pager

Set the user's preferred *text viewer* (~cat~, ~more~ or ~less~) that will be used by
programs such as ~man~ or ~git diff~.

~less~ is faster than anything else around (with exception of possibly ~more~, but
this one feels really archaic).

#+begin_src shell
PAGER="less"
#+end_src

With the ~less~ command, you can *scroll up* in the file as well as down; with the
~more~ command, you can only *scroll down* the file.

#+begin_src shell
alias more="less"
#+end_src

*** Less

~less~ options:

- ~-e~ or ~--quit-at-eof~ ::
     Causes ~less~ to automatically exit the second time it reaches end-of-file.
     By default, the only way to exit ~less~ is via the ~q~ command.

- ~-F~ ::
     Causes ~less~ to automatically *exit if the entire file can be displayed on
     the first screen*.

     #+begin_warning
     After quitting so, the screen is reset and you end up not seeing the
     content; the ~-X~ option does away with that behavior.
     #+end_warning

- ~-i~ or ~--ignore-case~ ::
     Causes searches to ignore case; that is, uppercase and lowercase are
     considered identical.  This option is ignored if any uppercase letters
     appear in the search pattern; in other words, if a pattern contains
     uppercase letters, then that search does not ignore case.

- ~-m~ or ~--long-prompt~ ::
     Causes less to prompt verbosely (like ~more~), with the percent into the
     file.  By default, ~less~ prompts with a colon.

- ~-M~ or ~--LONG-PROMPT~ ::
     Causes ~less~ to prompt even more verbosely than ~more~.

- ~-r~ or ~--raw-control-chars~ ::
     Causes "raw" control characters to be displayed.  The default is to display
     control characters using the caret notation; for example, a ~control-A~
     (octal ~001~) is displayed as ~^A~.

     #+begin_warning
     When the ~-r~ option is used, ~less~ cannot keep track of the actual appearance
     of the screen (since this depends on how the screen responds to each type
     of control character).  Thus, various display problems may result, such as
     long lines being split in the wrong place.
     #+end_warning

- ~-R~ or ~--RAW-CONTROL-CHARS~ ::
     (Only) ANSI "*color*" escape sequences (sequences of the form ~ESC[...m~ where
     the ~...~ is zero or more color specification characters, and ~m~ ends ANSI
     color escape sequences) are *output* in "raw" form.

     #+begin_note
     Without ~--RAW-CONTROL-CHARS~ (or ~--raw-control-chars~), ~less~ outputs the
     colors as raw escape codes, that is it does not *interpret colors*. With it,
     ~git diff~ finally shows colors...
     #+end_note

- ~-X~ or ~--no-init~ ::
     *Disables* sending the termcap initialization and deinitialization strings to
     the terminal.  This is sometimes desirable if the deinitialization string
     does something unnecessary, like *clearing the screen*.

     #+begin_note
     If you want that ~less~ does not *clear the terminal* when quitting, use the ~-X~
     option.
     #+end_note

#+begin_src shell
# Tailor `less'.
LESS="-F -i -M -R -X"
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
#+end_src

Man pages colors:

#+begin_src shell
# Colored man pages: http://linuxtidbits.wordpress.com/2009/03/23/less-colors-for-man-pages/
# Less Colors for Man Pages
export LESS_TERMCAP_mb=$'\E[01;31m'     # enter_blink_mode.
export LESS_TERMCAP_md=$'\E[01;38;5;74m' # enter_bold_mode.
export LESS_TERMCAP_so=$'\E[38;5;016m\E[48;5;220m' # enter_standout_mode (mode
                                                   # line at the bottom).
export LESS_TERMCAP_us=$'\E[04;38;5;146m' # enter_underline_mode.
export LESS_TERMCAP_me=$'\E[0m'         # exit_attribute_mode (end modes like
                                        # `mb' and `md').
export LESS_TERMCAP_se=$'\E[0m'         # exit_standout_mode.
export LESS_TERMCAP_ue=$'\E[0m'         # exit_underline_mode.
# See `terminfo'.
#+end_src

#+begin_seealso
[[file:~/.minttyrc][.minttyrc]] to *fix colors* and fonts.  See [[http://mintty.googlecode.com/svn-history/r1065/trunk/docs/mintty.1.html][mintty Manual Reference Pages]] for more
information.
#+end_seealso

See also
http://stackoverflow.com/questions/10535432/tmux-man-page-search-highlighting to
highlight man pages.

*** Most

To add a bit of color to your man pages, you can install ~most~.

See http://www.cyberciti.biz/faq/unix-linux-color-man-pages-configuration/.

#+begin_note
~most~ does not *highlight search results*: when searching using ~/~, it only scrolls
to the location...
#+end_note

** Misc

You may need to manually set your language environment (among others, for ~svn~
with accented file names in the repository).

#+begin_src shell
export LANG=C.UTF-8
#+end_src

** Terminal types

- ~dumb~
- ~cygwin~
- ~emacs~
- ~screen~
- ~xterm~
- ~xterm-256color~
- ~eterm-color~

Set the *terminal type* explicitly to get a nice *256 color* palette (instead of the
ugly default 8 colors):

#+begin_src shell
export TERM=xterm-256color
#+end_src

#+begin_seealso
Use the script ~colortest~ (on Linux distros) to output the default colors.
#+end_seealso

See what your color palet is for the terminal session:

#+begin_src shell :tangle no
tput colors
#+end_src

** Emacs (default editor)

Be sure one of these *editors* is *in your search path*!

#+begin_warning
Right now, I have instead hard-coded the path to Emacs in the
[[file:~/bin/emacsclient]] script.
#+end_warning

#+begin_src shell
# Find a suitable editor.
for editor in emacsclientw emacsclient emacs; do
    if $(which $editor >& /dev/null); then
        # Set EDITOR.
        case $editor in
            emacsclient*)
                # # doesn't bother waiting for a response
                # export EDITOR="$editor --no-wait"

                # If the Emacs server is not running, run `emacs --daemon' to
                # start Emacs in daemon mode, and try to connect to it.
                export EDITOR="$editor -a ''"
                ;;
            ,*)
                export EDITOR="$editor"
                ;;
        esac

        alias e="$EDITOR"
        break
    fi
done
#+end_src

#+begin_src shell :tangle no
alias e="emacsclient -a emacs -n"       # -n is essential part
#+end_src

#+begin_note
Shouldn't we alias ~EDITOR~ to ~emacs -nw~?
#+end_note

#+begin_src shell
# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"                 # For `crontab'.
export CVSEDITOR="$EDITOR"
export SVN_EDITOR="$EDITOR"
export EDIT="$EDITOR"
export ERROR_EDITOR="$EDITOR"
export FCEDIT="$EDITOR"                 # For the `fc' (fix command) builtin
                                        # command.
#+end_src

#+begin_src shell
alias em=emacs-minimal
#+end_src

#+begin_src shell
# ec FILE - open FILE in a running Emacs
ec ()
{
    emacsclient --no-wait "$1"
}
#+end_src

I connect to the server with either a terminal or a GUI client like this:

#+begin_example
alias et=emacsclient -t                 # New GUI frame.
alias ec=emacsclient -c                 # New terminal frame.
#+end_example

** Plugins

Aliases are abbreviations or alternative names (usually mnemonics) for
commands. They are commonly used to specify a few options to commands, and
then include the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like ~$1~.

#+begin_src shell
# Grep through the aliases.
alias agrep='alias | grep -i'
#+end_src

*** Common aliases

~ls~ options:

- ~-a~ ::
     Do not ignore entries starting with ~.~.

- ~-C~ ::
     List entries by *columns*.

- ~-F~ ::
     Append indicator (one of ~*/=>@|~) to entries.

- ~-g~ ::
     Like ~-l~, but do not list owner.

- ~--group-directories-first~ ::
     Group directories before files.

- ~-G~ ::
     In a long listing, don't print *group* names.

- ~-h~ ::
     With ~-l~ and/or ~-s~, print *human readable* sizes (e.g., ~1K~ ~234M~ ~2G~).

- ~-l~ ::
     Use a *long* listing format.

- ~-s~ ::
     Print the allocated *size* of each file, in blocks.

#+begin_src shell
LS_OPTIONS="$LS_OPTIONS --show-control-chars"

# Enable color support of `ls'.
if [ "$TERM" != "dumb" ]; then

    # # Add my coloration scheme to directory listings.
    # if [ -f $HOME/.dircolors ]; then
    #     eval "$(dircolors -b $HOME/.dircolors)"
    # else
    #     eval "$(dircolors -b)"
    # fi

    alias ls='ls --color=auto -F'
    alias ll='ls --color=auto -a --group-directories-first -G -h -l'
                                        # Long listing and hidden files.
else
    alias ls='ls -CF'
fi
#+end_src

Sort of tree:

#+begin_src shell
alias dirf='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'
#+end_src

~df~ options:

- ~-h~ ::
     Print sizes in powers of 1024 (e.g., ~1023M~).

- ~-k~ ::
     Like ~--block-size=1K~.

- ~-T~ ::
     Print file system type.

Make ~df~ human readable.

#+begin_src shell
alias df='df -kTh'
#+end_src

Make ~du~ human readable.

#+begin_src shell
alias du='du -kh'

alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'         # Ordered by size.
#+end_src

List all the files in this directory, and sort by human-readable file size.

#+begin_src shell
alias sizes="du --max-depth=1 -k | sort -nr | cut -f2 | xargs -d '\n' du -sh"
#+end_src

#+begin_src shell
alias fd='find . -type d -name'
alias ff='find . -type f -name'
#+end_src

#+begin_src shell
# Play safe!  Prevent some accidental mistakes.
alias rm='rm -i'                        # Confirm removing file.
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.
#+end_src

#+begin_note
The above aliases *alter* the *original* meaning of existing commands -- that
scripts don't expect to see modified!
#+end_note

#+begin_src shell
# Make an extract function!
alias tgz="tar -zxvf"
alias tbz2="tar -jxvf"
#+end_src

#+begin_src shell
# Print a more readable PATH (each directory on a new line).
alias path='echo $PATH | sed -e "s/:/\n/g"'
alias path='echo -e ${PATH//:/\\n}'

# Path.
alias where='type -a'
#+end_src

#+begin_src shell
alias mkall="./configure && make && sudo make install"

# sudo'ers
alias root="su - root"

# Make executable.
alias exe='chmod +x'

# Chown current dir and subdirs.
alias own='sudo chown -R $USER'
#+end_src

*** Directories

#+begin_src shell
alias up='cd ..'
alias -- ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# Directory history.
alias d='dirs -v'
#+end_src

*** Single char shortcuts for some commands

#+begin_src shell
alias t='tail -f'
alias p="$PAGER"
alias m='man'
alias s='sudo'

alias j='jobs -l'
alias l='ls'
#+end_src

*** Git

#+begin_src shell
alias g='git'
#+end_src

*** SVN

#+begin_src shell
# Search through files, ignoring .svn directories.
alias svn_find="find . -not \( -name .svn -prune \)"

# Grep a string in every SVN revision of a file.
# Usage: svn_grep_all_rev PATTERN FILE
svn_grep_all_rev() {
    svn log $2 | perl -n -e 'print "$1\n" if m/^r(\d*)\s+/' | (
        while read revision; do
            printf "\e[0;33m%s\e[0m\n" "Revision $revision:"
            svn cat -r $revision $2 | grep $1
            printf "\n"
        done
    )
}
#+end_src

*** History

Print the history lines matching a pattern.

#+begin_src shell
alias hgrep="history | grep -i"
#+end_src

#+begin_warning
We can't call this alias ~hg~ as that conflicts with the Mercurial prompt of the
Agnoster theme (checking for the presence of the ~hg~ command).
#+end_warning

Show the top 10 most used commands in your history.

#+begin_src shell :tangle no
history | awk '{print $2}' | awk 'BEGIN {FS="|"} {print $1}' | sort | uniq -c | sort -nr | head -10
#+end_src

*** Screen

Connect to a host in a new screen tab, with the device name as the tab title.

#+begin_src shell
function s()
{
    screen -t "$@" /usr/bin/ssh "$@"
}

alias screen="screen -U"
alias resume='screen -D -R'
alias sr='screen -r'
#+end_src

*** SSH agent / GPG agent

Most of our servers don't listen to SSH on a public VLAN. I can't be bothered to
keep a tunnel open on my laptop when away from the office:

#+begin_src shell
zugzug() { ssh -A -p <non_standard_port> -t <proxy_server> ssh $1; }
#+end_src

While it's a function and not an alias, I find it invaluable.

#+begin_src shell
alias keyon="ssh-add -t 10800"          # Add identity.
alias keyoff="ssh-add -D"               # Remove all identities.
alias keylist="ssh-add -l"              # List all identities.
#+end_src

#+begin_src shell
# gpg.
searchkey ()
{
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@";
}
#+end_src

#+begin_src shell
# Get gpg-key from keyserver.
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'
#+end_src

#+begin_src shell
encrypt ()
{
    # Use ascii armor.
    gpg -ac --no-options "$1"
}

bencrypt ()
{
    # No ascii armor.
    # Encrypt binary data. jpegs/gifs/vobs/etc.
    gpg -c --no-options "$1"
}

decrypt ()
{
    gpg --no-options "$1"
}

pe ()
{
# Passphrase encryption program
# Created by Dave Crouse 01-13-2006
# Reads input from text editor and encrypts to screen.
    clear
    echo "         Passphrase Encryption Program";
    echo "--------------------------------------------------"; echo "";
    which $EDITOR &>/dev/null
    if [ "$?" != "0" ]; then
        echo "It appears that you do not have a text editor set in your .bashrc file.";
        echo "What editor would you like to use ? " ;
        read EDITOR ; echo "";
    fi
    echo "Enter the name/comment for this message :"
    read comment
    $EDITOR passphraseencryption
    gpg --armor --comment "$comment" --no-options --output
    passphraseencryption.gpg --symmetric passphraseencryption
    shred -u passphraseencryption ; clear
    echo "Outputting passphrase encrypted message"; echo "" ; echo "" ;
    cat passphraseencryption.gpg ; echo "" ; echo "" ;
    shred -u passphraseencryption.gpg ;
    read -p "Hit enter to exit" temp; clear
}

keys ()
{
    # Open up kgpg keymanager.
    kgpg -k
}
#+end_src

*** Debian

#+begin_src shell
alias aps='aptitude search'
#+end_src

*** System admin (NMAP, etc.)

#+begin_src shell
# Use `pkill' (which is pgrep + kill in a single command).

# Show only my processes.
alias mytop='top -u $USERNAME'
#+end_src

#+begin_src shell
# My traceroute.
if $(which mtr >& /dev/null); then
    alias ping=mtr
fi

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 Compare /proc with ps (against rootkits).
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# # 040210 Grep.
# alias g='find . -type f -print0 | xargs -0 grep'
#+end_src

#+begin_src shell
# Echo my current external IP address.
if $(which curl >& /dev/null); then
    alias whatismyip='curl -s http://whatismyip.org'
fi
#+end_src

#+begin_src shell
# 040319 Send files via `netcat'.
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/}|nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'
#+end_src

#+begin_src shell
# Honor embedded linefeeds when displaying packets.
alias ngrep='ngrep -W byline'

# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23
#+end_src

#+begin_src shell
alias ports="netstat -alpe --ip"
#+end_src

#+begin_src shell
# alias scan="nmap -sS -O"
alias nm="nmap -sS -O -PI -PT"
alias portscan="nmap -sT -PT -R "
alias nmap_fast="nmap -F -T5 --top-ports 300"
#+end_src

#+begin_src shell
# nmap ()
# {
#     echo "Enter port #"
#     read port
#     echo "Enter IP range"
#     read range
#     sudo nmap -sT -p $port -P0 -v -T 4 -oG dump-$port-${range////_}.txt $range
#     grep -i open dump-$port-${range////_}.txt
# }
#+end_src

#+begin_src shell
# localnet - Find the local network in CIDR notation.
localnet ()
{
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}

# whoisonline [TARGET] - List hosts that are online.
whoisonline ()
{
    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Discovering online hosts in $net..."
    sudo nmap -sP $net | awk '/Host / && / up/ { print $0; }'
}

# localps [TARGET] - List open ports on hosts that are online.
localps ()
{
    local hostip
    local t1
    local t2
    local t3

    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi

    for hostip in $(nmap -sP $net | grep -E 'Host .* up' | cut -d " " -f2-2);
    do
        t1=$(ping -c 4 $hostip | grep -e PING | cut -d " " -f1-2 | cut -d " " -f2-4) ;
        t2=$(ping -c 4 $hostip | grep -e rtt | cut -d "/" -f5-5) ;
        t3=$(sudo nmap -sS $hostip | grep " open ") ;
        echo -e $t1 " " $t2 "ms\n" $t3 "\n";
    done
}

# watchport HOST PORT - Watch TCP port PORT on machine HOST.
watchport ()
{
    while true; do clear; nmap $1 -PN -p $2; sleep 5; done
}

# rdns [TARGET] - Perform reverse DNS lookups.
rdns ()
{
    local net
    if [ -n "$1" ]; then
      net="$1"
    else
      net=$(localnet)
    fi
    echo "Performing reverse DNS lookups in $net..."
    nmap -R -sL $net |\
    awk '{if ($3 != "not") print "Host " $3 " is " $2}' | grep '('
    # You could add "--dns-servers x.x.x.x" after the "-sL" if you need the
    # lookups to be performed on a specific DNS server.
}
#+end_src

#+begin_src shell
# Anonymous wget (using Privoxy and Tor).
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror="wget -v --tries=0 --continue --force-directories --mirror --no-parent"
#+end_src

#+begin_src shell
alias off='sudo shutdown -h now'
#+end_src

*** Org

For branches for which we want to make some development, and keep in track with
~master~:

#+begin_src shell
update_org () {
    (                                   # Directory changes made in a subshell
                                        # do not carry over to the parent shell.
        cd $HOME/Public/Repositories/org-mode;
        git fetch --all --verbose \
            && git rebase origin \
            && make autoloads \
            && echo DON\'T make clean \
            && echo DON\'T make \
            && echo DON\'T sudo make install \
            && echo DON\'T make doc \
            && make info \
            && sudo make install-info \
            && printf "Running org_test, please wait (this can take a while)...\n" \
            && org_test 2>&1 >/dev/null | tail -n 3
    )
}
#+end_src

*************** TODO Don't regenerate autoloads, doc, etc. if nothing new was pulled

#+begin_src shell
org_test () {
    (
        cd $HOME/Public/Repositories/org-mode;
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

#+begin_src shell
if [ -d "$HOME/Public/Repositories/org-bash-utils" ]; then
    PATH="$HOME/Public/Repositories/org-bash-utils:$PATH"
    source $HOME/Public/Repositories/org-bash-utils/org-alias
    source $HOME/Public/Repositories/org-bash-utils/awk-alias
fi
#+end_src

*** Grep

#+begin_note
~GREP_OPTIONS~ is dangerous because it applies in scripts that may be relying on
the exact set of options that they pass to ~grep~ (~--color=auto~ is about the only
safe thing you can put there); it's even officially *deprecated* since ~grep~ 2.21.
It is better to make ~grep~ itself an alias (and also ~egrep~ and ~fgrep~ if you use
them).
#+end_note

#+begin_src shell
# Display the matched pattern in color.
alias grep='grep --color=auto'
alias egrep='grep -E --color=auto'
alias fgrep='grep -F --color=auto'
#+end_src

#+begin_warning
If you use ~--color=always~, it'll use color even when piping, which confuses
things.
#+end_warning

Change the color of ~grep~:

#+begin_src shell
export GREP_COLOR="0;30;43"
#+end_src

#+begin_note
The colors are defined by the environment variable ~GREP_COLORS~ (used in ~grep~
2.5.2 and later versions). The *deprecated* environment variable ~GREP_COLOR~ (used
in ~grep~ 2.5.1) is still supported, but its setting does not have priority.

But apparently, this is not the case on my system. ~GREP_COLOR~ is the one that
worked...
#+end_note

#+begin_src shell
# Grep through the running processes.
alias pgrep='pgrep -fl'
#+end_src

*** GraphicsMagick

#+begin_src shell
# GraphicsMagick.
alias GIF="gm convert -verbose -interlace LINE"
alias thumb="gm convert -geometry 100x100 -interlace LINE -verbose"
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize ()
{
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES
    do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # Obscure but useful string operations.
        # (See http://www.arachnoid.com/linux/shell_programming.html.)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

*** Other things to sort

#+begin_src shell
# List all files modified in the last 24 hours (last full day).
alias oneday='find . -mtime -1 -print'

# List all files modified today only (since start of day only, i.e. 00:00).
today ()
{
    touch -t `date +%m%d0000` /tmp/$$
    find . -type f -newer /tmp/$$
    rm -f /tmp/$$
}
#+end_src

#+begin_src shell
case $(uname -s) in
    Linux*)
        alias vpnup='sudo test; exec sudo openvpn --config $HOME/.hide/OpenVPN-config/mcbe.ovpn --writepid /tmp/openvpn.pid &'  # --daemon'
        alias vpndown='sudo kill -INT `cat /tmp/openvpn.pid`'
        ;;

    CYGWIN*)
        alias vpnup='cd $HOME/.hide/OpenVPN-config; openvpn --config mcbe.ovpn --writepid c:/cygwin/tmp/openvpn.pid &'  # --daemon'
        alias vpndown='killall openvpn'
        ;;
esac
#+end_src

#+begin_src shell
export GS_OPTIONS="-sPAPERSIZE=a4"
alias pdfmerge="gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./finished.pdf" # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

#+begin_src shell
# clean [-r] - Remove useless files (recursively).
clean ()
{
    if [ "$1" = "-r" ]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" -o \
            -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" -o \
            -name "*.~BASE~" -o -name ".*.~BASE~" \) -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}

# swap FILE1 FILE2 - Swap FILE1 and FILE2.
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap ()
{
    if [ $# != 2 ]; then
        return 1
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f $1 $tmpfile
    mv -f $2 $1
    mv -f $tmpfile $2
    return 0
}
#+end_src

#+begin_src shell
saneperms ()
{
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod ${1:=644}
}
#+end_src

#+begin_src shell
# # Search for various types or README file in dir and display them in $PAGER.
# readme ()
# {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }
#+end_src

#+begin_src shell
safetmp ()
{
    test -d $HOME || exit 1
    test -d $HOME/tmp || mkdir $HOME/tmp
    echo $HOME/tmp/safetmp.$(hostname).$(date +%s).$$
}
#+end_src

#+begin_src shell
timesync ()
{
    if [[ $EUID -eq 0 ]]; then
        ntpdate -u swisstime.ethz.ch
    else
        echo "Must be root"
    fi
}
#+end_src

#+begin_src shell
# Immediately opens the first match.
texman ()
{
    locate $* | grep pdf | grep texlive | head -1 | xargs open;
}

texlist ()
{
    locate $* | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)";
}
#+end_src

*** MCit tools

#+begin_src shell
alias sp=sendpatch
#+end_src

** Postamble

#+begin_src shell
# This is for the sake of Emacs.
# Local Variables:
# End:

# commonprofile ends here
#+end_src

