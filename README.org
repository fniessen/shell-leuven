#+TITLE:     Shell-Leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   num:nil ^:{}

#+PROPERTY:  header-args :eval no
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

XXX (See Fish web_config for sorting things out)

Look at https://github.com/jlevy/the-art-of-command-line!

XXX https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html
XXX https://www.linuxtrainingacademy.com/23-handy-bash-shell-aliases-for-unix-linux-and-mac-os-x/
XXX https://pissedoffadmins.com/

XXX nine colors: black, red, green, yellow, blue, magenta, cyan, white, and
reset (the terminal's default foreground)
See
https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux/20983251#20983251
for extended explanation about ~tput~ and color codes.
*tput looks up the appropriate codes according to the value of TERM and renders
the correctly escaped ANSI code for you.*

Autojump

Cygwin Ports provides *notify-send* in the *libnotify* package. You will also need
a running daemon (any of notification-daemon, mate-notification-daemon,
xfce4-notifyd, notify-osd, qtnotifydaemon).

- Context sensitive completion;
  + Executables (and aliases).
  + Directory commands.
  + Environment variables
  + Thirdparty tools; Git, Mercurial, SVN, Go, and P4.
- New keyboard shortcuts;
  + Paste from clipboard (Ctrl-V).
  + Incremental history search (Ctrl-R/Ctrl-S).
  + Powerful completion (TAB).
  + Undo (Ctrl-Z).
  + Environment variable expansion (Ctrl-Alt-E).

Undo/Redo (Ctrl-_ or Ctrl-X, Ctrl-U)
Improved command line history.
Persists across sessions.
Searchable (Ctrl-R and Ctrl-S).
History expansion (e.g. !!, !<string>, and !$).

Here is also list with all Clink command shortcuts
C-@     : set-mark
C-b     : backward-char
C-c     : ctrl-c
C-d     : delete-char
C-f     : forward-char
C-g     : abort
C-h     : backward-delete-char
C-i     : clink-completion-shim
C-j     : accept-line
C-k     : kill-line
C-l     : clear-screen
C-m     : accept-line
C-n     : next-history
C-p     : previous-history
C-q     : reload-lua-state
C-r     : reverse-search-history
C-s     : forward-search-history
C-t     : transpose-chars
C-u     : unix-line-discard
C-v     : paste-from-clipboard
C-w     : unix-word-rubout
C-y     : yank
C-z     : undo
C-]     : character-search
C-_     : undo
A-C-c   : copy-line-to-clipboard
A-C-e   : expand-env-vars
A-C-g   : abort
A-C-h   : backward-kill-word
A-C-i   : tab-insert
A-C-r   : revert-line
A-C-y   : yank-nth-arg
A-C-[   : complete
A-C-]   : character-search-backward
A-      : set-mark
A-#     : insert-comment
A-&     : tilde-expand
A-*     : insert-completions
A-.     : yank-last-arg
A-<     : beginning-of-history
A-=     : possible-completions
A->     : end-of-history
A-?     : possible-completions
A-     : delete-horizontal-space
A-_     : yank-last-arg
A-c     : capitalize-word
A-h     : show-rl-help
A-l     : downcase-word
A-n     : non-incremental-forward-search-history
A-p     : non-incremental-reverse-search-history
A-r     : revert-line
A-t     : transpose-words
A-u     : upcase-word
A-y     : yank-pop
A-~     : tilde-expand
C-x,C-g : abort
C-x,C-r : re-read-init-file
C-x,C-u : undo
C-x,C-x : exchange-point-and-mark
C-x,(   : start-kbd-macro
C-x,)   : end-kbd-macro
C-x,e   : call-last-kbd-macro

* How Shell-Leuven is different from the default configuration

Shell-Leuven is a set of configuration files to customize your Bash and Zsh
experience on Windows (with Cygwin or Git BASH), Linux and Mac OS.

The features that differentiate Shell-Leuven from the default configuration
include:

- *Autosuggestions --* Shell-Leuven suggests commands (in muted gray) as you type,
  based on your command history and command completions.

- *Man Page Completions --* Shell-Leuven generates command completion options
  automatically by parsing installed man pages.

- *Syntax highlighting --* Shell-Leuven uses different colors for parts of
  commands to help users focus on different things (e.g., commands versus
  arguments).

* Installation

** Try Online

Run the following command in your shell to try (part of) Shell-Leuven without
installing anything:

#+begin_src shell
# Source .zshrc.
. <(curl -Ss https://raw.githubusercontent.com/fniessen/shell-leuven/master/.zshrc)
#+end_src

(=.shellrc= won't be loaded.)

** Manual Installation

Download and source XXX.bash or XXX.zsh in your shell config.

* COMMENT Tasks

** TODO Look at shell scripts

https://bitbucket.org/ambrevar/dotfiles/src/ac47e01e1b25942d5a3f83616a91f9eab6382823/.scripts/?at=master

(pdfscan, etc.)

** TODO Bash aliases

http://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html

** TODO Follow coding conventions

http://wiki.bash-hackers.org/scripting/style

** TODO Remove Bashisms

- https://wiki.ubuntu.com/DashAsBinSh
- http://mywiki.wooledge.org/Bashism

*** TODO Use printf instead of echo -e

See http://www.bashguru.com/2010/01/shell-colors-colorizing-shell-scripts.html.

** TODO Unset TZ (from Eli Zaretskii)
[2015-03-30 Mon 16:51]

#+begin_verse
> Though, this morning, in the above configuration (Cygwin GDB + pretest
> of Emacs 24.5), I had a problem with the Org timestamps: they were one
> hour late, like if the computer clock hadn't been updated with the
> "summer" times here in Europe (since this Saturday).
>
> I finally found that the problem does not come from Emacs itself, but
> from the fact it's launched from Cygwin GDB!

Probably because GDB sets TZ to something a native Windows program
cannot grok.  Or something like that.

> Any idea how this problem can be circumvented?

You could unset TZ inside GDB before running Emacs (assuming my guess
is correct; what does "M-x getenv RET TZ RET" show inside Emacs?).

But the best way is to use a native port of GDB, of course.  Let me
know if you need a pointer to a binary distribution ready to be
installed.
#+end_verse

From [[gnus:INBOX#83zj6uy1vr.fsf@gnu.org][Email from Eli Zaretskii: Re: bug#20179: 24.4; Crash whe]]

** TODO Integrate goodies

See [[file:~/bin/bash-goodies]].

** TODO Look at color Bash prompt

https://wiki.archlinux.org/index.php/Color_Bash_Prompt
Very interesting settings!

* Startup files

# See http://zsh.sourceforge.net/Guide/zshguide02.html

There are 3 *types of shells*:

- (interactive) *login*

  (for which =c:/cygwin/etc/profile= and =.profile= are read, which sources =.bashrc=
  as well)

  #+begin_note
  Launching Cygwin Terminal (login shell) does not load =.bashrc= on its own, it
  only loads =.bash_profile=. Hence, the need to have a =.bash_profile= sourcing
  =.bashrc=...
  #+end_note

- *interactive* (non-login)

  (for which =.bashrc= is read)

- normal shell

  i.e. one that's running a *script* (Bash does not execute any initialization
  file in this case!)

  ~$tty~ is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For Bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.

#+begin_src shell :tangle .bash_profile
# User dependent .bash_profile file

# Source the user's .bashrc if it exists.
if [[ -f "$HOME"/.bashrc ]]; then
    . "$HOME"/.bashrc
fi
#+end_src

- For Zsh, put stuff in =~/.zprofile=, which is always executed.

To recover the default Bash configuration files, get their copy from
=/etc/skel=.

See http://blog.flowblok.id.au/2013-02/shell-startup-scripts.html for a Dotty
graph of the files...

#+begin_note
If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.
#+end_note

** What to put where?

Login shell runs =.profile= (or =.bash_profile= or =.bash_login=) on startup. Set your
env variables in there, because sub-shells will inherit the env vars. Then make
=.profile= run your =.bashrc=:

#+begin_src shell
. .bashrc
#+end_src

Interactive runs =.bashrc=. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare minimum. Therefore
your ~PATH~ won't work very well so you often have to give an absolute pathname
like in ~crontab~:

#+begin_src shell
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** What to put in your Zsh startup files

See http://zsh.sourceforge.net/Guide/zshguide02.html.

* Bash Configuration
:PROPERTIES:
:header-args+: :tangle .bashrc
:END:

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## bash_profile --- Bash configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

# Code:
#+end_src

Prevent "stdin is not a tty" errors when ~ssh~'ing to a remote machine (or using
~scp~, ~rcp~ or ~rsync~):

#+begin_src shell
# If not running interactively, don't do anything.
# isInteractive=$(echo $- | grep i)
[[ "$-" != *i* ]] && return
#+end_src

You don't want to perform a full-blown initialization every time scripts
execute.

It's important to refrain from outputting anything in those cases.

** Make zsh your default shell on Windows

To start directly Zsh when opening /Bash on Ubuntu on Windows/:

#+begin_src shell :noweb yes
# # If running in terminal...
# if test -t 1; then
#     # ... start Zsh
#     echo "Start Zsh..."
#     exec zsh
# fi
#+end_src

** Startup (Where are Local customizations?)

#+begin_src shell
# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_before ]; then
    . "$HOME"/.shellrc_local_before
fi

# Allow local Bash customizations.
if [ -f "$HOME"/.bashrc_local_before ]; then
    . "$HOME"/.bashrc_local_before
fi
#+end_src

** Colors

** Prompt

Note ~\[...\]~ used by the shell to count proper length.

#+begin_src shell :tangle no
if tput setaf 1 &> /dev/null; then
    tput sgr0
    if [[ $(tput colors) -ge 256 ]] 2> /dev/null; then
        MAG=$(tput setaf 9)
        ORANGE=$(tput setaf 172)
        GREEN=$(tput setaf 190)
        PURPLE=$(tput setaf 141)
        WHITE=$(tput setaf 256)
    else
        MAG=$(tput setaf 5)
        ORANGE=$(tput setaf 4)
        GREEN=$(tput setaf 2)
        PURPLE=$(tput setaf 1)
        WHITE=$(tput setaf 7)
    fi
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
#+end_src

See [[http://ezprompt.net/][Easy Bash PS1 Generator]]

- Insert an empty line before the prompt
- Change Bash prompt color based on exit code of last command

#+begin_src shell :tangle no
# Define empty function (if not yet defined).
type -t __git_ps1 || __git_ps1() { :; }
#+end_src

#+begin_src shell
# Colors.
BLK="\[$(tput setaf 0; tput bold)\]"
RED="\[$(tput setaf 1; tput bold)\]"
grn="\[$(tput setaf 2)\]"
GRN="\[$(tput setaf 2; tput bold)\]"
yel="\[$(tput setaf 3)\]"
reset_color="\[$(tput sgr0)\]"

# PS1 --- Default interaction prompt

case "$TERM" in
    "dumb")
        # No fancy multi-line prompt for TRAMP (see `tramp-terminal-type').
        # Don't confuse it!
        PS1="\n> "
        ;;
    cygwin|xterm*|rxvt-unicode)
        # `M-x shell' under Cygwin Emacs.
        # `M-x term' under Cygwin Emacs.
        BEL=$(tput bel)
        PS1='\[\033]0;Bash $PWD\007\]\n\
$(st=$?; if [[ $st -eq 0 ]]; then printf "\[\033[01;32m\]"; else printf "\[\033[01;31m\]$BEL\\u2718 $st "; fi)\
\[\033[0;32m\]\u@\h\
\[\033[01;30m\]:\
\[\033[;;33m\]\w\
\[\033[36m\]`__git_ps1`\n\
\[\033[35m\]$\[\033[0m\] '

# PS1='\[\033]0;$TITLEPREFIX:$PWD\007\]\n\[\033[32m\]\u@\h \[\033[35m\]$MSYSTEM \[\033[33m\]\w\[\033[36m\]`__git_ps1`\[\033[0m\]\n$ '


        ;;
    ,*) # emacs
        # `M-x shell' under EmacsW32.
        PS1="\n$?\u@\h:\w \$ "
        ;;
esac
# PS1+='$(if test $? -ne 0; then tput bel; fi)'
#+end_src

#+begin_src shell
export PS2="incomplete? continue here-> "
#+end_src

#+begin_src shell
# PS4 --- Used by "set -x" to prefix tracing output

# Get line numbers when you run with `-x'.
PS4='+'$grn'[$0:$LINENO]+ '${reset_color}
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

#+begin_tip
Single quotes around ~LINENO~ in ~PS4~; otherwise, *this* line number is taken...
#+end_tip

#+begin_tip
If you are looking at performance issues, put ~$SECONDS~ in the PS4 prompt as
well.
#+end_tip

** Getting Help

In the Zsh shell, ~M-h~ shows the *manual page* for the current command, if one
exists.  The Zsh way of doing things is much, much nicer than typing the ~man~
command...

Add this functionality to the Bash shell:

#+begin_src shell
# M-h = run-help.
bind '"\eh": "\C-a\eb\ed\C-y\e#man \C-y\C-m\C-p\C-p\C-a\C-d\C-e"'
#+end_src

** Syntax Highlighting

** Autosuggestions

** Tab Completions

#+begin_src shell
# Ignore case while completing filenames.
bind "set completion-ignore-case on"

# Treat hypens and underscores as the same if completion-ignore-case is on.
bind "set completion-map-case on"
#+end_src

Program specific completions:
- The programs ~man~ and ~whatis~ show all installed manual pages as completions.
- The ~make~ program uses all targets in the =Makefile= in the current directory as
  completions.
- The ~mount~ command uses all mount points specified in =fstab= as completions.
- The ~ssh~ command uses all hosts that are stored in the =known_hosts= file as
  completions. (See the ssh documentation for more information)
- The ~su~ command uses all users on the system as completions.
- The ~apt-get~, ~rpm~ and ~yum~ commands use all installed packages as completions.

#+begin_src shell
complete -A helptopic help
complete -A hostname ssh telnet nmap ftp ping host traceroute nslookup
#+end_src

** Changing Working Directory

#+begin_src shell
# When entering a directory, push it to the directory stack and list its
# contents.
cd() {
    builtin pushd "$@" > /dev/null      # = setopt auto_pushd, in Zsh.
    dirs_remove_dups                    # = setopt pushd_ignore_dups, in Zsh.
    ls --color=auto -F
}

# Remove dups.
dirs_remove_dups() {
    declare -a new=() copy=("${DIRSTACK[@]:1}")
    declare -A seen
    local v i
    seen[$PWD]=1
    for v in "${copy[@]}"; do
        if [ -z "${seen[$v]}" ]; then
            new+=("$v")
            seen[$v]=1
        fi
    done
    dirs -c
    for ((i=${#new[@]}-1; i>=0; i--)); do
        builtin pushd -n "${new[i]}" > /dev/null
    done
}
#+end_src

** Functions

** Variables

*** PATH variables

*** Special variables

#+begin_src shell
# Allow Meta (Alt) key bindings [line added to the top of my `.inputrc'].
bind "set convert-meta on"

# Don't strip characters to 7 bits when reading (permit UTF-8).
bind "set input-meta on"

# Denote symlinks to directories with an appended slash.
bind "set mark-symlinked-directories on"

# Do not autocomplete hidden files unless the pattern begins with a dot.
bind "set match-hidden-files off"

# Display characters with the 8th bit set directly rather than as meta-prefixed
# characters (permit UTF-8).
bind "set output-meta on"

# # Show all autocomplete results at once instead of via the internal pager.
# bind "set page-completions off"

# List all matches in case multiple possible completions are possible.
bind "set show-all-if-ambiguous on"

# bind "set menu-complete-display-prefix on"


set show-all-if-unmodified on
# Color the common prefix
set colored-completion-prefix on
# Color the common prefix in menu-complete
set menu-complete-display-prefix on
# Note that this may cause completion text blink in some terminals (e.g. xterm).
set colored-stats on


# Factor any text after the cursor position into completion matching.
bind "set skip-completed-text on"

# Show extra file information when completing similar to `ls -F`.
bind "set visible-stats off"
#+end_src

#+begin_src shell
# Automatically cd into a  directory without the `cd' in front of it.
shopt -s autocd

# Correct dir spellings.
shopt -s cdspell

# Make sure display get updated when terminal window get resized.
shopt -q -s checkwinsize
#+end_src

*** Locale variables

** History

Access and modify commands that you had previously typed at the command line.

#+begin_src shell
# When running two Bash windows, allow both to write to the history.
shopt -s histappend

# Make multi-line commands 1 line in history.
shopt -q -s cmdhist
#+end_src

#+begin_src shell
# Store 10,000 commands in history.
export HISTSIZE=10000
export HISTFILESIZE=$HISTSIZE

# Print full time-date stamps in ISO8601 `yyyy-mm-dd hh:mm' format.
export HISTTIMEFORMAT="%y-%m-%d %H:%M  "

# Blacklist - Avoid recording common commands (like ls, top and clear).
export HISTIGNORE="ls*:top:clear"
#+end_src

Prefix a command with a space to hide it from history (suitable for sensitive
information like passwords):

#+begin_src shell
# Ignore duplicate commands and commands starting with spaces.
HISTCONTROL=ignoreboth:erasedups
#+end_src

~ignoredups~, implied by ~ignoreboth~, doesn't add a command to history if it's the
same as *the immediate previous command*. It doesn't look further back in
history.

A value of ~erasedups~ causes *all previous lines* matching the current line
to be removed from the history list before that line is saved.

#+begin_tip
There is no reason to ~export~ the ~HISTCONTROL~ and ~PROMPT_COMMAND~ variables: you
are defining them in =.bashrc= so they will be defined in every shell (even in
non-interactive ones, which is also wasteful).
#+end_tip

See also [[https://unix.stackexchange.com/questions/1288/preserve-bash-history-in-multiple-terminal-windows][Preserve bash history in multiple terminal windows]] to keep Bash history
in sync between multiple terminals.

Le ~!~ en shell permet plein de trucs sympa.

- ~!!~ refait la dernière commande
- ~!cmd~ refait la dernière commande commençant par ~cmd~
- ~!cmd:p~ permet de visualiser sans éxecuter la dernière commande commençant
  par ~cmd~
- ~!$~ est le dernier mot de la ligne de commande précédente
- ~!cmd:$~ est le dernier mot du dernier ligne de commande commençant par ~cmd~
- ~!*~ est l'ensemble de la dernière ligne de commande à part le premier mot

See also http://dvorka.github.io/hstr/ to easily view, navigate and search your
command history with shell history suggest box.

#+begin_src shell
alias h="history"
#+end_src

** Key Bindings (Command line editor)

The =.inputrc= file controls the behavior of the *command line editor* for programs
that use the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

See https://code.google.com/p/mintty/wiki/Tips#Readline_configuration.

By default, Bash uses /Emacs/ style keyboard shortcuts when editing (~C-a~, ~C-e~,
etc.).  Check your active Bash keymap with:

#+begin_src shell :tangle no
bind -v | grep editing-mode
bind -v | grep keymap
#+end_src

List with ~bind -P~.

The key bindings can also be part of =.bashrc= (by adding single quotes).


- Tab completes the current token. Shift, Tab completes the current token and starts the pager's search mode.
- Alt+?,Left and Alt+?,Right move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+?,Right (or Alt+F) accepts the first word in the suggestion.
- Shift,?,Left and Shift,?,Right move the cursor one word left or right, without stopping on punctuation.
- ? (Up) and ? (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the history section for more information on history searching.
- Alt+?,Up and Alt+?,Down search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the history section for more information on history searching.
- Control+C cancels the entire line.
- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.
- Control+U moves contents from the beginning of line to the cursor to the killring.
- Control+L clears and repaints the screen.
- Control+W moves the previous path component (everything up to the previous "/", ":" or "@") to the killring.
- Control+X copies the current buffer to the system's clipboard, Control+V inserts the clipboard contents.
- Alt+d moves the next word to the killring.
- Alt+h (or F1) shows the manual page for the current command, if one exists.
- Alt+l lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.
- Alt+w prints a short description of the command under the cursor.

- Alt+s Prepends sudo to the current commandline.

  # Insert 'sudo ' at the beginning of the line.
  bindkey -M "$keymap" "$key_info[Control]X$key_info[Control]S" prepend-sudo

Emacs mode commands
- Home or Control+A moves the cursor to the beginning of the line.
- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.
- ? (Left) (or Control+B) and ? (Right) (or Control+F) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, the ? (Right) key and the Control+F combination accept the suggestion.
- Delete and Backspace removes one character forwards or backwards respectively.
- Control+K moves contents from the cursor to the end of line to the killring.
- Alt+c capitalizes the current word.
- Alt+u makes the current word uppercase.
- Control+t transposes the last two characters
- Alt+t transposes the last two words
- You can change these key bindings using the bind builtin.


*** Commands For Moving

#+begin_src shell
# Set <C-left/right> to move by whole words.
bind '"\e[1;5C": forward-word'
bind '"\e[1;5D": backward-word'
#+end_src

*** Commands For Manipulating The History

#+begin_src shell
# Very nice history search.  Type text (as prefix) and hit up <up/down> to
# search witin command history (no C-r required).
bind '"\e[B": history-search-forward'
bind '"\e[A": history-search-backward'
#+end_src

*** Commands For Changing Text

#+begin_src shell
# Set Delete/Insert keys to delete/insert chars on line
bind '"\e[3~": delete-char'
bind '"\e[2~": quoted-insert'
#+end_src

*** Killing And Yanking

*** Specifying Numeric Arguments

*** Letting Readline Type For You

#+begin_src shell
# Make TAB cycle through commands after listing.
bind '"\t": menu-complete'
#+end_src

*** Keyboard Macros

*** Some Miscellaneous Commands

https://www.gnu.org/software/bash/manual/html_node/Bindable-Readline-Commands.html#Bindable-Readline-Commands

This makes ~M-p~ (see Fish) append " | less" to the line and run it:

#+begin_src shell
bind '"\ep": "\C-e | less\C-m"'
#+end_src

This example wraps the line in su -c '', if Alt+S is pressed:

"\es": "\C-a su -c '\C-e'\C-m"

This example prefixes the line with sudo , if Alt+S is pressed. It's safer
because it won't input the Enter key.

"\es": "\C-asudo \C-e"

Others:
- https://brettterpstra.com/2015/07/09/shell-tricks-inputrc-binding-fun/

Control-o: "> output" C-o is bound to run the macro expressed on the right hand
side (that is, to insert the text "> output" into the line)

"\C-d": kill-whole-line Map control-d to kill the whole line.





FZF Key bindings for command line
- CTRL-T - Paste the selected files and directories onto the command line
  Set FZF_CTRL_T_COMMAND to override the default command
  Set FZF_CTRL_T_OPTS to pass additional options
- CTRL-R - Paste the selected command from history onto the command line
  If you want to see the commands in chronological order, press CTRL-R again which toggles sorting by relevance
  Set FZF_CTRL_R_OPTS to pass additional options
- ALT-C - cd into the selected directory
  Set FZF_ALT_C_COMMAND to override the default command
  Set FZF_ALT_C_OPTS to pass additional options

#+begin_src shell
bind '"\ee": edit-and-execute-command'
bind '"\ev": edit-and-execute-command'
# Same as C-x C-e.
#+end_src

#+begin_src shell
# C-M-u: up-directory
bind '"\e\C-u": "cd ..\n"'
#+end_src

** Ready for more?

#+begin_src shell
# Common configuration.
if [ -f "$HOME"/.shellrc ]; then
    . "$HOME"/.shellrc
fi

# Allow local Bash customizations.
if [ -f "$HOME"/.bashrc_local_after ]; then
    . "$HOME"/.bashrc_local_after
fi

# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_after ]; then
    . "$HOME"/.shellrc_local_after
fi
#+end_src

* Zsh Configuration
:PROPERTIES:
:header-args+: :tangle .zshrc
:END:

Documentation: [[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]].

Examples:
- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)
- [[http://grml.org/zsh/zsh-lovers.html][zsh-lovers]]

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .zshrc --- Zsh configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

# Code:
#+end_src

** Startup (Where are Local customizations?)

#+begin_src shell
# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_before ]; then
    . "$HOME"/.shellrc_local_before
fi

# Allow local Zsh customizations.
if [ -f "$HOME"/.zshrc_local_before ]; then
    . "$HOME"/.zshrc_local_before
fi
#+end_src

** Colors

*** Stderr in red

Wrap text that goes to file with descriptor ~2~ with proper ANSI escape codes,
making text red.

#+begin_src shell
# Coloring stderr.
STDERRED_ESC_CODE=$'\e[33;1;41m'
zmodload zsh/system
color_stderr_red() {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    while sysread; do
        syswrite -o 2 "$STDERRED_ESC_CODE$REPLY$terminfo[sgr0]"
    done
}

exec 2> >( color_stderr_red )
#+end_src

** Prompt

#+begin_src shell
# # Don't inherit the value of PS1 from the previous shell (Zsh from Bash).
# PS1=$'%{\e]0;%d\a%}\n%F{grn}%n@%m %F{yel}%d%f\n%# '
#+end_src

Zsh expects that every character in ~PS1~ will advance the cursor one space.  Wrap
any non-printing escape sequences in ~%{...%}~, and it should work. So use
~%{\e[31m%}~, etc.

*************** TODO Define colors using ~terminfo~
See http://superuser.com/questions/239290/how-can-i-make-zsh-show-that-there-are-stashed-revisions-on-a-git-repo-whenever
*************** END

For the prompt, the tricky part was getting the syntax for testing the exit
code.  The syntax is ~%(x.true-string.false-string)~, where ~x~ is some arbitrary
testing condition, in this case, ~?~ for exit codes.  After the first dot, if the
test passes, show ~true-string~; if it fails, show ~false-string~ after the second
dot.

#+begin_src shell
autoload -Uz vcs_info
precmd_vcs_info() {
    vcs_info
}
precmd_functions+=( precmd_vcs_info )
setopt PROMPT_SUBST                     # Allow parameter expansion in prompt.
zstyle ':vcs_info:git:*' formats '%F{cyan}(%b)%f'
zstyle ':vcs_info:*' enable git
#+end_src

#+begin_src shell
PROMPT="
%B%(?.%F{green}.%F{red}$(tput bel)"$'\u2718'" %? )%f%b%F{green}%n@%m%F{black}%B:%b%F{yellow}%~ %f\$vcs_info_msg_0_
%B%F{blue}%(!.#.$)%f%b "
                                        # ? - Exit code of the previous command.
                                        # n - User name.
                                        # m - Machine name.
                                        # . - Abbreviated pwd.
                                        # ! - su?
#+end_src

One of the hardest things is to set the xterm title "correctly", because most
people do it wrong in some way, and then it will break when you have literal
tabs or percent signs or tildes in your command line. Here is what I currently
use:

#+begin_src shell
case "$TERM" in
    xterm*|rxvt*)
        precmd()  { print -Pn "\e]0;%m: %~\a" }
        preexec() { print -n "\e]0;Zsh $HOST: ${(q)1//(#m)[$'\000-\037\177-']/${(q)MATCH}}\a" }
esac
#+end_src

Insert beep when last command has failed.

#+begin_tip
For portability and readability, we use the ~tput~ command.

But since it's an external command, we run it once to get the bel sequence, and
then stick that sequence in the relevant part of our prompt -- for performance,
to avoid an unnecessary shellout at each prompt evaluation.
#+end_tip

#+begin_src shell
BEL=$(tput bel)
PROMPT+='%(?::$BEL)'
#+end_src

To get a *blank line before the prompt*, you can simply write a function to echo
a blank line and add it to your ~preexec~ or ~precmd~ hooks.

Technically, it doesn't insert a line after each commands output, but inserts
a blank line before building the prompt.  However, the end result is the
same.

#+begin_src shell :tangle no
echo_blank() {
    echo
}

# preexec_functions+=echo_blank
precmd_functions+=echo_blank
#+end_src

Don't confuse TRAMP:

#+begin_src shell
[[ "$TERM" = "dumb" ]] && PROMPT="> "
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

*** Right prompt

Don't confuse TRAMP:

#+begin_src shell
[[ "$TERM" = "dumb" ]] && RPROMPT=""
#+end_src

*** Add a new theme: Solarized

- [[https://github.com/altercation/solarized/issues/90][How should bold/bright be handled by terminal emulators?]]
- [[https://github.com/mintty/mintty/issues/683][Solarized bold colors are gray]]

Karlin Fox ported the Solarized theme to MinTTY (the terminal which comes by
default with Cygwin), and it is available at [[https://github.com/karlin/mintty-colors-solarized][karlin/mintty-colors-solarized]].

#+begin_src shell :tangle no
git clone https://github.com/karlin/mintty-colors-solarized.git \
    "$HOME"/.dotfiles/plugins/mintty-colors-solarized
#+end_src

#+begin_src shell
FILE="$HOME"/.dotfiles/plugins/mintty-colors-solarized/mintty-solarized-dark.sh && test -f "$FILE" && . "$FILE"

# XXX Check for MinTTY
if [[ -d /cygdrive/c/ ]]; then
    echo -ne '\e]4;8;#404040\a'     # bold blk
    echo -ne '\e]4;9;#FF4040\a'     # bold red
    echo -ne '\e]4;10;#40FF40\a'    # bold grn
    echo -ne '\e]4;11;#FFFF40\a'    # bold yel
    echo -ne '\e]4;12;#6060FF\a'    # bold blu
    echo -ne '\e]4;13;#FF40FF\a'    # bold mag
    echo -ne '\e]4;14;#40FFFF\a'    # bold cyn
    echo -ne '\e]4;15;#FFFFFF\a'    # bold wht
fi
#+end_src

https://github.com/oumu/mintty-color-schemes
https://github.com/mintty/mintty/wiki/Tips
http://mintty.github.io/mintty.1.html#CONFIGURATION
https://stackoverflow.com/questions/24229406/how-to-get-vim-on-cygwin-to-display-right-colors

See great (more portable) stuff at
https://github.com/jimeh/git-aware-prompt/blob/master/colors.sh!

*** Install Powerline-patched fonts

*Powerline patched* versions of the most popular mono *fonts* are available at
[[https://github.com/powerline/fonts][powerline/fonts]].

Make sure to change the font of MinTTY:

- Right click the title bar of the Terminal, click Options.
- Change your font to a Powerline patched font you installed.

#+begin_note
If you right-click them, there should be install option in the menu. Or you can
drag it straight to Windows Fonts folder
#+end_note

Test if it's working correctly by running:

#+begin_src shell :tangle no
echo "\ue0b0 \u00b1 \ue0a0 \u27a6 \u2718 \u26a1 \u2699"
#+end_src

Good-looking fonts:
- UbuntuMono
- DejaVuSansMono
- DroidSansMono (bad?)

For Consolas, use: https://github.com/runsisi/consolas-font-for-powerline.

*** Install "Oh My Zsh"

Oh My Zsh is just awesome!

#+begin_src shell :tangle no
git clone https://github.com/robbyrussell/oh-my-zsh.git
#+end_src

#+begin_note
We put Oh My Zsh at the very beginning, so that it does not override our own
settings.
#+end_note

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    ZSH="$HOME"/.dotfiles/plugins/oh-my-zsh
    # ${ZSH_CUSTOM:-"$HOME"/.dotfiles/plugins/oh-my-zsh/custom}
    ZSH_CUSTOM="$ZSH/custom"

    HIST_STAMPS="yyyy-mm-dd"            # See command `history'.

    COMPLETION_WAITING_DOTS="true"
fi
#+end_src

http://marc-abramowitz.com/archives/2012/04/10/fix-for-oh-my-zsh-git-svn-prompt-slowness/

*** Change the Oh My Zsh theme to "agnoster"

# I am fan of ~agnoster~.
#
# #+begin_src shell
# if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
#     ZSH_THEME="agnoster"
# fi
# #+end_src

**** Agnoster Theme Adaption for SVN

#+begin_src shell
# if [[ -r "$ZSH" ]]; then
#     prompt_svn() {
#         local rev branch
#         if in_svn; then
#             rev=$(svn_get_rev_nr)
#             branch=$(svn_get_branch_name)
#             if [[ $(svn_dirty_choose_pwd 1 0) -eq 1 ]]; then
#                 prompt_segment yel blk
#                 echo -n "$rev@$branch"
#                 echo -n " ±"
#             else
#                 prompt_segment grn blk
#                 echo -n "$rev@$branch"
#             fi
#         fi
#     }
# fi
#+end_src

*** Install Zinc (successor of Powerlevel9k!)

#+begin_src shell :tangle no
git clone https://gitlab.com/robobenklein/zinc \
    "$ZSH_CUSTOM"/themes/zinc
#+end_src

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh//custom/themes/zinc/zinc.zsh ]]; then

    ZSH_THEME=""
    source "$ZSH_CUSTOM"/themes/zinc/zinc.zsh

    zinc_default_user="f.niessen"
    zinc_default_host="XIPHIAS"

    # Input your own strftime format: http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
    zincs_time() {
        REPLY="%D{%H:%M}"
    }

    prompt_zinc_setup fniessen-p9k-port

    prompt_zinc_setup rprompt-previous-line

fi

# # either user and host separate with CONNECT_PREV
# # or zincs_userhost
# zinc_left=(
#   # zincs_user
#   # zincs_host
#   zincs_userhost
#   zincs_cwd
#   zincs_vcs
# )
#
# zinc_right=(
#   zincs_retval
#   zincs_execution_time
#   my_custom_time
#   zincs_jobs
# )
#
# zinc_opts=(
#   zincs_user "white;black;CONDITIONAL;normal"
#   zincs_host "white;black;CONNECT_PREV+CONDITIONAL;normal"
#   zincs_userhost "white;black;CONDITIONAL;normal"
# )
#
# # autohide the user when it's default
# zincs_user_display_hidden() {
#   [[ "$USER" == "$zinc_default_user" ]] && true || false
# }
# zincs_host_display_hidden() {
#   [[ "$HOST" == "$zinc_default_host" ]] && true || false
# }
#
# # or show both when either changes:
# zincs_userhost_display_hidden() {
#   [[ "$HOST" == "$zinc_default_host" ]] && [[ "$USER" == "$zinc_default_user" ]] && true
# }
#
# # set the time format option:
# # http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
# my_custom_time() {
#   REPLY="%T"
# }
#
# # set the zincs_execution_time min time:
# zincs_execution_time[threshold]=10
#+end_src

*** Plugins

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then

    plugins=(
        colored-man-pages
        extract
        # git                           # Provide many aliases and a few useful functions.
        history
        history-substring-search
        # svn
    )
fi
#+end_src

**** Colored man pages plugin

#+begin_seealso
[[file:~/.minttyrc][.minttyrc]] to *fix colors* and fonts.  See [[http://mintty.googlecode.com/svn-history/r1065/trunk/docs/mintty.1.html][mintty Manual Reference Pages]] for more
information.
#+end_seealso

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    # Fix Colorize man pages (with `less` pager) not working in Cygwin MinTTY
    export MANROFFOPT="-c"
    # in your shell rc file. This has the same effect as
    # export GROFF_NO_SGR=1               # For konsole and gnome-terminal.
    # but only affects man. I'm not sure if groff is used for anything else
    # besides man pages, but this seems safer to prevent unintended side
    # effects.
fi
#+end_src

** Syntax Highlighting

Besides the syntax highlighting for your shell, this plugin has the capability
to verify the correctness of your command.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \
    "$ZSH_CUSTOM"/plugins/zsh-syntax-highlighting
#+end_src

#+begin_src shell
if [[ -r "$ZSH_CUSTOM/plugins/zsh-syntax-highlighting" ]]; then
    plugins+=(zsh-syntax-highlighting)
fi
#+end_src

** Autosuggestions

Zsh suggests commands based on your command history.

To accept the autosuggestion, hit ~→~ (right arrow) or ~Ctrl-F~.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-autosuggestions \
    "$ZSH_CUSTOM"/plugins/zsh-autosuggestions
#+end_src

#+begin_src shell
if [[ -r "$ZSH_CUSTOM/plugins/zsh-autosuggestions" ]]; then
    plugins+=(zsh-autosuggestions)
fi
#+end_src

*** Load Zsh tools

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    . "$ZSH"/oh-my-zsh.sh
fi
#+end_src

#+begin_src shell
# Autosuggestions.
if [[ -r "$ZSH_CUSTOM/plugins/zsh-autosuggestions" ]]; then
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=5'
fi
#+end_src

** Tab Completions

** Changing Working Directory

#+begin_src shell
# When entering a directory, push it to the directory stack and list its
# contents.
setopt auto_pushd
setopt pushd_ignore_dups

cd() {
    builtin cd "$@" > /dev/null
    ls --color=auto -F
}
#+end_src

** Functions

** Variables

*** PATH variables

*** Special variables

**** Changing Directories

#+begin_src shell
setopt AUTO_CD                  # Change directory given just path.
#+end_src

**** Completion

Zsh will attempt to complete wildcards by expanding them in the command line.

#+begin_src shell
# Load general completion.
autoload -Uz compinit

# Start the Zsh completion system.
compinit -i                     # Silently ignore all insecure files and directories.
#+end_src

How to fix "zsh compinit: insecure directories"?  Stripping these directories of
the group write permission:

#+begin_src shell :tangle no
compaudit | xargs chmod g-w
#+end_src

will do the trick, see [[http://www.wezm.net/technical/2008/09/zsh-cygwin-and-insecure-directories/][zsh, Cygwin and Insecure Directories]].

#+begin_src shell
setopt AUTO_LIST                # Automatically list choices on an ambiguous completion.

# setopt always_to_end            # when completing from the middle of a word, move the cursor to the end of the word
# setopt auto_menu                # show completion menu on successive tab press. needs unsetop menu_complete to work
# setopt auto_name_dirs           # any parameter that is set to the absolute name of a directory immediately becomes a name for that directory
# unsetopt auto_name_dirs         # do not set auto_name_dirs because it messes up prompts
# setopt complete_in_word         # allow completion from within a word/phrase
# setopt auto_list                # automatically list choices on ambiguous completion.
# unsetopt completealiases        # an alias of a command should complete to the command completion
# unsetopt menu_complete          # do not autoselect the first completion entry
# unsetopt flowcontrol            # do not freezes output to the terminal until you type ^q
#+end_src

**** 20. Completion System

#+begin_src shell
# Small and capital letters will match small and capital letters only if there
# are no case-sensitive matches.
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'
#+end_src

See also
https://superuser.com/questions/1092033/how-can-i-make-zsh-tab-completion-fix-capitalization-errors-for-directorys-and.

Launch Windows applications from CLI (with ~start~ script -- see
https://github.com/babun/babun/issues/299#issuecomment-123925935):

#+begin_src shell
# compdef '_files -g "*"' start
#+end_src

**** Expansion and Globbing

#+begin_src shell
setopt EXTENDED_GLOB            # Use additional pattern matching features.
setopt NOMATCH                  # Unmatched patterns cause an error.
#+end_src

**** Job Control

#+begin_src shell
setopt NOTIFY                   # Immediately report changes in background job status.
#+end_src

**** Zle

Zsh has its own line editor (ZLE) and doesn't read readline's =.inputrc=.

#+begin_src shell
# Beep when there's an error with the command text you're typing in (e.g. if you
# hit tab and there are no matching files) -- not as a result of normal commands
# returning errors.
setopt BEEP
#+end_src

Make Zsh ~forward-word~ behavior same as in *Bash* / Emacs, where only alphanumeric
characters are considered word characters:

#+begin_src shell
autoload -U select-word-style
select-word-style bash
#+end_src

*** Locale variables

** History

#+begin_src shell
HISTFILE=~/.zsh_history         # Zsh doesn't save the history to a file by default.
HISTSIZE=10000                  # In memory.
SAVEHIST=$HISTSIZE              # To file.
#+end_src

#+begin_src shell
setopt APPEND_HISTORY           # Append rather than overwrite history file.
setopt EXTENDED_HISTORY         # Save timestamp and runtime information.
setopt HIST_EXPIRE_DUPS_FIRST   # Allow dups, but expire old ones when I hit HISTSIZE.
setopt HIST_FIND_NO_DUPS        # Don't find duplicates in history.
setopt HIST_IGNORE_ALL_DUPS     #! Ignore duplicate commands regardless of commands in between.
setopt HIST_IGNORE_DUPS         # Ignore duplicate commands.
setopt HIST_REDUCE_BLANKS       # Leave blanks out.
setopt HIST_SAVE_NO_DUPS        # Don't save duplicates.

setopt INC_APPEND_HISTORY       # Write after each command.
setopt SHARE_HISTORY            # Share history between sessions.
#+end_src

#+begin_src shell
# Print full time-date stamps in ISO8601 `yyyy-mm-dd hh:mm' format.
alias history="history -i"
alias h="history -i"
#+end_src

** Key Bindings (Command line editor)

10.4 Some interesting keybindings

| Key binding | Meaning                                         |
|-------------+-------------------------------------------------|
| C-d         | complete + EOF                                  |
|-------------+-------------------------------------------------|
| C-k         | kill line                                       |
| C-u         | kill while line (kill-ring)                     |
| C-w         | copy last word (kill-ring) OR delete last word? |
| C-y         | yank (insert kill-ring)                         |
|-------------+-------------------------------------------------|
| <tab>       | complete and take first result                  |
|-------------+-------------------------------------------------|
| C-_         | undo                                            |
|-------------+-------------------------------------------------|
| M-?         | which-command                                   |
| M-'         | quote-line ('')                                 |
| esc-q       | push line                                       |

Useful keybindings of the Zsh *command line editor*:

- ~M-q~ ::
     Type another command in the middle of a long command (look at ~man~, etc.):
     you can push the current command to the buffer stack, and after executing
     another command, you can see the top of the stack popped.

- ~C-r~ ::
     Do an interactive search across all of the *command history*.

Useful commands:

- ~vared VAR~ ::
     Interactively edit variable ~VAR~.

#+begin_note
See [[file:~/.dotfiles/plugins/oh-my-zsh/lib/key-bindings.zsh]] for extra key bindings.
#+end_note

Run ~bindkey~ to get a listing of currently active keybindings.

For a more general approach you start your terminal, press ~C-v~ followed by the
key combination you want the escape code (the name) of, and put the output for
each key combination in between the two quotes.

#+begin_src shell
# # Behave like Emacs when editing. (Default if $VISUAL or $EDITOR does not contain string 'vi'?)
# bindkey -e
#+end_src

*** Commands For Moving

| Key binding | Meaning                                   |
|-------------+-------------------------------------------|
| C-a         | Move to the beginning of the current line |
| C-e         | Move to the end of the current line       |
| C-l         | Clear the screen                          |

#+begin_src shell
# Move by whole words.
bindkey '\e[1;5C' forward-word          # <C-right>
bindkey '\e[1;5D' backward-word         # <C-left>
#+end_src

*** Commands For Manipulating The History

#+begin_src shell
# Search matching commands from the history.
bindkey '\e[A' history-beginning-search-backward # <up>
bindkey '\e[B' history-beginning-search-forward  # <down>
#+end_src

#+begin_src shell
# Insert last word with Alt+. -- cool!  BY DEFAULT!???
# bindkey '\e.' insert-last-word
#+end_src

| Key binding | Meaning                                                                            |
|-------------+------------------------------------------------------------------------------------|
| ~M-.~         | Insert the last argument of the previous command (and so on); similar to typing ~!$~ |

Bonus Tip

In Bash, there are some great but lesser-known default bindings. You may know
that M-. will insert the last argument of the previous command (e.g. running ls
~/Desktop and then typing cd and pressing M-. will turn it into cd ~/Desktop),
but did you know you can actually yank the argument at any index from the last
command (without using history or ! operators)?

Just press M-[#], where # is the position of the argument you want, then type
M-. to insert it in the current command.

*** Commands For Changing Text

#+begin_src shell
bindkey "\e[3~" delete-char             # <delete>

# Make Zsh beep like Bash when backspacing on an empty command line.
backward-delete-char-beep() {
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep  # <backspace>
#+end_src

*** Killing And Yanking

*** Specifying Numeric Arguments

*** Letting Readline Type For You

*** Keyboard Macros

*** Some Miscellaneous Commands

| Key binding | Meaning                                                                                                                    |
|-------------+----------------------------------------------------------------------------------------------------------------------------|
| M-e         | Edit the current command line in an external editor ($VISUAL or $EDITOR); similar to the ~fc~ ("fix command") shell built-in |
| M-v         | Same as ~M-e~                                                                                                                |
| C-x C-e     | Same as ~M-e~; default in Bash                                                                                               |
| C-M-u       | Go up one directory (automatic "cd ..")                                                                                    |

From Dan Davison:
bindkey '^W' kill-region
bindkey '^x^r' replace-string

#+begin_src shell
autoload edit-command-line
zle -N edit-command-line
bindkey "\ee"      edit-command-line
bindkey "\ev"      edit-command-line
bindkey "\C-x\C-e" edit-command-line
#+end_src

#+begin_src shell :tangle no
# M-s: prepend-sudo
prepend_sudo() { zle beginning-of-line; zle -U "sudo " }
zle -N prepend-sudo prepend_sudo
bindkey '\es' prepend-sudo
#+end_src

M-p (see Fish) appends the string " | less" to the current command. The result
is that the output of the command will be paged.

#+begin_src shell
# M-p: append-less
append_less() { zle end-of-line; zle -U " | less" }
zle -N append-less append_less
bindkey '\ep' append-less
#+end_src

#+begin_src shell
# C-M-u: up-directory
bindkey -s '\e\C-u' "cd ..\n"
#+end_src

** Abbreviations (aliases)

Some global aliases (expand whatever their position).

#+begin_src shell
alias -g 21="2>&1"
alias -g A='| awk'
alias -g BG='& exit'
alias -g C='| cat'
alias -g CA="| cat -A"
alias -g F=' | fmt -' ##
alias -g G='| grep --color=auto -E' ######
alias -g H='| head' ###
alias -g J='| jq -C .'
alias -g L="| less" #######
alias -g L='| less'
alias -g N='> /dev/null'
alias -g NN='> /dev/null 2>&1'
alias -g S='| sort' ###
alias -g T='| tail' ###
alias -g W='| wc -l' ####
alias -g X1='| xargs -n 1'
alias -g X='| xargs'
alias -g XL='| tr "\n" "\0" | xargs -0'
#+end_src

#+begin_src shell
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g ,1="| awk -F, '{print \$1}'"
alias -g ,2="| awk -F, '{print \$2}'"
alias -g ,3="| awk -F, '{print \$3}'"
alias -g ,4="| awk -F, '{print \$4}'"
alias -g ,5="| awk -F, '{print \$5}'"
alias -g ,6="| awk -F, '{print \$6}'"
alias -g ,7="| awk -F, '{print \$7}'"
alias -g ,8="| awk -F, '{print \$8}'"
alias -g ,9="| awk -F, '{print \$9}'"
alias -g :1="| awk -F: '{print \$1}'"
alias -g :2="| awk -F: '{print \$2}'"
alias -g :3="| awk -F: '{print \$3}'"
alias -g :4="| awk -F: '{print \$4}'"
alias -g :5="| awk -F: '{print \$5}'"
alias -g :6="| awk -F: '{print \$6}'"
alias -g :7="| awk -F: '{print \$7}'"
alias -g :8="| awk -F: '{print \$8}'"
alias -g :9="| awk -F: '{print \$9}'"
alias -g T1="| awk -F $'\t' '{print \$1}'"
alias -g T2="| awk -F $'\t' '{print \$2}'"
alias -g T3="| awk -F $'\t' '{print \$3}'"
alias -g T4="| awk -F $'\t' '{print \$4}'"
alias -g T5="| awk -F $'\t' '{print \$5}'"
alias -g T6="| awk -F $'\t' '{print \$6}'"
alias -g T7="| awk -F $'\t' '{print \$7}'"
alias -g T8="| awk -F $'\t' '{print \$8}'"
alias -g T9="| awk -F $'\t' '{print \$9}'"
#+end_src

*** Git

Git this week / month / year:

#+begin_src shell
alias -g GTHISWEEK=' --since=1.week.ago'
alias -g GTHISMONTH=' --since=1.month.ago'
alias -g GTHISYEAR=' --since=1.year.ago'
#+end_src

** Ready for more?

#+begin_src shell
# Common configuration.
if [ -f "$HOME"/.shellrc ]; then
    . "$HOME"/.shellrc
fi

# Allow local Zsh customizations.
if [ -f "$HOME"/.zshrc_local_after ]; then
    . "$HOME"/.zshrc_local_after
fi

# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_after ]; then
    . "$HOME"/.shellrc_local_after
fi
#+end_src

* Shell agnostic Configuration
:PROPERTIES:
:header-args+: :tangle .shellrc
:END:

=.shellrc= contains miscellaneous settings *common to Bash and Zsh* -- it is read by
both shells.

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .shellrc --- Shell agnostic configuration file

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

#+begin_src shell
uname -s -n -r -m
#+end_src

** Functions

*** Exit with an error

The exit status follows the conventions for programs such as ~grep~, ~cmp~, and
~diff~: it is 2 (or greater) if an error occurred.

#+begin_src shell
die() {
    printf "$(basename $0): $@\n" > /dev/stderr
    exit 2                              # An error occurred.
}
#+end_src

~Die~ *must be a function* so that the calling script does exit with an error.

*** Check for executable files

~has~ checks presence of various command line tools on the PATH.

#+begin_src shell
has() {
    for cmd in "$@"; do
        command -v $cmd > /dev/null || die "$cmd not found."
    done
}
#+end_src

To find out if a given command exists, don't use ~which~ (because it is not in
POSIX so its output format is unspecified, and it complains when nothing is
found instead of being silent):

#+begin_src shell :tangle no
if $(which ag > /dev/null 2>&1); then alias grep='ag'; fi
#+end_src

Instead use:

#+begin_src shell
has() {
    if ! command -v "$1" > /dev/null 2>&1; then
        echo "$1 not found."
        return 2                        # An error occurred.
    fi
}
#+end_src

#+begin_src shell :tangle no
has ag && alias grep='ag'
#+end_src

See also
https://unix.stackexchange.com/questions/85249/why-not-use-which-what-to-use-then.

*** Go to directory of the file currently active in Emacs

If you are an avid Emacs user like me, you'll find this function useful.  It
*enters the directory of the file currently active in Emacs* resides in:

#+begin_src shell
cde() {
  builtin cd $(emacsclient -e '(with-current-buffer
                                   (window-buffer (selected-window))
                                 default-directory)' | tr -d '"')
}
#+end_src

You need the ~emacs-server~ functionality enabled for this to work.

** Variables

*** PATH variables

**** Search path

Specify the directories that the shell is to look through to find a command.
These directories are searched in the order in which they appear.

The global search ~PATH~ is defined in the file =/etc/environment=.

#+begin_src shell
# Add user paths.
for MAYBE_PATH in "$HOME"/bin \
                  "$HOME"/expect; do
    # `-e' or `-x'?
    if [[ -d "$MAYBE_PATH" ]]; then
        PATH="$MAYBE_PATH":"$PATH"
    fi
done

# Extend the PATH var (where to look for executable files).  For Cygwin only.
if [[ "$OSTYPE" = cygwin* ]]; then
    for MAYBE_CYG_PATH in "$HOME"/.dotfiles/winbin; do
        # `-e' or `-x'?
        if [[ -d "$MAYBE_CYG_PATH" ]]; then
            PATH="$MAYBE_CYG_PATH":"$PATH"
        fi
    done
fi
#+end_src

#+begin_note
~PATH~ should already be marked as exported, so reexporting is not needed.

Run ~export~ to see a list of exported variables (names marked to be passed to
child processes in the environment).

Since ~env~ is an independent executable (=/usr/bin/env=), it only sees the
variables that the shell passes to it, or */exported/ environment variables*
(which are passed on to every executed program).

~set~ on the other hand is a /built-in/ shell command, it also *sees local shell
variables* (which are only accessible from the current shell) -- including shell
functions.
#+end_note

By default, the ~root~ shell does not load commands from the current location.  If
you're ~root~ and if you trust those commands, type ~./whatever-command~ instead.

If you add the ~CWD~ (~.~) to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src shell
# Add the current directory as last component in the search path (not to include
# for `root', for security reasons).
if [[ $EUID -ne 0 ]]; then
    PATH="$PATH":.
fi
#+end_src

**** CDPATH

Much like the ~PATH~ environment variable defines a search order for the
executable you want, ~CDPATH~ provides a selection of directories which will be
checked for the folder you are trying to ~cd~ into.

#+begin_src shell
# Search current directory and home directory.
export CDPATH=.:"$HOME"
#+end_src

**** MANPATH

#+begin_src shell
# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
# if [[ -d "$HOME"/man ]]; then
#     export MANPATH="$HOME/man":"$MANPATH"
# fi

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'
#+end_src

**** INFOPATH

#+begin_src shell
# Info readers (standalone + Emacs Info mode)
INFOPATH=/usr/share/info:"$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
# INFOPATH="$HOME"/texlive/2014/texmf/doc/info:"$INFOPATH"
#+end_src

**** Tool paths

***** Java

- Download Ant and add its =/bin= directory to ~PATH~.

- Add =C:\Program Files\Java\jdk1.8.0_91= to ~JAVA_HOME~ and add ~%JAVA_HOME%/bin~
  to ~PATH~.

*** Special variables

**** umask

#+begin_src shell
# Permissions on newly created files.
umask 022                               # Prevent new dirs and files from being
                                        # group and world writable.
if [[ $EUID -eq 0 ]]; then
    umask 077                           # Stricter.
fi
#+end_src

**** BROWSER

#+begin_src shell
# # For Bash on Ubuntu on Windows.
# export BROWSER='/mnt/c/Windows/explorer.exe' # does not work.
export BROWSER='/mnt/c/Program Files (x86)/Mozilla Firefox/firefox.exe'
#+end_src

*** Locale variables

LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC and
LC_TIME set the language option for the shell and subprograms.

You may need to manually set your language environment (among others, for ~svn~
with accented file names in the repository).

#+begin_src shell
export LANG=C.UTF-8

# For scripts in R language.
export LC_CTYPE=
#+end_src

These variables work as follows:
- LC_ALL forces all the aspects of the locale to the specified value.  If LC_ALL
  is set, all other locale variables will be ignored.
- The other LC_ variables set the specified aspect of the locale information.
- LANG is a fallback value, it will be used if none of the LC_ variables are
  specified.

** EDITOR

#+begin_src shell
# Find a suitable editor.
if [ -z "$SSH_CONNECTION" ]; then
    export EDITOR="emacsclient"
    export ALTERNATE_EDITOR=""
    alias e="emacsclient -n" # 'e .' opens the current directory in Emacs.
    alias ee="emacsclient -n --alternate-editor=emacs"
    alias bgemacs='emacs &'
else
    EDITOR=$(command -v emacs \
                 || command -v subl \
                 || command -v atom \
                 || command -v nano)
    alias e='$EDITOR'
fi
#+end_src

When setting the environment variables ~EDITOR~ and/or ~VISUAL~, you better omit the
~--no-wait~ (~-n~) option: if ~emacsclient~ doesn't wait, the program that opens the
editor will think you exited it. In the case of our ~git commit~, we would end up
with a blank commit message!

#+begin_src shell
# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"
#+end_src

** PAGER

Set the user's preferred *text viewer* (~cat~, ~more~, ~less~ or ~most~) that will be used
by programs such as ~man~ or ~git diff~.

#+begin_src shell
export PAGER="less"
#+end_src

With the ~less~ command, you can *scroll up* in the file (with ~b~, backward one
window) as well as *scroll down*; with the archaic ~more~ command, you can only
*scroll down* the file.

#+begin_src shell
alias more='less'
#+end_src

*How to get color man pages?*  Color any command with man-like output, including
~git help~:

#+begin_src shell
export LESS_TERMCAP_mb=$'\e[01;31m'     # Begin bold.
export LESS_TERMCAP_md=$'\e[01;36m'     # Begin blink (section titles in cyan).
export LESS_TERMCAP_me=$'\e[0m'         # Reset bold/blink.
export LESS_TERMCAP_so=$'\e[01;44;33m'  # Begin reverse video.
export LESS_TERMCAP_se=$'\e[0m'         # Reset reverse video.
export LESS_TERMCAP_us=$'\e[01;32m'     # Begin underline.
export LESS_TERMCAP_ue=$'\e[0m'         # Reset underline.
#+end_src

If you see ~\e[0m~ etc. appearing when you view the man page, add this line as
well:

#+begin_src shell
export LESS='-R'
#+end_src

If you see ~<E9>~ (in reverse video) etc. appearing when you view accents in an
ISO Latin 1 file (in a UTF-8 terminal), add this:

#+begin_src shell
# Format for displaying non-printable, non-control characters (see `man less').
export LESSBINFMT="*n<%02X>"            # Do not use reverse video.
export LESSBINFMT="*d?"                 # Use bold ?.
#+end_src

Commands for *searching*:

- ~/pattern~ :: Search forward for matching line.
- ~?pattern~ :: Search backward for matching line.
- ~n~ :: Repeat previous search.
- ~N~ :: Repeat previous search in reverse direction.
- ~ESC-u~ :: Undo (toggle) search highlighting.
- ~&pattern~ :: Display only matching lines. \\
     If pattern is empty (if you type ~&~ immediately followed by ~RET~), any
     filtering is turned off, and all lines are displayed.

Commands for *jumping*:

- g :: Jump to start (go to *first line* in file).
- G :: Jump to end (go to *last line* in file).

Miscellaneous commands:

- -S :: Toggle chop (*truncate*) *long lines* rather than wrapping.

Options:

#+begin_src shell
export LESS='-F -i -M -R -X'
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'
#+end_src

: export LESS=-i -g -M -R -x4 -X -f -F -z-1
: export PAGER=less LESS='-wiXz-2$j15' LESSBINFMT=.

~less~ options:

- ~-e~ or ~--quit-at-eof~ ::
     Causes ~less~ to automatically *exit the /second/ time it reaches EOF*.  By
     default, the only way to exit ~less~ is via the ~q~ command.

- -f or --force ::
     *Forces non-regular files* to be *opened*.  (A non-regular file is a directory
     or a device special file.)  Also suppresses the warning message when
     a binary file is opened.

- ~-F~ or --quit-if-one-screen ::
     Causes ~less~ to automatically *exit if the entire file can be displayed in
     one screen*. This is usually desirable as there is no incentive to stay in
     ~less~ if a single screen can display all the contents.

     It means you can just pipe any old thing into it, and if it's only a couple
     of lines, you don't have to quit manually.

     #+begin_warning
     After quitting so, the screen is reset and you end up not seeing the
     content; the ~-X~ option does away with that behavior: *don't reinit the
     screen* when the pager exits.  ~-F~ relies on this option to work properly.
     #+end_warning

- -g or --hilite-search ::
     Normally, less will highlight ALL strings which match the last search
     command.  The -g option changes this behavior to *highlight only the
     particular string which was found by the last search command*.  This can
     cause less to run somewhat faster than the default.

- ~-i~ or ~--ignore-case~ ::
     Causes *searches* to *ignore case*; that is, uppercase and lowercase are
     considered identical.  This option is /ignored if any uppercase letters
     appear in the search pattern/; in other words, if a pattern contains
     uppercase letters, then that search does not ignore case.

- -J or --status-column ::
     Displays a status column at the left edge of the screen.  The status column
     indicates the *lines that matched the current search*, and the first unread
     line after moving a full page (if the -w or -W option is in effect).

- ~-m~ or ~--long-prompt~ ::
     Causes less to prompt verbosely (like ~more~), with the percent into the
     file.  By default, ~less~ prompts with a colon.

- ~-M~ or ~--LONG-PROMPT~ ::
     Causes ~less~ to *prompt* even *more verbosely* than ~more~.

- ~-r~ or ~--raw-control-chars~ ::
     Causes "raw" control characters to be displayed.  The default is to display
     control characters using the caret notation; for example, a ~control-A~
     (octal ~001~) is displayed as ~^A~.

     #+begin_warning
     When the ~-r~ option is used, ~less~ cannot keep track of the actual appearance
     of the screen (since this depends on how the screen responds to each type
     of control character).  Thus, various display problems may result, such as
     long lines being split in the wrong place.
     #+end_warning

- ~-R~ or ~--RAW-CONTROL-CHARS~ ::
     (Only) ANSI *"color" escape sequences* (sequences of the form ~ESC[...m~ where
     the ~...~ is zero or more color specification characters, and ~m~ ends ANSI
     color escape sequences) are *output in "raw" form*.

     #+begin_note
     Without ~--RAW-CONTROL-CHARS~ (or ~--raw-control-chars~), ~less~ outputs the
     colors as raw escape codes; that is, it does not interpret colors. With
     that option, ~git diff~ finally *displays colors*...

     In other words, I definitely recommend ~-R~ if you don't enjoy periodic
     symbol junk terminal confusion.
     #+end_note

- -w or --hilite-unread ::
     Temporarily highlights the first "new" line after a forward movement of
     a full page.  The first "new" line is the line immediately following the
     line previously at the bottom of the screen.  Also highlights the target
     line after a g or p command.  The highlight is removed at the next command
     which causes movement.  The entire line is highlighted, unless the -J
     option is in effect, in which case only the status column is high- lighted.

- -W or --HILITE-UNREAD ::
     Like -w, but temporarily *highlights the first unread line* after any
     scrolling larger than one line.

- -x4 or --tabs=4 ::
     Sets tab stops at multiples of 4, since most modern text files assume
     4-character width for a tab.. The default is 8.

- ~-X~ or ~--no-init~ ::
     *Disables* sending the termcap initialization and deinitialization strings to
     the terminal.  This is sometimes desirable if the deinitialization string
     does something unnecessary, like *clearing the screen*.

     #+begin_note
     Add the ~-X~ option to ~less~ in ~MANPAGER~, for example, if you do not want to
     *clear the screen* when quitting a manual page.
     #+end_note

- -z-4 or --window=-4 ::
     Changes the default scrolling window size to *4 lines less than the current
     screen size*, so always keep 4 lines overlapping with previous screen when
     scrolling with the space key.

** DISPLAY
:PROPERTIES:
:ID:       02ba0b6b-f205-42e2-a801-4271aa4691eb
:END:

#+begin_src shell
# Start x11 server (if a process instance is not already running).
# ps -ae | grep XWin || startxwin > /dev/null 2>&1 &   # XXX For Cygwin only!
# To check that have the package xinit installed, try 'startxwin' without redirecting anything.

# Set DISPLAY environment variable.
export DISPLAY=:0.0
#+end_src

** Abbreviations (aliases)

An *alias* is a simple string substitution.

#+begin_note
By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).
#+end_note

In general, it should not do more than *change the default options of a command*.

Aliases are abbreviations or alternative names (usually mnemonics) for commands.
They are commonly used to specify a few options to commands, and then include
the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like ~$1~.

#+begin_note
Single quotes are evaluated dynamically:
: alias qs='echo $PWD'

Double quotes are evaluated at time of creation and, thereafter, never changes:
: alias qd="echo $PWD"
#+end_note

*** History

Print the history lines matching a pattern.

#+begin_src shell
alias hgrep='history | grep -i'
#+end_src

#+begin_tip
We can't call this alias ~hg~ as that conflicts with the Mercurial prompt of the
Agnoster theme (checking for the presence of the ~hg~ command).
#+end_tip

*** Common aliases

#+begin_src shell
alias which-shell='ps -p $$'
#+end_src

~ls~ options:

- ~-a~ ::
     Do not ignore entries starting with ~.~.

- ~-C~ ::
     List entries by *columns*.

- ~-F~ ::
     Append indicator (one of ~*/=>@|~) to entries.

- ~-g~ ::
     Like ~-l~, but do not list owner.

- ~--group-directories-first~ ::
     Group directories before files.

- ~-G~ ::
     In a long listing, don't print *group* names.

- ~-h~ ::
     With ~-l~ and/or ~-s~, print *human readable* sizes (e.g., ~1K~ ~234M~ ~2G~).

- ~-l~ ::
     Use a *long* listing format.

- ~-s~ ::
     Print the allocated *size* of each file, in blocks.

#+begin_src shell
LS_OPTIONS="$LS_OPTIONS --show-control-chars"

# Make `ls' produce ISO 8601 format.
export TIME_STYLE=long-iso

# Colorize `ls' output.
if [[ "$TERM" != "dumb" ]]; then

    # Add my coloration scheme to directory listings.
    if [[ -f "$HOME"/.dircolors ]]; then
        eval "$(dircolors -b $HOME/.dircolors)"
        # See https://github.com/seebi/dircolors-solarized.
    else
        eval "$(dircolors -b)"
    fi

    alias ls='ls --color=auto -F'
    alias ll='ls --color=auto -a --group-directories-first -G -h -l'
                                        # Long listing and hidden files.
else
    alias ls='ls -CF'
fi
#+end_src

*************** TODO Beautify the terminal's ls command, with color and font-awesome icons
https://github.com/athityakumar/colorls
*************** END

Sort of tree:

#+begin_src shell
alias dirf='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'
#+end_src

~df~ options:

- ~-h~ ::
     Print sizes in powers of 1024 (e.g., ~1023M~).

- ~-k~ ::
     Like ~--block-size=1K~.

- ~-T~ ::
     Print file system type.

Make ~df~ human readable.

#+begin_src shell
alias df='df -kTh'
#+end_src

Make ~du~ human readable.

#+begin_src shell
alias du='du -kh'

alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'         # Ordered by size.
#+end_src

#+begin_src shell
alias mount='mount | column -t'
#+end_src

List all the files in this directory, and sort by human-readable file size.

#+begin_src shell
alias sizes="du --max-depth=1 -k | sort -nr | cut -f2 | xargs -d '\n' du -sh"
#+end_src

#+begin_src shell
# Play safe!  Prevent some accidental mistakes.
alias rm='rm -i'                        # Confirm removing file.
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.
#+end_src

#+begin_note
The above aliases *alter* the *original* meaning of existing commands -- that
scripts don't expect to see modified!
#+end_note

#+begin_src shell
# Make an extract function!
alias tgz='tar -zxvf'
alias tbz2='tar -jxvf'
#+end_src

Interesting alias in Oh My Zsh: ~x~ / ~extract~ to extract an archive of types
tar.{bz2,gz,xz,lzma}, bz2, rar, gz, tbz2, tgz, zip, Z, 7z.

#+begin_src shell
# Print a more readable PATH (each directory on a new line).
alias path='echo "$PATH" | sed -e "s/:/\n/g"'
alias path='sed "s/:/\n/g" <<< "$PATH"' # here-strings (undefined in POSIX sh).
alias path='tr ":" "\n" <<< "$PATH"'    # here-strings.
alias path='echo -e "${PATH//:/\\n}"'   # Parameter expansion (string replacement undefined in POSIX sh/dash).
# https://ubuntuplace.info/questions/4532/comment-afficher-les-chemins-dans-path-separement

# Path.
alias where='type -a'                   # Good?
#+end_src

#+begin_src shell
alias mkall='./configure && make && sudo make install'
#+end_src

#+begin_src shell
# Enable aliases to be sudo’ed.
alias sudo='sudo '

# Become root.
alias root='sudo -i'
#+end_src

#+begin_src shell
alias apt-updater='sudo apt-get update \
    && sudo apt-get dist-upgrade -Vy \
    && sudo apt-get autoremove -y \
    && sudo apt-get autoclean \
    && sudo apt-get clean'
#+end_src

#+begin_src shell
alias poweroff="systemctl poweroff"
alias reboot="systemctl reboot"
#+end_src

#+begin_src shell
# Make executable.
alias exe='chmod +x'
alias addx='chmod +x'

# Chown current dir and subdirs.
alias own='sudo chown -R $USER'
#+end_src

*** Changing Working Directory

#+begin_src shell
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

alias -- -='cd -'                       # Alias '-' to 'cd -'.
#+end_src

#+begin_src shell
# Print the current directory stack (list directory history).
alias d='dirs -v | head -n 10'
#+end_src

Normally, you can use ~cd +1~ to go to the previous directory in the list, and so
on.  Here, this even more straightforward; you can use just the number of the
entry in the *directory history* you want to visit: ~1~.

#+begin_src shell
alias 1='cd -'
alias 2='cd +2'
alias 3='cd +3'
alias 4='cd +4'
alias 5='cd +5'
alias 6='cd +6'
alias 7='cd +7'
alias 8='cd +8'
alias 9='cd +9'
#+end_src

#+begin_src shell
# # For WSL.
# alias c:='cd /mnt/c'
# alias d:='cd /mnt/d'
#
# # For Cygwin.
# alias c:='cd /cygdrive/c'
# alias d:='cd /cygdrive/d'
#+end_src

*** Shortcuts (single char for some commands)

#+begin_src shell
alias c='clear'
alias j='jobs -l'
alias l='ls'                            # xx
alias m='man'
# alias p='$PAGER'
alias q='exit'
alias s='sudo'
alias t='tail -f'
# alias x='exit' # Conflict with extract (from Oh-my-Zsh?)
#+end_src

*** Colorize diff output

*Highlight SVN diffs in the Shell (in Cygwin)???*

#+begin_src shell
# Make `diff' automatically call `colordiff' (Install `colordiff' package...).
alias diff='colordiff'
#+end_src

*** Git

#+begin_src shell
alias g='git'
#+end_src

Go to the top of your Git repo.

#+begin_src shell
# alias gitroot='cd $(git rev-parse --show-toplevel)' # Conflict with Oh My Zsh?

# Good alias that will not blow up cd if you aren't in a Git directory.
alias cdroot='git rev-parse && cd "$(git rev-parse --show-toplevel)"'
#+end_src

http://jonas.nitro.dk/tig/manual.html

#+begin_src shell
alias tigs='tig status'                 # Use it all of the time!
alias tigb='tig blame'
alias tigall='tig --all'
alias tigreleases='tig --all --simplify-by-decoration'
#+end_src

http://stackoverflow.com/tags/tig/hot

*** TODO Color lines in shell (GRC, Supercat, Highlight, etc.)

http://stackoverflow.com/questions/4267400/colour-highlighting-output-based-on-regex-in-shell

highlight-lines-matching-regexp "ERROR"

*** UTF-8 BOM

Remove the UTF-8 encoded BOM if it exists (make no changes if it doesn't).

#+begin_src shell
alias remove-bom='sed -i "1s/^\xEF\xBB\xBF//"'
#+end_src

*** Screen

Connect to a host in a new screen tab, with the device name as the tab title.

#+begin_src shell :tangle no
s() {
    screen -t "$@" /usr/bin/ssh "$@"
}

alias screen='screen -U'
alias resume='screen -D -R'
alias sr='screen -r'
#+end_src

*** SSH agent / GPG agent
:PROPERTIES:
:header-args+: :tangle no
:END:

Most of our servers don't listen to SSH on a public VLAN. I can't be bothered to
keep a tunnel open on my laptop when away from the office:

#+begin_src shell
zugzug() {
    ssh -A -p <non_standard_port> -t <proxy_server> ssh "$1"
}
#+end_src

While it's a function and not an alias, I find it invaluable.

#+begin_src shell
alias keyon='ssh-add -t 10800'          # Add identity.
alias keyoff='ssh-add -D'               # Remove all identities.
alias keylist='ssh-add -l'              # List all identities.
#+end_src

#+begin_src shell
# gpg.
searchkey() {
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@"
}
#+end_src

#+begin_src shell
# Get gpg-key from keyserver.
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'
#+end_src

*** Debian
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
alias aps='aptitude search'
#+end_src

*** System admin (NMAP, etc.)
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
# Use `pkill' (which is pgrep + kill in a single command).

# Show only my processes.
alias mytop='top -u $USERNAME'
#+end_src

#+begin_src shell
# My traceroute.
have mtr && alias ping=mtr

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 Compare /proc with ps (against rootkits).
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# # 040210 Grep.
# alias g='find . -type f -print0 | xargs -0 grep'
alias rgrep="grep -r"
#+end_src

#+begin_src shell
# Echo my current external IP address.
have curl && alias whatismyip='curl -s http://whatismyip.org'
#+end_src

#+begin_src shell
alias externalip='wget http://ipinfo.io/ip -qO -'
alias internalip='ipconfig getifaddr en0'

# Get your external IP address.
# curl ifconfig.me

# Get internal IP address.
alias ip='ipconfig getifaddr en0 || ipconfig getifaddr en1'

alias wanip='dig +short myip.opendns.com @resolver1.opendns.com'
#+end_src

#+begin_src shell
alias docker-rm-all='sudo docker ps -a | awk "NR > 1{print \$1}" | xargs sudo docker rm'

alias dk='docker'
alias dkc='docker-compose'
alias dkm='docker-machine'

alias dk-ips="docker ps -q | xargs -n 1 docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}} {{ .Name }}' | sed 's/ \//\t/'"
alias dk-clean='docker-clean'



alias db='docker build'
alias dc='docker-compose'
alias de='docker exec'
alias del='docker exec -it $(docker ps -q | head -n1) bash'
alias di='docker images'
alias docker-clean='docker-rm-all && docker-prune'
alias docker-prune='docker rmi $(docker images -f "dangling=true" -q)'
alias docker-rm-all='docker rm -f $(docker ps -a -q)'
alias dps='docker ps'
alias dr='docker run'
alias drl="docker-run-last"



alias dl="docker ps -l -q"
alias dps="docker ps"
alias di="docker images"
alias dkd="docker run -d -P"
alias dki="docker run -i -t -P"
alias dex="docker exec -i -t"
#+end_src

#+begin_src shell
# 040319 Send files via `netcat'.
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/} | nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'
#+end_src

#+begin_src shell
# Sharing file through http 80 port.
# From the other machine open a web navigator and go to ip from the machine who
# launch netcat, http://ip-address/ If you have some web server listening at 80
# port then you would need stop them or select another port before launch net
# cat ;-) * You need netcat tool installed
# nc -v -l 80 < file.ext
#+end_src

#+begin_src shell
# Recursively delete `.DS_Store` files
alias cleanup="find . -type f -name '*.DS_Store' -ls -delete"

# Empty the Trash on all mounted volumes and the main HDD
alias emptytrash="sudo rm -rfv /Volumes/*/.Trashes; sudo rm -rfv ~/.Trash"
#+end_src

#+begin_src shell
# Intuitive map function
# For example, to list all directories that contain a certain file:
# find . -name .gitattributes | map dirname
alias map="xargs -n1"
#+end_src

#+begin_src shell
# Honor embedded linefeeds when displaying packets.
alias ngrep='ngrep -W byline'

# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23

# View HTTP traffic.
alias sniff='sudo ngrep -d "eth1" -t "^(GET|POST) " "tcp and port 80"'
alias httpdump="sudo tcpdump -i eth1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""
#+end_src

#+begin_src shell
ipf() {
    curl -H 'Accept: application/json' "ipinfo.io/$1" | jq .
}

for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
  alias "$method"="curl -X '$method'"
done

# Run `dig` and display the most useful info
digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}
#+end_src

#+begin_src shell
# IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="ipconfig getifaddr en0"
alias ips="ifconfig -a | grep -o 'inet6\? \(addr:\)\?\s\?\(\(\([0-9]\+\.\)\{3\}[0-9]\+\)\|[a-fA-F0-9:]\+\)' | awk '{ sub(/inet6? (addr:)? ?/, \"\"); print }'"
#+end_src

#+begin_src shell
alias ports='netstat -alpe --ip'

# Open ports.
alias ports='netstat -tulanp'
alias ports='netstat -tulap'

alias openports='netstat -nape --inet'
#+end_src

#+begin_src shell
# localnet - Find the local network in CIDR notation.
localnet() {
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}
#+end_src

#+begin_src shell
# Resume getting a partially-downloaded file.
alias wget='wget -c'

# Anonymous wget (using Privoxy and Tor).
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror='wget -v --tries=0 --continue --force-directories --mirror --no-parent'

alias download_web_site='wget --random-wait -r -p -e robots=off -U mozilla'
#+end_src

*** Org

#+begin_src shell
org_test() {
    (
        cd "$HOME"/Public/Repositories/org-mode
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest \
            emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

*** Grep

#+begin_note
~GREP_OPTIONS~ causes problems because it *applies in scripts* that may be relying
on the exact set of options that they pass to ~grep~; it's even officially
*deprecated* since ~grep~ 2.21.  It is better to make ~grep~ itself an alias (and also
~egrep~ and ~fgrep~ if you use them).
#+end_note

#+begin_src shell
# Display the matched pattern in color.
alias grep='grep --color=auto'
alias egrep='grep -E --color=auto'
alias fgrep='grep -F --color=auto'
#+end_src

#+begin_warning
If you use ~--color=always~, it'll use color even when piping, which confuses
things.
#+end_warning

Change the color of ~grep~:

#+begin_src shell
# export GREP_COLOR='0;33;1;44'         # Bold Yellow on blue.
export GREP_COLORS="sl=:cx=:mt=01;33;1;44:ms=01;33;1;44:mc=01;33;1;44:fn=35:ln=32:bn=32:se=36"
#+end_src

- sl :: *Matching Lines* ("selected" lines)
- cx :: Context Lines
- mt :: *Matching Text* in any matching line
- ms :: Matching text in a Selected line
- mc :: Matching text in a Context line
- fn :: File Name
- ln :: Line Number
- bn :: Byte Number
- se :: Separator

Paste in a GREP_COLORS string to preview it.
Tweak the style the way you want, with a live preview of how it'll look!
See https://dom.hastin.gs/files/grep-colors/

#+begin_note
The colors are defined by the environment variable ~GREP_COLORS~ (used in ~grep~
2.5.2 and later versions). The *deprecated* environment variable ~GREP_COLOR~ (used
in ~grep~ 2.5.1) is still supported, but its setting does not have priority.

But apparently, this is not the case on my system. ~GREP_COLOR~ is the one that
works?  (... That's when there is no mt specification in the GREP_COLORS env
var...)
#+end_note

#+begin_src shell
# Grep through the running processes.
alias pgrep='pgrep -fl'
alias 'ps?'='ps ax | grep '
#+end_src

*** Ripgrep

#+begin_src shell
alias rg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold'"
alias srg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold' --sort-files"
#+end_src

*** Ag, the Silver Searcher

[[https://blog.kowalczyk.info/software/the-silver-searcher-for-windows.html][The Silver Searcher windows port]]

#+begin_src shell :tangle no
have ag && alias grep=ag
#+end_src

*** GraphicsMagick

See also https://image.online-convert.com/fr...

#+begin_src shell
# GraphicsMagick.
alias GIF='gm convert -verbose -interlace LINE'
alias thumb='gm convert -geometry 100x100 -interlace LINE -verbose'
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize() {
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES; do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # Obscure but useful string operations.
        # (See http://www.arachnoid.com/linux/shell_programming.html.)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

*** Other things to sort

#+begin_src shell
export GS_OPTIONS='-sPAPERSIZE=a4'
alias pdfmerge='gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./pdf-joined.pdf' # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

#+begin_src shell
# clean [-r] - Remove useless files (recursively).
clean() {
    if [[ "$1" = "-r" ]]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" \
             -o -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" \
             -o -name "*.~BASE~" -o -name ".*.~BASE~" \) \
             -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}
#+end_src

#+begin_src shell
# swap FILE1 FILE2 - Swap FILE1 and FILE2.
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap() {
    if [[ $# != 2 ]]; then
        return 2
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f "$1" $tmpfile
    mv -f "$2" "$1"
    mv -f $tmpfile "$2"
    return 0
}
#+end_src

#+begin_src shell
saneperms() {
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod "${1:=644}"
}
#+end_src

#+begin_src shell
# # Search for various types or README file in dir and display them in $PAGER.
# readme() {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }
#+end_src

#+begin_src shell
safetmp() {
    test -d "$HOME" || exit 1
    test -d "$HOME"/tmp || mkdir "$HOME"/tmp
    echo "$HOME/tmp/safetmp.$(hostname).$(date +%s).$$"
}
#+end_src

#+begin_src shell
# Immediately opens the first match.
texman() {
    locate "$*" | grep pdf | grep texlive | head -1 | xargs open
}

texlist() {
    locate "$*" | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)"
}
#+end_src

*** Extra

#+begin_src shell
## Commandline Fu
cmdfu() { curl "http://www.commandlinefu.com/commands/matching/$(echo "$@" \
        | sed 's/ /-/g')/$(echo -n $@ | base64)/plaintext" ;}

##Check if websites are down
down4me() { curl -s "http://www.downforeveryoneorjustme.com/$1" | sed '/just you/!d;s/<[^>]*>//g';}

## Google Translate Functions ##

say() {
   find ~/Downloads/en -name "$1.ogg" -exec ogg123 {} \;
   # mplayer -user-agent Mozilla -prefer-ipv4 \
   # "http://translate.google.md/translate_tts?ie=UTF-8&tl="$1"&q=$(echo "$@" \
   # | cut -d ' ' -f2- | sed 's/ /\+/g')" > /dev/null 2>&1 ;
}

say-translation() {
   lang=$1
   trans=$(translate {=$lang} "$(echo "$@" | cut -d ' ' -f2- | sed 's/ /\+/g')" )
   echo $trans
   mplayer -user-agent Mozilla \
   "http://translate.google.com/translate_tts?ie=UTF-8&tl=$lang&q=$trans" > /dev/null 2>&1 ;
}
#+end_src

#+begin_src shell :tangle no
console() {
    if [[ $# > 0 ]]; then
        query=$(echo "$*" | tr -s ' ' '|')
        tail -f /var/log/system.log | grep -i --color=auto -E "$query"
    else
        tail -f /var/log/system.log
    fi
}
#+end_src

*** Alert

Add an "alert" alias for *long running commands*.

#+begin_src shell
alert() {
    $@
    echo -e "\a"                        # Beep.
}
#+end_src

#+begin_src shell :tangle no
alias alert='notify-send --urgency=low -i "$([[ $? = 0 ]] && echo terminal || echo error)" "$(history | tail -n1 | sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

Use like so:

: sleep 10; alert

* Getting started

** Prerequisites for Windows

Install [[https://www.cygwin.com/][Cygwin]] (http://mirrors.kernel.org).

*** ~PATH~

After Cygwin is installed, modify the System ~PATH~ variable: prepend it with
=C:\cygwin64\bin= (before ~%SystemRoot%\system32~).

#+begin_warning
If you add other directories (such as =~/bin= or =~/winbin=) in the ~PATH~ before
Cygwin, please check that those directories don't contain =cygwin1.dll= or
such. That was why I had troubles running ~git~ commands...
#+end_warning

In =c:/cygwin64/etc/profile=,

- =/usr/local/bin= is appended to the ~PATH~!!

  And, except when root, it is almost always wrong to have =/usr/local/bin= after
  any system path.

- ~TZ~ (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from =c:/cygwin/Cygwin.bat=!!

*** HOME, the user's home directory

Add an ~HOME~ environment variable (with no trailing backslash!).

Programs like ~ssh~ don't rely on your environment variable ~HOME~ for the location
of your *home directory*.

Starting with Cygwin 1.7.34, the recommended way to do this is to add a custom
~db_home~ setting (comment the example line) to =/etc/nsswitch.conf=.

#+begin_note
If you installed Cygwin prior to 1.7.34 or have run its ~mkpasswd~ utility so that
you have an =/etc/passwd= file, you can change your Cygwin ~HOME~ directory by
editing your user's entry in that file. Your ~HOME~ directory is the penultimate
element on your user's line in =/etc/passwd= (the ~HOME~ environment variable is set
from that field).
#+end_note

*** Packages

*************** TODO See http://www.4thinker.com/cygwin-setup.html
*************** END

[[http://cygwin.com/cgi-bin2/package-grep.cgi][Cygwin Package Search]]

In order to *install Cygwin's packages* through the terminal instead of running
the setup every single time you need one, you can install ~apt-cyg~.  As
a requirement, you'll need to install ~lynx~ through the cygwin setup first.
After that, just run the following commands:

#+begin_src shell
lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg > apt-cyg
install apt-cyg /bin
#+end_src

- Archive
  + [X] ~unzip~
  + [X] ~zip~ (used by the "Org to ODT" exporter)

- Database
  + [X] ~freetds~ (for ~tsql~)

- Devel
  + [ ] ~autoconf~
  + [ ] ~bzr~
  + [ ] ~ctags~ (Exuberant Ctags)
  + [ ] ~gcc-core~ (C compiler)
  + [ ] ~gcc4~ (needed for installing some Perl packages, for CSV2Ledger)
  + [X] ~gdb~
  + [X] ~git~
  + [X] ~make~ (for making info for Git Org mode)
  + [X] ~meld~ (for diffing -- requires ~xinit~)
  + [ ] ~mercurial~ (for ~hg~ command, used by Beamer)
  + [X] ~patch~
  + [X] ~patchutils~
  + [X] ~subversion~ (for ~svn~ command)

- Editors
  + [X] ~emacs~
  + [X] ~emacs-el~ (needed to get more up-to-date sources, such as for Org)
  + [X] ~emacs-w32~ (for graphical Cygwin Emacs with the w32 graphics toolkit)

- Graphics
  + [X] ~ghostscript~ (needed by various utilities -- ~texlive~ for example)
  + [ ] ~gnuplot~
  + [X] ~graphviz~ (~dot~)
  + [X] ~poppler~ (for ~pdftotext~)

- Interpreters
  + [ ] ~m4~

- Libs
  + [ ] ~libbz2-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiconv~
  + [ ] ~libicu-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiodbc-devel~ (needed for installing RODBC inside R)

- Math
  + [X] ~R~

- Net
  + [X] ~bind-utils~ (for ~dig~, ~host~, ~nslookup~, etc.)
  + [X] ~curl~
  + [X] ~inetutils~ (for getting ~telnet~ to work with expect)
  + [ ] ~nc~ (see socat)
  + [ ] ~openssh~
  + [ ] ~ping~ (Note: Allow to "Run this program as an administrator")
  + [ ] ~rsync~
  + [X] ~sitecopy~
  + [ ] ~socat~ (see ~nc~)

- Perl
  + [ ] ~perl~

- Publishing
  + [X] ~texlive~ (= TeX only, not LaTeX!  It requires ~fontconfig~ and ~ghostscript~)
  + [X] ~texlive-collection-binextra~ (for ~latexmk~)
  + [X] ~texlive-collection-fontsextra~ (for =libertine.sty=)
  + [X] ~texlive-collection-fontsrecommended~ (for =marvosym.sty=, etc.)
  + [X] ~texlive-collection-genericrecommended~ (for =ulem.sty=, etc.)
  + [X] ~texlive-collection-langfrench~ (for ~frenchb~)
  + [X] ~texlive-collection-latex~
  + [X] ~texlive-collection-latexextra~ (for =draftwatermark.sty=, etc.)
  + [X] ~texlive-collection-science~ (for =siunitx.sty=, etc.)

- Python
  + [X] ~python~

- Ruby
  + [ ] ~ruby~

- Shells
  + [ ] ~rxvt~
  + [X] ~zsh~

- System
  + [X] ~procps-ng~ (to get ~top~ and ~pkill~)
  + [ ] ~psmisc~ (to get ~killall~)

- Tcl
  + [ ] ~expect~

- Text
  + [ ] ~antiword~
  + [X] ~aspell~ (Note that the Win32 binary has *much* more dictionaries! Use that
    one instead if you need "nl" language...)
  + [ ] ~jq~ (for displaying JSON)
  + [ ] ~most~
  + [ ] ~opensp~ (for ~nsgmls~ validator)
  + [X] ~texinfo~ (for ~makeinfo~)
  + [ ] ~tidy~

- Utils
  + [X] ~colordiff~ (for ~svn~)
  + [ ] ~dos2unix~
  + [ ] ~fdupes~
  + [ ] ~file~ to determine file type
  + [ ] ~flog~ (logger, to syslog)
  + [X] ~gnupg~ (for ~gpg~) -- requiring ~libusb0~ (though you don't need to install
    the Win32 driver which is adviced!)
  + [X] ~moreutils~ (provides ~sponge~)
  + [X] ~ncurses~ (provides ~tput~ and the ~clear~ command used by the TeX Live
    installer, though you can use ~C-l~ to get the same result)
  + [ ] ~screen~
  + [ ] ~sgrep~ (installs the XPath command ~xmllint~, with ~libxml2~)
  + [X] ~the_silver_searcher~ (ag)
  + [X] ~tig~ (Git browser)
  + [X] ~xmlstarlet~

- X11
  + [ ] ~fontconfig~ (needed by XeTeX)
  + [X] ~xinit~ (needed by ~meld~)
    See [[id:02ba0b6b-f205-42e2-a801-4271aa4691eb][Display]].

- Web
  + [ ] ~wget~

Many Unix commands have already newer and more feature-rich
replacements:

- df :: pydf
- less :: most
- tail :: multitail
- top :: htop
- tracepath :: mtr
- traceroute :: mtr

*** Terminal emulators

For a better Emacs experience than with the Cygwin console, use:

- MinTTY
- (u)rxvt
- xterm

#+begin_tip
*~Alt-F2~ opens a new terminal window*

*~Shift-PageUp~ and ~Shift-PageDown~!*

For rapidly paging through previous lines of output, you can press ~Shift-PageUp~
and ~Shift-PageDown~, just like the Linux console.

*Searching text in scrollback buffer (in Cygwin MinTTY)*

In mintty, ~Alt-F3~ opens a search bar with an input field for a search string.
Matches are highlighted in the scrollback buffer.  ~Enter~ / ~Shift+Enter~ find the
~next~ / ~previous~ position of the match and scrolls the scrollback buffer
accordingly.  The appearance of the search bar and the matching highlight
colours can be customized.

See [[https://mintty.github.io/mintty.1.html][man page]].
#+end_tip

*** Terminal types

- ~dumb~
- ~cygwin~
- ~emacs~
- ~screen~
- ~xterm~
- ~xterm-256color~
- ~eterm-color~

Set the *terminal type* explicitly to get a nice *256 color* palette (instead of the
ugly default 8 colors):

#+begin_src shell :tangle no
export TERM=xterm-256color
#+end_src

#+begin_tip
In fact, we are advised to *NOT* set ~TERM~ variable in dotfiles that are related to
the *shell*, as opposed to dotfiles related to the *terminal emulator* program.
This is because a shell may be used with multiple terminal emulators, and
setting ~TERM~ there is obviously a misplacement mistake, an all too common one...
The proper place to override the ~TERM~ value is in a terminal emulator dotfile,
something like =~/.minttyrc=.
#+end_tip

Initialize the terminal according to the type of terminal in the environmental
variable ~TERM~.

#+begin_src shell
# tput init                             # This resets the Solarized color theme!!!
#+end_src

#+begin_note
This command should be included in everyone's =.profile= after the environmental
variable ~TERM~ has been exported.
#+end_note

#+begin_seealso
Use the script ~colortest~ (on Linux distros) to output the default colors.
#+end_seealso

See what your color palet is for the terminal session:

#+begin_src shell :tangle no
tput colors
#+end_src

*** GnuPG

When first running ~gpg~:

- Directory =~/.gnupg= created
- New configuration file =~/.gnupg/gpg.conf= created
- Keyring =~/.gnupg/secring.gpg= created (empty)
- Keyring =~/.gnupg/pubring.gpg= created (empty)

*** Suppress the Cygwin DOS path warning

When first running ~M-x ediff-buffers~, I got this Cygwin warning:

#+begin_example
MS-DOS style path detected: c:/Users/...
Preferred POSIX equivalent is: /cygdrive/c/Users/...
CYGWIN environment variable option "nodosfilewarning" turns off this warning.
Consult the user's guide for more details about POSIX paths:
  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
#+end_example

Though, setting it in =.bashrc= or something like that does not work. A good
place to set it is in the global *Windows environment variables*.

** TODO Basic installation (OBSOLETE)

Shell-Leuven is installed by doing the following:

1. *Clone the repository:*

   #+begin_src shell
   git clone git@github.com:fniessen/dotfiles.git ~/.dotfiles
   ~/.dotfiles/install
   #+end_src

2. *Source Shell-Leuven configuration files*

   #+begin_src shell
   . ~/.bash_profile
   #+end_src

   #+begin_src shell
   . ~/.zshrc
   #+end_src

Once you open up a new terminal window with Bash or Zsh, it should load with
Shell-Leuven's configuration.

** Custom directory

If you'd like to change the install directory with the ~ZSH~ environment variable,
either by running

: export ZSH=/your/path

before installing.

* FAQ

** How to run Windows Emacs without showing a terminal window?

Use the ~run~ command:

#+begin_src shell
C:\cygwin64\bin\run.exe /usr/bin/emacs
#+end_src
