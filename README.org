#+TITLE:     Shell-Leuven
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   num:nil ^:{}

#+PROPERTY:  header-args :eval no
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

XXX (See Fish web_config for sorting things out)

Look at https://github.com/jlevy/the-art-of-command-line!

XXX https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html
XXX https://www.linuxtrainingacademy.com/23-handy-bash-shell-aliases-for-unix-linux-and-mac-os-x/
XXX https://pissedoffadmins.com/

* Summary

Shell-Leuven is a set of configuration files to take advantage of Bash and Zsh
on Mac OS X, Linux and Windows (with Cygwin).

* COMMENT Tasks

** TODO Look at shell scripts

https://bitbucket.org/ambrevar/dotfiles/src/ac47e01e1b25942d5a3f83616a91f9eab6382823/.scripts/?at=master

(pdfscan, etc.)

** TODO Bash aliases

http://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html

** TODO Follow coding conventions

http://wiki.bash-hackers.org/scripting/style

** TODO Remove Bashisms

- https://wiki.ubuntu.com/DashAsBinSh
- http://mywiki.wooledge.org/Bashism

*** TODO Use printf instead of echo -e

See http://www.bashguru.com/2010/01/shell-colors-colorizing-shell-scripts.html.

** TODO Unset TZ (from Eli Zaretskii)
[2015-03-30 Mon 16:51]

#+begin_verse
> Though, this morning, in the above configuration (Cygwin GDB + pretest
> of Emacs 24.5), I had a problem with the Org timestamps: they were one
> hour late, like if the computer clock hadn't been updated with the
> "summer" times here in Europe (since this Saturday).
>
> I finally found that the problem does not come from Emacs itself, but
> from the fact it's launched from Cygwin GDB!

Probably because GDB sets TZ to something a native Windows program
cannot grok.  Or something like that.

> Any idea how this problem can be circumvented?

You could unset TZ inside GDB before running Emacs (assuming my guess
is correct; what does "M-x getenv RET TZ RET" show inside Emacs?).

But the best way is to use a native port of GDB, of course.  Let me
know if you need a pointer to a binary distribution ready to be
installed.
#+end_verse

From [[gnus:INBOX#83zj6uy1vr.fsf@gnu.org][Email from Eli Zaretskii: Re: bug#20179: 24.4; Crash whe]]

** TODO Integrate goodies

See [[file:~/bin/bash-goodies]].

** TODO Look at color Bash prompt

https://wiki.archlinux.org/index.php/Color_Bash_Prompt
Very interesting settings!

* Startup files

# See http://zsh.sourceforge.net/Guide/zshguide02.html

There are 3 *types of shells*:

- (interactive) *login*

  (for which =c:/cygwin/etc/profile= and =.profile= are read, which sources =.bashrc=
  as well)

  #+begin_note
  Launching Cygwin Terminal (login shell) does not load =.bashrc= on its own, it
  only loads =.bash_profile=. Hence, the need to have a =.bash_profile= sourcing
  =.bashrc=...
  #+end_note

- *interactive* (non-login)

  (for which =.bashrc= is read)

- normal shell

  i.e. one that's running a *script* (Bash does not execute any initialization
  file in this case!)

  ~$tty~ is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For Bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.

#+begin_src shell :tangle .bash_profile
# User dependent .bash_profile file

# Source the user's .bashrc if it exists.
if [[ -f "$HOME"/.bashrc ]]; then
    . "$HOME"/.bashrc
fi
#+end_src

- For Zsh, put stuff in =~/.zprofile=, which is always executed.

To recover the default Bash configuration files, get their copy from
=/etc/skel=.

See http://blog.flowblok.id.au/2013-02/shell-startup-scripts.html for a Dotty
graph of the files...

#+begin_note
If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.
#+end_note

** What to put where?

Login shell runs =.profile= (or =.bash_profile= or =.bash_login=) on startup. Set your
env variables in there, because sub-shells will inherit the env vars. Then make
=.profile= run your =.bashrc=:

#+begin_src shell
. .bashrc
#+end_src

Interactive runs =.bashrc=. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare minimum. Therefore
your ~PATH~ won't work very well so you often have to give an absolute pathname
like in ~crontab~:

#+begin_src shell
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** What to put in your Zsh startup files

See http://zsh.sourceforge.net/Guide/zshguide02.html.

* Bash Configuration
:PROPERTIES:
:header-args+: :tangle .bashrc
:END:

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## bash_profile --- Bash configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

# Code:
#+end_src

Prevent "stdin is not a tty" errors when ~ssh~'ing to a remote machine (or using
~scp~, ~rcp~ or ~rsync~):

#+begin_src shell
# If not running interactively, don't do anything.
# isInteractive=$(echo $- | grep i)
[[ "$-" != *i* ]] && return
#+end_src

You don't want to perform a full-blown initialization every time scripts
execute.

It's important to refrain from outputting anything in those cases.

** Make zsh your default shell on Windows

To start directly Zsh when opening /Bash on Ubuntu on Windows/:

#+begin_src shell :noweb yes
# # If running in terminal...
# if test -t 1; then
#     # ... start Zsh
#     echo "Start Zsh..."
#     exec zsh
# fi
#+end_src

** Local customizations

#+begin_src shell
# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_before ]; then
    . "$HOME"/.shellrc_local_before
fi

# Allow local Bash customizations.
if [ -f "$HOME"/.bashrc_local_before ]; then
    . "$HOME"/.bashrc_local_before
fi
#+end_src

** Prompt

Note ~\[...\]~ used by the shell to count proper length.

#+begin_src shell :tangle no
if tput setaf 1 &> /dev/null; then
    tput sgr0
    if [[ $(tput colors) -ge 256 ]] 2> /dev/null; then
        MAG=$(tput setaf 9)
        ORANGE=$(tput setaf 172)
        GREEN=$(tput setaf 190)
        PURPLE=$(tput setaf 141)
        WHITE=$(tput setaf 256)
    else
        MAG=$(tput setaf 5)
        ORANGE=$(tput setaf 4)
        GREEN=$(tput setaf 2)
        PURPLE=$(tput setaf 1)
        WHITE=$(tput setaf 7)
    fi
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
#+end_src

See [[http://ezprompt.net/][Easy Bash PS1 Generator]]

- Insert an empty line before the prompt
- Change Bash prompt color based on exit code of last command

#+begin_src shell :tangle no
# Define empty function (if not yet defined).
type -t __git_ps1 || __git_ps1() { :; }
#+end_src

#+begin_src shell
# Colors.
BLK="\[$(tput setaf 0; tput bold)\]"
RED="\[$(tput setaf 1; tput bold)\]"
grn="\[$(tput setaf 2)\]"
GRN="\[$(tput setaf 2; tput bold)\]"
yel="\[$(tput setaf 3)\]"
reset_color="\[$(tput sgr0)\]"

# PS1 --- Default interaction prompt

case "$TERM" in
    "dumb")
        # No fancy multi-line prompt for TRAMP (see `tramp-terminal-type').
        # Don't confuse it!
        PS1="\n> "
        ;;
    cygwin|xterm*|rxvt-unicode)
        # `M-x shell' under Cygwin Emacs.
        # `M-x term' under Cygwin Emacs.
        BEL=$(tput bel)
        PS1='\n\
$(st=$?; if [[ $st -eq 0 ]]; then printf "\[\033[01;32m\]v"; else printf "\[\033[01;31m\]$BEL$st"; fi)\
\[\033]0;$PWD\007\] \
\[\033[0;32m\]\u@\h\
\[\033[01;30m\]:\
\[\033[;;33m\]\w\
\[\033[36m\]`__git_ps1`\n\
\[\033[32m\]$\[\033[0m\] '
        ;;
    ,*) # emacs
        # `M-x shell' under EmacsW32.
        PS1="\n$?\u@\h:\w \$ "
        ;;
esac
# PS1+='$(if test $? -ne 0; then tput bel; fi)'
#+end_src

#+begin_src shell
export PS2="incomplete? continue here-> "
#+end_src

#+begin_src shell
# PS4 --- Used by "set -x" to prefix tracing output

# Get line numbers when you run with `-x'.
PS4='+'$grn'[$0:$LINENO]+ '${reset_color}
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

#+begin_tip
Single quotes around ~LINENO~ in ~PS4~; otherwise, *this* line number is taken...
#+end_tip

#+begin_tip
If you are looking at performance issues, put ~$SECONDS~ in the PS4 prompt as
well.
#+end_tip

** Functions

** Variables

#+begin_src shell
# Automatically cd into a  directory without the `cd' in front of it.
shopt -s autocd

# Correct dir spellings.
shopt -s cdspell

# Make sure display get updated when terminal window get resized.
shopt -q -s checkwinsize

# When running two bash windows, allow both to write to the history.
shopt -s histappend

# Make multi-line commands 1 line in history.
shopt -q -s cmdhist
#+end_src

** History

Access and modify commands that you had previously typed at the command line.

#+begin_src shell
# Store 10000 commands in history buffer.
export HISTSIZE=10000

# Store 10000 commands in history FILE.
export HISTFILESIZE=10000

# Avoid recording common commands (like ls, top and clear).
export HISTIGNORE="ls*:top:clear"

# Ignore duplicate commands and commands starting with space.
export HISTCONTROL="ignoreboth"         # Prefix a command with a space to keep it out of the history.
#+end_src

Le ~!~ en shell permet plein de trucs sympa.

- ~!!~ refait la dernière commande
- ~!cmd~ refait la dernière commande commençant par ~cmd~
- ~!cmd:p~ permet de visualiser sans éxecuter la dernière commande commençant
  par ~cmd~
- ~!$~ est le dernier mot de la ligne de commande précédente
- ~!cmd:$~ est le dernier mot du dernier ligne de commande commençant par ~cmd~
- ~!*~ est l'ensemble de la dernière ligne de commande à part le premier mot

Pourquoi ce dernier est-il utile ?  Pense à ceci :

#+begin_src shell :tangle no
$ gm convret -size 120x120 input.png -resize 120x120 -draw "gravity southeast text 0,0 'Dave Neary'" output.jpg
bash: convret: command not found
$ gm convert !*
#+end_src

** Bindings

*** Command line editor
:PROPERTIES:
:header-args+: :tangle .inputrc
:END:

The =.inputrc= file controls the behavior of line input editing for programs that
use the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

See https://code.google.com/p/mintty/wiki/Tips#Readline_configuration.

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .inputrc --- my Readline Init File

# Copyright (C) 2005-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: readline, dotfile, config

# Ignore case while completing.
set completion-ignore-case on

# Allow Meta (Alt) key bindings [line added to the top of my `.inputrc'].
set convert-meta on

# Behave like Emacs when editing.
set editing-mode emacs                  # Ctrl-a/e      Start/End of line.
                                        # Ctrl-f/b      Forward/Backward one character.
                                        # Ctrl-d        Delete one character.
                                        # Ctrl-k        Kill line.
                                        # Ctrl-p/n      Previous/Next command in history.
                                        # Ctrl-r        Search for command in history.
                                        # Ctrl-i/TAB    File name completion.

# Some defaults / modifications for the Emacs mode.
$if mode=emacs

# <C-up/down> for searching matching commands from the history.
"\e[1;5A": history-search-backward
"\e[1;5B": history-search-forward

# <C-left/right> to move by whole words.
"\e[1;5C": forward-word
"\e[1;5D": backward-word

Meta-p: history-search-backward
Meta-n: history-search-forward

$endif

# # Display all alternatives for completion after one tab keypress.
# set show-all-if-ambiguous on

# # Get Bash to display accented characters (Emacs *Meta Key* Problems in XTerm)

# # Don't strip characters to 7 bits when reading.
# set input-meta on
# # (Synonym of 'meta-flag'.)

# # Display characters with the eighth bit set directly rather than as
# # meta-prefixed characters.
# set output-meta on
#+end_src

*** Tab completion

- The programs man and whatis show all installed manual pages as completions.
- The make program uses all targets in the Makefile in the current directory as completions.
- The mount command uses all mount points specified in fstab as completions.
- The ssh command uses all hosts that are stored in the known_hosts file as completions. (See the ssh documentation for more information)
- The su command uses all users on the system as completions.
- The apt-get, rpm and yum commands use all installed packages as completions.

#+begin_src shell
complete -A helptopic help
complete -A hostname ssh telnet nmap ftp ping host traceroute nslookup
#+end_src

*** Getting Help

In the Zsh shell, ~Alt-h~ shows the *manual page* for the current command, if one
exists.  The Zsh way of doing things is much, much nicer than typing the ~man~
command...

Add this functionality to the Bash shell:

#+begin_src shell
bind '"\eh": "\C-a\eb\ed\C-y\e#man \C-y\C-m\C-p\C-p\C-a\C-d\C-e"'
#+end_src

** Ready for more?

#+begin_src shell
# Common configuration.
if [ -f "$HOME"/.shellrc ]; then
    . "$HOME"/.shellrc
fi

# Allow local Bash customizations.
if [ -f "$HOME"/.bashrc_local_after ]; then
    . "$HOME"/.bashrc_local_after
fi

# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_after ]; then
    . "$HOME"/.shellrc_local_after
fi
#+end_src

* Zsh Configuration
:PROPERTIES:
:header-args+: :tangle .zshrc
:END:

Documentation: [[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]].

Examples:
- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)
- [[http://grml.org/zsh/zsh-lovers.html][zsh-lovers]]

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .zshrc --- Zsh configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

# Code:
#+end_src

** Local customizations

#+begin_src shell
# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_before ]; then
    . "$HOME"/.shellrc_local_before
fi

# Allow local Zsh customizations.
if [ -f "$HOME"/.zshrc_local_before ]; then
    . "$HOME"/.zshrc_local_before
fi
#+end_src

** Prompt

#+begin_src shell
# # Don't inherit the value of PS1 from the previous shell (Zsh from Bash).
# PS1=$'%{\e]0;%d\a%}\n%F{grn}%n@%m %F{yel}%d%f\n%# '
#+end_src

Zsh expects that every character in ~PS1~ will advance the cursor one space.  Wrap
any non-printing escape sequences in ~%{...%}~, and it should work. So use
~%{\e[31m%}~, etc.

*************** TODO Define colors using ~terminfo~
See http://superuser.com/questions/239290/how-can-i-make-zsh-show-that-there-are-stashed-revisions-on-a-git-repo-whenever
*************** END

For the prompt, the tricky part was getting the syntax for testing the exit
code.  The syntax is ~%(x.true-string.false-string)~, where ~x~ is some arbitrary
testing condition, in this case, ~?~ for exit codes.  After the first dot, if the
test passes, show ~true-string~; if it fails, show ~false-string~ after the second
dot.

#+begin_src shell
autoload -Uz vcs_info
precmd_vcs_info() { vcs_info }
precmd_functions+=( precmd_vcs_info )
setopt PROMPT_SUBST                     # Allow parameter expansion in prompt.
zstyle ':vcs_info:git:*' formats '%F{6}(%b)%f'
zstyle ':vcs_info:*' enable git
#+end_src

#+begin_src shell
PROMPT="
%B%(?.%F{green}v.%F{red}$(tput bel)%?)%f%b %F{green}%n@%m%F{black}%B:%b%F{yellow}%~ %f\$vcs_info_msg_0_
%F{green}%(!.#.$)%f "
                                        # ? - Exit code of the previous command.
                                        # n - User name.
                                        # m - Machine name.
                                        # . - Abbreviated pwd.
                                        # ! - su?
#+end_src

Insert beep when last command has failed.

#+begin_tip
For portability and readability, we use the ~tput~ command.

But since it's an external command, we run it once to get the bel sequence, and
then stick that sequence in the relevant part of our prompt -- for performance,
to avoid an unnecessary shellout at each prompt evaluation.
#+end_tip

#+begin_src shell
BEL=$(tput bel)
PROMPT+='%(?::$BEL)'
#+end_src

# To get a blank line before the prompt, you can write a function to echo a blank
# line and adding it to your ~preexec~ or ~precmd~ hooks.
#
# Technically, it doesn't insert a line after each commands output, but inserts
# a blank line before building the prompt. However, the end result is the
# same.
#
# #+begin_src shell
# echo_blank() {
#     echo
# }
#
# # preexec_functions+=echo_blank
# precmd_functions+=echo_blank
# #+end_src

Don't confuse TRAMP:

#+begin_src shell
[[ "$TERM" = "dumb" ]] && PROMPT="> "
#+end_src

#+begin_warning
When you invoke the *shell from Emacs*, it is a *non-interactive* session, which
might get different settings.
#+end_warning

*** Right prompt

Don't confuse TRAMP:

#+begin_src shell
[[ "$TERM" = "dumb" ]] && RPROMPT=""
#+end_src

** Add a new theme: Solarized

- [[https://github.com/altercation/solarized/issues/90][How should bold/bright be handled by terminal emulators?]]
- [[https://github.com/mintty/mintty/issues/683][Solarized bold colors are gray]]

Karlin Fox ported the Solarized theme to MinTTY (the terminal which comes by
default with Cygwin), and it is available at [[https://github.com/karlin/mintty-colors-solarized][karlin/mintty-colors-solarized]].

#+begin_src shell :tangle no
git clone https://github.com/karlin/mintty-colors-solarized.git \
    "$HOME"/.dotfiles/plugins/mintty-colors-solarized
#+end_src

#+begin_src shell
FILE="$HOME"/.dotfiles/plugins/mintty-colors-solarized/mintty-solarized-dark.sh && test -f "$FILE" && . "$FILE"

# XXX Check for MinTTY
if [[ -d /cygdrive/c/ ]]; then
    echo -ne '\e]4;8;#404040\a'     # bold blk
    echo -ne '\e]4;9;#FF4040\a'     # bold red
    echo -ne '\e]4;10;#40FF40\a'    # bold grn
    echo -ne '\e]4;11;#FFFF40\a'    # bold yel
    echo -ne '\e]4;12;#6060FF\a'    # bold blu
    echo -ne '\e]4;13;#FF40FF\a'    # bold mag
    echo -ne '\e]4;14;#40FFFF\a'    # bold cyn
    echo -ne '\e]4;15;#FFFFFF\a'    # bold wht
fi
#+end_src

https://github.com/oumu/mintty-color-schemes
https://github.com/mintty/mintty/wiki/Tips
http://mintty.github.io/mintty.1.html#CONFIGURATION
https://stackoverflow.com/questions/24229406/how-to-get-vim-on-cygwin-to-display-right-colors

See great (more portable) stuff at
https://github.com/jimeh/git-aware-prompt/blob/master/colors.sh!

** Install Powerline-patched fonts

*Powerline patched* versions of the most popular mono *fonts* are available at
[[https://github.com/powerline/fonts][powerline/fonts]].

Make sure to change the font of MinTTY:

- Right click the title bar of the Terminal, click Options.
- Change your font to a Powerline patched font you installed.

#+begin_note
If you right-click them, there should be install option in the menu. Or you can
drag it straight to Windows Fonts folder
#+end_note

Test if it's working correctly by running:

#+begin_src shell :tangle no
echo "\ue0b0 \u00b1 \ue0a0 \u27a6 \u2718 \u26a1 \u2699"
#+end_src

Good-looking fonts:
- UbuntuMono
- DejaVuSansMono
- DroidSansMono (bad?)

For Consolas, use: https://github.com/runsisi/consolas-font-for-powerline.

** Install "Oh My Zsh"

Oh My Zsh is just awesome!

#+begin_src shell :tangle no
git clone https://github.com/robbyrussell/oh-my-zsh.git
#+end_src

#+begin_note
We put Oh My Zsh at the very beginning, so that it does not override our own
settings.
#+end_note

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    ZSH="$HOME"/.dotfiles/plugins/oh-my-zsh
    # ${ZSH_CUSTOM:-"$HOME"/.dotfiles/plugins/oh-my-zsh/custom}
    ZSH_CUSTOM="$ZSH/custom"

    HIST_STAMPS="yyyy-mm-dd"            # See command `history'.

    COMPLETION_WAITING_DOTS="true"
fi
#+end_src

http://marc-abramowitz.com/archives/2012/04/10/fix-for-oh-my-zsh-git-svn-prompt-slowness/

** Change the Oh My Zsh theme to "agnoster"

# I am fan of ~agnoster~.
#
# #+begin_src shell
# if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
#     ZSH_THEME="agnoster"
# fi
# #+end_src

*** Agnoster Theme Adaption for SVN

#+begin_src shell
# if [[ -r "$ZSH" ]]; then
#     prompt_svn() {
#         local rev branch
#         if in_svn; then
#             rev=$(svn_get_rev_nr)
#             branch=$(svn_get_branch_name)
#             if [[ $(svn_dirty_choose_pwd 1 0) -eq 1 ]]; then
#                 prompt_segment yel blk
#                 echo -n "$rev@$branch"
#                 echo -n " ±"
#             else
#                 prompt_segment grn blk
#                 echo -n "$rev@$branch"
#             fi
#         fi
#     }
# fi
#+end_src

** Install Zinc (successor of Powerlevel9k!)

#+begin_src shell :tangle no
git clone https://gitlab.com/robobenklein/zinc \
    "$ZSH_CUSTOM"/themes/zinc
#+end_src

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh//custom/themes/zinc/zinc.zsh ]]; then

    ZSH_THEME=""
    source "$ZSH_CUSTOM"/themes/zinc/zinc.zsh

    zinc_default_user="f.niessen"
    zinc_default_host="XIPHIAS"

    # Input your own strftime format: http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
    zincs_time() {
        REPLY="%D{%H:%M}"
    }

    prompt_zinc_setup fniessen-p9k-port

    prompt_zinc_setup rprompt-previous-line

fi

# # either user and host separate with CONNECT_PREV
# # or zincs_userhost
# zinc_left=(
#   # zincs_user
#   # zincs_host
#   zincs_userhost
#   zincs_cwd
#   zincs_vcs
# )
#
# zinc_right=(
#   zincs_retval
#   zincs_execution_time
#   my_custom_time
#   zincs_jobs
# )
#
# zinc_opts=(
#   zincs_user "white;black;CONDITIONAL;normal"
#   zincs_host "white;black;CONNECT_PREV+CONDITIONAL;normal"
#   zincs_userhost "white;black;CONDITIONAL;normal"
# )
#
# # autohide the user when it's default
# zincs_user_display_hidden() {
#   [[ "$USER" == "$zinc_default_user" ]] && true || false
# }
# zincs_host_display_hidden() {
#   [[ "$HOST" == "$zinc_default_host" ]] && true || false
# }
#
# # or show both when either changes:
# zincs_userhost_display_hidden() {
#   [[ "$HOST" == "$zinc_default_host" ]] && [[ "$USER" == "$zinc_default_user" ]] && true
# }
#
# # set the time format option:
# # http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
# my_custom_time() {
#   REPLY="%T"
# }
#
# # set the zincs_execution_time min time:
# zincs_execution_time[threshold]=10
#+end_src

** Plugins

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then

    plugins=(
        colored-man-pages
        extract
        # git                           # Provide many aliases and a few useful functions.
        history
        history-substring-search
        # svn
    )
fi
#+end_src

*** Colored man pages plugin

#+begin_seealso
[[file:~/.minttyrc][.minttyrc]] to *fix colors* and fonts.  See [[http://mintty.googlecode.com/svn-history/r1065/trunk/docs/mintty.1.html][mintty Manual Reference Pages]] for more
information.
#+end_seealso

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    # Fix Colorize man pages (with `less` pager) not working in Cygwin MinTTY
    export MANROFFOPT="-c"
    # in your shell rc file. This has the same effect as
    # export GROFF_NO_SGR=1               # For konsole and gnome-terminal.
    # but only affects man. I'm not sure if groff is used for anything else
    # besides man pages, but this seems safer to prevent unintended side
    # effects.
fi
#+end_src

** Syntax Highlighting

Besides the syntax highlighting for your shell, this plugin has the capability
to verify the correctness of your command.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git \
    "$ZSH_CUSTOM"/plugins/zsh-syntax-highlighting
#+end_src

#+begin_src shell
if [[ -r "$ZSH_CUSTOM/plugins/zsh-syntax-highlighting" ]]; then
    plugins+=(zsh-syntax-highlighting)
fi
#+end_src

** Autosuggestions

Zsh suggests commands based on your command history.

To accept the autosuggestion, hit ~→~ (right arrow) or ~Ctrl-F~.

#+begin_src shell :tangle no
git clone https://github.com/zsh-users/zsh-autosuggestions \
    "$ZSH_CUSTOM"/plugins/zsh-autosuggestions
#+end_src

#+begin_src shell
if [[ -r "$ZSH_CUSTOM/plugins/zsh-autosuggestions" ]]; then
    plugins+=(zsh-autosuggestions)
fi
#+end_src

*** Load Zsh tools

#+begin_src shell
if [[ -r "$HOME"/.dotfiles/plugins/oh-my-zsh ]]; then
    . "$ZSH"/oh-my-zsh.sh
fi
#+end_src

#+begin_src shell
# Autosuggestions.
if [[ -r "$ZSH_CUSTOM/plugins/zsh-autosuggestions" ]]; then
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=5'
fi
#+end_src

** Variables

*** Changing Directories

#+begin_src shell
setopt AUTO_CD                  # Change directory given just path.
#+end_src

*** Completion

Zsh will attempt to complete wildcards by expanding them in the command line.

#+begin_src shell
# Load general completion.
autoload -Uz compinit
# compinit                      # Security check (insecure directories)!
#+end_src

#+begin_src shell
setopt AUTO_LIST                # Automatically list choices on an ambiguous completion.
#+end_src

*** 20. Completion System

#+begin_src shell
# Case-insensitive completion.
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
#+end_src

Launch Windows applications from CLI (with ~start~ script -- see
https://github.com/babun/babun/issues/299#issuecomment-123925935):

#+begin_src shell
# compdef '_files -g "*"' start
#+end_src

*** Expansion and Globbing

#+begin_src shell
setopt EXTENDED_GLOB            # Use additional pattern matching features.
setopt NOMATCH                  # Unmatched patterns cause an error.
#+end_src

*** Job Control

#+begin_src shell
setopt NOTIFY                   # Immediately report changes in background job status.
#+end_src

*** Zle

#+begin_src shell
# Beep when there's an error with the command text you're typing in (e.g. if you
# hit tab and there are no matching files) -- not as a result of normal commands
# returning errors.
setopt BEEP
#+end_src

** History

#+begin_src shell
# History.
setopt APPEND_HISTORY           # Append rather than overwrite history file.
setopt EXTENDED_HISTORY         # Save timestamp and runtime information.
setopt HIST_EXPIRE_DUPS_FIRST   # Allow dups, but expire old ones when I hit HISTSIZE.
setopt HIST_FIND_NO_DUPS        # Don't find duplicates in history.
setopt HIST_IGNORE_ALL_DUPS     #! Ignore duplicate commands regardless of commands in between.
setopt HIST_IGNORE_DUPS         # Ignore duplicate commands.
setopt HIST_REDUCE_BLANKS       # Leave blanks out.
setopt HIST_SAVE_NO_DUPS        # Don't save duplicates.
setopt INC_APPEND_HISTORY       # Write after each command.
setopt SHARE_HISTORY            # Share history between sessions.
#+end_src

#+begin_src shell
HISTSIZE=10000
SAVEHIST=10000
#+end_src

** Bindings

Useful keybindings of the Zsh *command line editor*:

- ~M-q~ ::
     Type another command in the middle of a long command (look at ~man~, etc.):
     you can push the current command to the buffer stack, and after executing
     another command, you can see the top of the stack popped.

- ~M-.~ ::
     Recall the last argument of the previous command, and so on.

- ~C-r~ ::
     Do an interactive search across all of the *command history*.

Useful commands:

- ~vared VAR~ ::
     Interactively edit variable ~VAR~.

#+begin_note
See [[file:~/.dotfiles/plugins/oh-my-zsh/lib/key-bindings.zsh]] for extra key bindings.
#+end_note

#+begin_src shell
# Behave like Emacs when editing.
bindkey -e

# Mappings for `Ctrl-up/down' for matching commands from the history.
bindkey ';5A' history-search-backward
bindkey ';5B' history-search-forward

# Mappings for `Ctrl-left/right' for word moving.
bindkey ';5C' forward-word
bindkey ';5D' backward-word

# Make Zsh beep like Bash when backspacing on an empty command line.
backward-delete-char-beep() {
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep
#+end_src

** Abbreviations

Some global aliases (expand whatever their position).

#+begin_src shell
alias -g 21="2>&1"
alias -g A='| awk'
alias -g BG='& exit'
alias -g C='| cat'
alias -g CA="| cat -A"
alias -g F=' | fmt -' ##
alias -g G='| grep --color=auto -E' ######
alias -g H='| head' ###
alias -g J='| jq -C .'
alias -g L="| less" #######
alias -g L='| less'
alias -g N='> /dev/null'
alias -g NN='> /dev/null 2>&1'
alias -g S='| sort' ###
alias -g T='| tail' ###
alias -g W='| wc -l' ####
alias -g X1='| xargs -n 1'
alias -g X='| xargs'
alias -g XL='| tr "\n" "\0" | xargs -0'
#+end_src

#+begin_src shell
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g ,1="| awk -F, '{print \$1}'"
alias -g ,2="| awk -F, '{print \$2}'"
alias -g ,3="| awk -F, '{print \$3}'"
alias -g ,4="| awk -F, '{print \$4}'"
alias -g ,5="| awk -F, '{print \$5}'"
alias -g ,6="| awk -F, '{print \$6}'"
alias -g ,7="| awk -F, '{print \$7}'"
alias -g ,8="| awk -F, '{print \$8}'"
alias -g ,9="| awk -F, '{print \$9}'"
alias -g :1="| awk -F: '{print \$1}'"
alias -g :2="| awk -F: '{print \$2}'"
alias -g :3="| awk -F: '{print \$3}'"
alias -g :4="| awk -F: '{print \$4}'"
alias -g :5="| awk -F: '{print \$5}'"
alias -g :6="| awk -F: '{print \$6}'"
alias -g :7="| awk -F: '{print \$7}'"
alias -g :8="| awk -F: '{print \$8}'"
alias -g :9="| awk -F: '{print \$9}'"
alias -g T1="| awk -F $'\t' '{print \$1}'"
alias -g T2="| awk -F $'\t' '{print \$2}'"
alias -g T3="| awk -F $'\t' '{print \$3}'"
alias -g T4="| awk -F $'\t' '{print \$4}'"
alias -g T5="| awk -F $'\t' '{print \$5}'"
alias -g T6="| awk -F $'\t' '{print \$6}'"
alias -g T7="| awk -F $'\t' '{print \$7}'"
alias -g T8="| awk -F $'\t' '{print \$8}'"
alias -g T9="| awk -F $'\t' '{print \$9}'"
#+end_src

*** Git

Git this week / month / year:

#+begin_src shell
alias -g GTHISWEEK=' --since=1.week.ago'
alias -g GTHISMONTH=' --since=1.month.ago'
alias -g GTHISYEAR=' --since=1.year.ago'
#+end_src

** Stderr in red

Wrap text that goes to file with descriptor ~2~ with proper ANSI escape codes,
making text red.

#+begin_src shell
# Coloring stderr.
STDERRED_ESC_CODE=$'\e[33;1;41m'
zmodload zsh/system
color_stderr_red() {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    while sysread; do
        syswrite -o 2 "$STDERRED_ESC_CODE$REPLY$terminfo[sgr0]"
    done
}

exec 2> >( color_stderr_red )
#+end_src

** Ready for more?

#+begin_src shell
# Common configuration.
if [ -f "$HOME"/.shellrc ]; then
    . "$HOME"/.shellrc
fi

# Allow local Zsh customizations.
if [ -f "$HOME"/.zshrc_local_after ]; then
    . "$HOME"/.zshrc_local_after
fi

# Allow local Shell customizations.
if [ -f "$HOME"/.shellrc_local_after ]; then
    . "$HOME"/.shellrc_local_after
fi
#+end_src

* Shell agnostic Configuration
:PROPERTIES:
:header-args+: :tangle .shellrc
:END:

=.shellrc= contains miscellaneous settings *common to Bash and Zsh* -- it is read by
both shells.

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .shellrc --- Shell agnostic configuration file

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

#+begin_src shell
uname -s -n -r -m
#+end_src

** Variables

*** umask

#+begin_src shell
# Permissions on newly created files.
umask 022                               # Prevent new dirs and files from being
                                        # group and world writable.
if [[ $EUID -eq 0 ]]; then
    umask 077                           # Stricter.
fi
#+end_src

*** BROWSER

#+begin_src shell
# # For Bash on Ubuntu on Windows.
# export BROWSER='/mnt/c/Windows/explorer.exe' # does not work.
export BROWSER='/mnt/c/Program Files (x86)/Mozilla Firefox/firefox.exe'
#+end_src

*** LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC and LC_TIME

You may need to manually set your language environment (among others, for ~svn~
with accented file names in the repository).

#+begin_src shell
export LANG=C.UTF-8

# For scripts in R language.
export LC_CTYPE=
#+end_src

These variables work as follows:
- LC_ALL forces all the aspects of the locale to the specified value.  If LC_ALL
  is set, all other locale variables will be ignored.
- The other LC_ variables set the specified aspect of the locale information.
- LANG is a fallback value, it will be used if none of the LC_ variables are
  specified.

*** Tool paths

**** Java

- Download Ant and add its =/bin= directory to ~PATH~.

- Add =C:\Program Files\Java\jdk1.8.0_91= to ~JAVA_HOME~ and add ~%JAVA_HOME%/bin~
  to ~PATH~.

** $PATH

*** Search path

Specify the directories that the shell is to look through to find a command.
These directories are searched in the order in which they appear.

The global search ~PATH~ is defined in the file =/etc/environment=.

#+begin_src shell
# Add user paths.
for MAYBE_PATH in "$HOME"/bin \
                  "$HOME"/expect; do
    # `-e' or `-x'?
    if [[ -d "$MAYBE_PATH" ]]; then
        PATH="$MAYBE_PATH":"$PATH"
    fi
done

# Extend the PATH var (where to look for executable files).  For Cygwin only.
if [[ "$OSTYPE" = cygwin* ]]; then
    for MAYBE_CYG_PATH in "$HOME"/.dotfiles/winbin; do
        # `-e' or `-x'?
        if [[ -d "$MAYBE_CYG_PATH" ]]; then
            PATH="$MAYBE_CYG_PATH":"$PATH"
        fi
    done
fi
#+end_src

#+begin_note
~PATH~ should already be marked as exported, so reexporting is not needed.

Run ~export~ to see a list of exported variables (names marked to be passed to
child processes in the environment).

Since ~env~ is an independent executable (=/usr/bin/env=), it only sees the
variables that the shell passes to it, or */exported/ environment variables*
(which are passed on to every executed program).

~set~ on the other hand is a /built-in/ shell command, it also *sees local shell
variables* (which are only accessible from the current shell) -- including shell
functions.
#+end_note

By default, the ~root~ shell does not load commands from the current location.  If
you're ~root~ and if you trust those commands, type ~./whatever-command~ instead.

If you add the ~CWD~ (~.~) to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src shell
# Add the current directory as last component in the search path (not to include
# for `root', for security reasons).
if [[ $EUID -ne 0 ]]; then
    PATH="$PATH":.
fi
#+end_src

*** CDPATH

Much like the ~PATH~ environment variable defines a search order for the
executable you want, ~CDPATH~ provides a selection of directories which will be
checked for the folder you are trying to ~cd~ into.

#+begin_src shell
# Search current directory and home directory.
export CDPATH=.:"$HOME"
#+end_src

*** MANPATH

#+begin_src shell
# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
# if [[ -d "$HOME"/man ]]; then
#     export MANPATH="$HOME/man":"$MANPATH"
# fi

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'
#+end_src

*** INFOPATH

#+begin_src shell
# Info readers (standalone + Emacs Info mode)
INFOPATH=/usr/share/info:"$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
# INFOPATH="$HOME"/texlive/2014/texmf/doc/info:"$INFOPATH"
#+end_src

** EDITOR

Be sure one of these *editors* is *in your search path*!

#+begin_warning
Right now, I have instead hard-coded the path to Emacs in the
[[file:~/bin/emacsclient]] script.
#+end_warning

#+begin_src shell
# Find a suitable editor.
for editor in emacsclientw emacsclient emacs; do
    if command -v "$editor" > /dev/null 2>&1; then
        # Set EDITOR.
        case $editor in
            emacsclient*)
                # # doesn't bother waiting for a response
                # export EDITOR="$editor --no-wait"

                # From the man page for emacsclient(1):
                # If the Emacs server is not running, run `emacs --daemon' to
                # start Emacs in daemon mode, and try to connect to it.
                export EDITOR="$editor --alternate-editor=''"
                ;;
            ,*)
                export EDITOR="$editor"
                ;;
        esac

        alias e='$EDITOR'
        break
    fi
done
#+end_src

#+begin_src shell :tangle no
alias e="emacsclient --alternate-editor=emacs --no-wait" # --no-wait is an essential part.
alias e="emacsclient --tty --alternate-editor=''"
#+end_src

#+begin_src shell
alias ek="emacsclient -e '(kill-emacs)'"
#+end_src

#+begin_note
Shouldn't we alias ~EDITOR~ to ~emacs --tty~?
#+end_note

#+begin_src shell
# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"                 # For `crontab'.
export CVSEDITOR="$EDITOR"
export SVN_EDITOR="$EDITOR"
export EDIT="$EDITOR"
export ERROR_EDITOR="$EDITOR"
export FCEDIT="$EDITOR"                 # For the `fc' (fix command) builtin
                                        # command.
#+end_src

#+begin_src shell
alias em=emacs-minimal
#+end_src

#+begin_src shell
# ec FILE - open FILE in a running Emacs
ec() {
    emacsclient --no-wait "$1"
}
#+end_src

I connect to the server with either a terminal or a GUI client like this:

#+begin_example
alias et=emacsclient --tty              # New GUI frame.
alias ec=emacsclient --create-frame     # New terminal frame.
#+end_example

A good way to start emacsclient is with this line:

#+begin_example
alias e="emacsclient --no-wait --alternate-editor=\"\" --create-frame"
#+end_example

You may also set the environment variables =EDITOR= and/or =VISUAL=, but then you
better omit the "=--no-wait=" option.

** PAGER

Set the user's preferred *text viewer* (~cat~, ~more~, ~less~ or ~most~) that will be used
by programs such as ~man~ or ~git diff~.

#+begin_src shell
export PAGER="less"
#+end_src

With the ~less~ command, you can *scroll up* in the file (with ~b~, backward one
window) as well as *scroll down*; with the archaic ~more~ command, you can only
*scroll down* the file.

#+begin_src shell
alias more='less'
#+end_src

*How to get color man pages?*  Color any command with man-like output, including
~git help~:

#+begin_src shell
export LESS_TERMCAP_mb=$'\e[01;31m'     # Begin bold.
export LESS_TERMCAP_md=$'\e[01;36m'     # Begin blink.
export LESS_TERMCAP_me=$'\e[0m'         # Reset bold/blink.
export LESS_TERMCAP_so=$'\e[01;44;33m'  # Begin reverse video.
export LESS_TERMCAP_se=$'\e[0m'         # Reset reverse video.
export LESS_TERMCAP_us=$'\e[01;32m'     # Begin underline.
export LESS_TERMCAP_ue=$'\e[0m'         # Reset underline.
#+end_src

If you see ~\e[0m~ etc. appearing when you view the man page, add this line as
well:

#+begin_src shell
export LESS='-R'
#+end_src

If you see ~<E9>~ (in reverse video) etc. appearing when you view accents in an
ISO Latin 1 file (in a UTF-8 terminal), add this:

#+begin_src shell
# Format for displaying non-printable, non-control characters (see `man less').
export LESSBINFMT="*n<%02X>"            # Do not use reverse video.
export LESSBINFMT="*d?"                 # Use bold ?.
#+end_src

Commands for *searching*:

- ~/pattern~ :: Search forward for matching line.
- ~?pattern~ :: Search backward for matching line.
- ~n~ :: Repeat previous search.
- ~N~ :: Repeat previous search in reverse direction.
- ~ESC-u~ :: Undo (toggle) search highlighting.
- ~&pattern~ :: Display only matching lines. \\
     If pattern is empty (if you type ~&~ immediately followed by ~RET~), any
     filtering is turned off, and all lines are displayed.

Commands for *jumping*:

- g :: Jump to start (go to *first line* in file).
- G :: Jump to end (go to *last line* in file).

Miscellaneous commands:

- -S :: Toggle chop (*truncate*) *long lines* rather than wrapping.

Options:

#+begin_src shell
export LESS='-F -i -M -R -X'
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'
#+end_src

: export LESS=-i -g -M -R -x4 -X -f -F -z-1
: export PAGER=less LESS='-wiXz-2$j15' LESSBINFMT=.

~less~ options:

- ~-e~ or ~--quit-at-eof~ ::
     Causes ~less~ to automatically *exit the /second/ time it reaches EOF*.  By
     default, the only way to exit ~less~ is via the ~q~ command.

- -f or --force ::
     *Forces non-regular files* to be *opened*.  (A non-regular file is a directory
     or a device special file.)  Also suppresses the warning message when
     a binary file is opened.

- ~-F~ or --quit-if-one-screen ::
     Causes ~less~ to automatically *exit if the entire file can be displayed in
     one screen*. This is usually desirable as there is no incentive to stay in
     ~less~ if a single screen can display all the contents.

     It means you can just pipe any old thing into it, and if it's only a couple
     of lines, you don't have to quit manually.

     #+begin_warning
     After quitting so, the screen is reset and you end up not seeing the
     content; the ~-X~ option does away with that behavior: *don't reinit the
     screen* when the pager exits.  ~-F~ relies on this option to work properly.
     #+end_warning

- -g or --hilite-search ::
     Normally, less will highlight ALL strings which match the last search
     command.  The -g option changes this behavior to *highlight only the
     particular string which was found by the last search command*.  This can
     cause less to run somewhat faster than the default.

- ~-i~ or ~--ignore-case~ ::
     Causes *searches* to *ignore case*; that is, uppercase and lowercase are
     considered identical.  This option is /ignored if any uppercase letters
     appear in the search pattern/; in other words, if a pattern contains
     uppercase letters, then that search does not ignore case.

- -J or --status-column ::
     Displays a status column at the left edge of the screen.  The status column
     indicates the *lines that matched the current search*, and the first unread
     line after moving a full page (if the -w or -W option is in effect).

- ~-m~ or ~--long-prompt~ ::
     Causes less to prompt verbosely (like ~more~), with the percent into the
     file.  By default, ~less~ prompts with a colon.

- ~-M~ or ~--LONG-PROMPT~ ::
     Causes ~less~ to *prompt* even *more verbosely* than ~more~.

- ~-r~ or ~--raw-control-chars~ ::
     Causes "raw" control characters to be displayed.  The default is to display
     control characters using the caret notation; for example, a ~control-A~
     (octal ~001~) is displayed as ~^A~.

     #+begin_warning
     When the ~-r~ option is used, ~less~ cannot keep track of the actual appearance
     of the screen (since this depends on how the screen responds to each type
     of control character).  Thus, various display problems may result, such as
     long lines being split in the wrong place.
     #+end_warning

- ~-R~ or ~--RAW-CONTROL-CHARS~ ::
     (Only) ANSI *"color" escape sequences* (sequences of the form ~ESC[...m~ where
     the ~...~ is zero or more color specification characters, and ~m~ ends ANSI
     color escape sequences) are *output in "raw" form*.

     #+begin_note
     Without ~--RAW-CONTROL-CHARS~ (or ~--raw-control-chars~), ~less~ outputs the
     colors as raw escape codes; that is, it does not interpret colors. With
     that option, ~git diff~ finally *displays colors*...

     In other words, I definitely recommend ~-R~ if you don't enjoy periodic
     symbol junk terminal confusion.
     #+end_note

- -w or --hilite-unread ::
     Temporarily highlights the first "new" line after a forward movement of
     a full page.  The first "new" line is the line immediately following the
     line previously at the bottom of the screen.  Also highlights the target
     line after a g or p command.  The highlight is removed at the next command
     which causes movement.  The entire line is highlighted, unless the -J
     option is in effect, in which case only the status column is high- lighted.

- -W or --HILITE-UNREAD ::
     Like -w, but temporarily *highlights the first unread line* after any
     scrolling larger than one line.

- -x4 or --tabs=4 ::
     Sets tab stops at multiples of 4, since most modern text files assume
     4-character width for a tab.. The default is 8.

- ~-X~ or ~--no-init~ ::
     *Disables* sending the termcap initialization and deinitialization strings to
     the terminal.  This is sometimes desirable if the deinitialization string
     does something unnecessary, like *clearing the screen*.

     #+begin_note
     If you want that ~less~ does not *clear the terminal* when quitting, use the ~-X~
     option.
     #+end_note

- -z-4 or --window=-4 ::
     Changes the default scrolling window size to *4 lines less than the current
     screen size*, so always keep 4 lines overlapping with previous screen when
     scrolling with the space key.

** DISPLAY
:PROPERTIES:
:ID:       02ba0b6b-f205-42e2-a801-4271aa4691eb
:END:

#+begin_src shell
# Start x11 server (if a process instance is not already running).
# ps -ae | grep XWin || startxwin > /dev/null 2>&1 &   # XXX For Cygwin only!
# To check that have the package xinit installed, try 'startxwin' without redirecting anything.

# Set DISPLAY environment variable.
export DISPLAY=:0.0
#+end_src

** Abbreviations

An *alias* is a simple string substitution.

#+begin_note
By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).
#+end_note

In general, it should not do more than *change the default options of a command*.

Aliases are abbreviations or alternative names (usually mnemonics) for commands.
They are commonly used to specify a few options to commands, and then include
the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like ~$1~.

#+begin_note
Single quotes are evaluated dynamically:
: alias qs='echo $PWD'

Double quotes are evaluated at time of creation and, thereafter, never changes:
: alias qd="echo $PWD"
#+end_note

*** History

Print the history lines matching a pattern.

#+begin_src shell
alias hgrep='history | grep -i'
#+end_src

#+begin_tip
We can't call this alias ~hg~ as that conflicts with the Mercurial prompt of the
Agnoster theme (checking for the presence of the ~hg~ command).
#+end_tip

*** Common aliases

#+begin_src shell
alias which-shell='ps -p $$'
#+end_src

~ls~ options:

- ~-a~ ::
     Do not ignore entries starting with ~.~.

- ~-C~ ::
     List entries by *columns*.

- ~-F~ ::
     Append indicator (one of ~*/=>@|~) to entries.

- ~-g~ ::
     Like ~-l~, but do not list owner.

- ~--group-directories-first~ ::
     Group directories before files.

- ~-G~ ::
     In a long listing, don't print *group* names.

- ~-h~ ::
     With ~-l~ and/or ~-s~, print *human readable* sizes (e.g., ~1K~ ~234M~ ~2G~).

- ~-l~ ::
     Use a *long* listing format.

- ~-s~ ::
     Print the allocated *size* of each file, in blocks.

#+begin_src shell
LS_OPTIONS="$LS_OPTIONS --show-control-chars"

# Make `ls' produce ISO 8601 format.
export TIME_STYLE=long-iso

# Enable color support of `ls'.
if [[ "$TERM" != "dumb" ]]; then

    # Add my coloration scheme to directory listings.
    if [[ -f "$HOME"/.dircolors ]]; then
        eval "$(dircolors -b $HOME/.dircolors)"
        # See https://github.com/seebi/dircolors-solarized.
    else
        eval "$(dircolors -b)"
    fi

    alias ls='ls --color=auto -F'
    alias ll='ls --color=auto -a --group-directories-first -G -h -l'
                                        # Long listing and hidden files.
else
    alias ls='ls -CF'
fi
#+end_src

*************** TODO Beautify the terminal's ls command, with color and font-awesome icons
https://github.com/athityakumar/colorls
*************** END

Sort of tree:

#+begin_src shell
alias dirf='find . -type d | sed -e "s/[^-][^\/]*\//  |/g" -e "s/|\([^ ]\)/|-\1/"'
#+end_src

~df~ options:

- ~-h~ ::
     Print sizes in powers of 1024 (e.g., ~1023M~).

- ~-k~ ::
     Like ~--block-size=1K~.

- ~-T~ ::
     Print file system type.

Make ~df~ human readable.

#+begin_src shell
alias df='df -kTh'
#+end_src

Make ~du~ human readable.

#+begin_src shell
alias du='du -kh'

alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'         # Ordered by size.
#+end_src

#+begin_src shell
alias mount='mount | column -t'
#+end_src

List all the files in this directory, and sort by human-readable file size.

#+begin_src shell
alias sizes="du --max-depth=1 -k | sort -nr | cut -f2 | xargs -d '\n' du -sh"
#+end_src

#+begin_src shell
# Play safe!  Prevent some accidental mistakes.
alias rm='rm -i'                        # Confirm removing file.
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.
#+end_src

#+begin_note
The above aliases *alter* the *original* meaning of existing commands -- that
scripts don't expect to see modified!
#+end_note

#+begin_src shell
# Make an extract function!
alias tgz='tar -zxvf'
alias tbz2='tar -jxvf'
#+end_src

Interesting alias in Oh My Zsh: ~x~ / ~extract~ to extract an archive of types
tar.{bz2,gz,xz,lzma}, bz2, rar, gz, tbz2, tgz, zip, Z, 7z.

#+begin_src shell
# Print a more readable PATH (each directory on a new line).
alias path='echo "$PATH" | sed -e "s/:/\n/g"'
alias path='sed "s/:/\n/g" <<< "$PATH"' # here-strings (undefined in POSIX sh).
alias path='tr ":" "\n" <<< "$PATH"'    # here-strings.
alias path='echo -e "${PATH//:/\\n}"'   # Parameter expansion (string replacement undefined in POSIX sh/dash).
# https://ubuntuplace.info/questions/4532/comment-afficher-les-chemins-dans-path-separement

# Path.
alias where='type -a'                   # Good?
#+end_src

#+begin_src shell
alias mkall='./configure && make && sudo make install'
#+end_src

#+begin_src shell
# Using sudo with an alias.
alias sudo='sudo '

# Become root.
alias root='sudo -i'
#+end_src

#+begin_src shell
# Make executable.
alias exe='chmod +x'
alias addx='chmod +x'

# Chown current dir and subdirs.
alias own='sudo chown -R $USER'
#+end_src

*** Directories

#+begin_src shell
alias -- ..='cd ..'

alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# Aliases '-' to 'cd -'.
alias -- -='cd -'
#+end_src

#+begin_src shell
# # For WSL.
# alias c:='cd /mnt/c'
# alias d:='cd /mnt/d'
#
# # For Cygwin.
# alias c:='cd /cygdrive/c'
# alias d:='cd /cygdrive/d'
#+end_src

#+begin_src shell
# list last used directories (directory history).
alias d='dirs -v'
#+end_src

Normally, you can use ~cd +1~ to go to the previous directory and so on.
Oh My Zsh made this even more straightforward, now you can use just the number
of the entry in the directory history you want to visit... ~1~.

*** Shortcuts (single char for some commands)

#+begin_src shell
alias c='clear'
alias j='jobs -l'
alias l='ls'                            # xx
alias m='man'
# alias p='$PAGER'
alias q='exit'
alias s='sudo'
alias t='tail -f'
# alias x='exit' # Conflict with extract (from Oh-my-Zsh?)
#+end_src

*** Colorize diff output

*Highlight SVN diffs in the Shell (in Cygwin)???*

#+begin_src shell
# Make `diff' automatically call `colordiff' (Install `colordiff' package...).
alias diff='colordiff'
#+end_src

*** Git

#+begin_src shell
alias g='git'
#+end_src

Go to the top of your Git repo.

#+begin_src shell
# alias gitroot='cd $(git rev-parse --show-toplevel)' # Conflict with Oh My Zsh?

# Good alias that will not blow up cd if you aren't in a Git directory.
alias cdroot='git rev-parse && cd "$(git rev-parse --show-toplevel)"'
#+end_src

http://jonas.nitro.dk/tig/manual.html

#+begin_src shell
alias tigs='tig status'                 # Use it all of the time!
alias tigb='tig blame'
alias tigall='tig --all'
alias tigreleases='tig --all --simplify-by-decoration'
#+end_src

http://stackoverflow.com/tags/tig/hot

*** TODO Color lines in shell (GRC, Supercat, Highlight, etc.)

http://stackoverflow.com/questions/4267400/colour-highlighting-output-based-on-regex-in-shell

highlight-lines-matching-regexp "ERROR"

*** UTF-8 BOM

Remove the UTF-8 encoded BOM if it exists (make no changes if it doesn't).

#+begin_src shell
alias remove-bom='sed -i "1s/^\xEF\xBB\xBF//"'
#+end_src

*** Screen

Connect to a host in a new screen tab, with the device name as the tab title.

#+begin_src shell :tangle no
s() {
    screen -t "$@" /usr/bin/ssh "$@"
}

alias screen='screen -U'
alias resume='screen -D -R'
alias sr='screen -r'
#+end_src

*** SSH agent / GPG agent
:PROPERTIES:
:header-args+: :tangle no
:END:

Most of our servers don't listen to SSH on a public VLAN. I can't be bothered to
keep a tunnel open on my laptop when away from the office:

#+begin_src shell
zugzug() {
    ssh -A -p <non_standard_port> -t <proxy_server> ssh "$1"
}
#+end_src

While it's a function and not an alias, I find it invaluable.

#+begin_src shell
alias keyon='ssh-add -t 10800'          # Add identity.
alias keyoff='ssh-add -D'               # Remove all identities.
alias keylist='ssh-add -l'              # List all identities.
#+end_src

#+begin_src shell
# gpg.
searchkey() {
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@"
}
#+end_src

#+begin_src shell
# Get gpg-key from keyserver.
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'
#+end_src

*** Debian
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
alias aps='aptitude search'
#+end_src

*** System admin (NMAP, etc.)
:PROPERTIES:
:header-args+: :tangle no
:END:

#+begin_src shell
# Use `pkill' (which is pgrep + kill in a single command).

# Show only my processes.
alias mytop='top -u $USERNAME'
#+end_src

#+begin_src shell
# My traceroute.
have mtr && alias ping=mtr

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 Compare /proc with ps (against rootkits).
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# # 040210 Grep.
# alias g='find . -type f -print0 | xargs -0 grep'
alias rgrep="grep -r"
#+end_src

#+begin_src shell
# Echo my current external IP address.
have curl && alias whatismyip='curl -s http://whatismyip.org'
#+end_src

#+begin_src shell
alias externalip='wget http://ipinfo.io/ip -qO -'
alias internalip='ipconfig getifaddr en0'

# Get your external IP address.
# curl ifconfig.me

# Get internal IP address.
alias ip='ipconfig getifaddr en0 || ipconfig getifaddr en1'

alias wanip='dig +short myip.opendns.com @resolver1.opendns.com'
#+end_src

#+begin_src shell
alias docker-rm-all='sudo docker ps -a | awk "NR > 1{print \$1}" | xargs sudo docker rm'

alias dk='docker'
alias dkc='docker-compose'
alias dkm='docker-machine'

alias dk-ips="docker ps -q | xargs -n 1 docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}} {{ .Name }}' | sed 's/ \//\t/'"
alias dk-clean='docker-clean'
#+end_src

#+begin_src shell
# 040319 Send files via `netcat'.
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/} | nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'
#+end_src

#+begin_src shell
# Sharing file through http 80 port.
# From the other machine open a web navigator and go to ip from the machine who
# launch netcat, http://ip-address/ If you have some web server listening at 80
# port then you would need stop them or select another port before launch net
# cat ;-) * You need netcat tool installed
# nc -v -l 80 < file.ext
#+end_src

#+begin_src shell
# Honor embedded linefeeds when displaying packets.
alias ngrep='ngrep -W byline'

# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23

alias sniff='sudo ngrep -d "en0" -t "^(GET|POST) " "tcp and port 80"'

alias httpdump="sudo tcpdump -i en0 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""
#+end_src

#+begin_src shell
ipf() {
    curl -H 'Accept: application/json' "ipinfo.io/$1" | jq .
}

for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
  alias "$method"="curl -X '$method'"
done

# Run `dig` and display the most useful info
digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}
#+end_src

#+begin_src shell
alias ports='netstat -alpe --ip'

# Open ports.
alias ports='netstat -tulanp'
alias ports='netstat -tulap'

alias openports='netstat -nape --inet'

# Scan all open/listening ports.
# sudo nmap -n -PN -sT -sU -p- localhost
#+end_src

#+begin_src shell
# alias scan='nmap -sS -O'
alias nm='nmap -sS -O -PI -PT'
alias portscan='nmap -sT -PT -R '
alias nmap_fast='nmap -F -T5 --top-ports 300'
#+end_src

#+begin_src shell
# nmap() {
#     echo "Enter port #"
#     read port
#     echo "Enter IP range"
#     read range
#     sudo nmap -sT -p $port -P0 -v -T 4 -oG dump-$port-${range////_}.txt $range
#     grep -i open dump-$port-${range////_}.txt
# }
#+end_src

#+begin_src shell :tangle no
have nmap && {
    # -- [ nmap ] ---------------------------------------------------
    #  -sS - TCP SYN scan
    #  -v - verbose
    #  -T1 - timing of scan. Options are paranoid (0), sneaky (1), polite (2), normal (3), aggressive (4), and insane (5)
    #  -sF - FIN scan (can sneak through non-stateful firewalls)
    #  -PE - ICMP echo discovery probe
    #  -PP - timestamp discovery probe
    #  -PY - SCTP init ping
    #  -g - use given number as source port
    #  -A - enable OS detection, version detection, script scanning, and traceroute (aggressive)
    #  -O - enable OS detection
    #  -sA - TCP ACK scan
    #  -F - fast scan
    #  --script=vulscan - also access vulnerabilities in target
    alias nmap_open_ports='nmap --open'
    alias nmap_list_interfaces='nmap --iflist'
    alias nmap_slow='nmap -sS -v -T1'
    alias nmap_fin='nmap -sF -v'
    alias nmap_full='nmap -sS -T4 -PE -PP -PS80,443 -PY -g 53 -A -p1-65535 -v'
    alias nmap_check_for_firewall='nmap -sA -p1-65535 -v -T4'
    alias nmap_ping_through_firewall="nmap -PS -PA"
    alias nmap_fast="nmap -F -T5 --version-light --top-ports 300"
    alias nmap_detect_versions="nmap -sV -p1-65535 -O --osscan-guess -T4 -Pn"
    alias nmap_check_for_vulns="nmap --script=vulscan"
    alias nmap_full_udp="nmap -sS -sU -T4 -A -v -PE -PS22,25,80 -PA21,23,80,443,3389 "
    alias nmap_traceroute="nmap -sP -PE -PS22,25,80 -PA21,23,80,3389 -PU -PO --traceroute "
    alias nmap_full_with_scripts="sudo nmap -sS -sU -T4 -A -v -PE -PP -PS21,22,23,25,80,113,31339 -PA80,113,443,10042 -PO --script all "
    alias nmap_web_safe_osscan="sudo nmap -p 80,443 -O -v --osscan-guess --fuzzy "
}
#+end_src

#+begin_src shell
# localnet - Find the local network in CIDR notation.
localnet() {
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}

# whoisonline [TARGET] - List hosts that are online.
whoisonline() {
    local net
    if [[ -n "$1" ]]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Discovering online hosts in $net..."
    sudo nmap -sP $net | awk '/Host / && / up/ { print $0; }'
}

# localps [TARGET] - List open ports on hosts that are online.
localps() {
    local hostip
    local t1
    local t2
    local t3

    local net
    if [[ -n "$1" ]]; then
        net="$1"
    else
        net=$(localnet)
    fi

    for hostip in $(nmap -sP $net | grep -E 'Host .* up' | cut -d " " -f2-2); do
        t1=$(ping -c 4 $hostip | grep -e PING | cut -d " " -f1-2 | cut -d " " -f2-4)
        t2=$(ping -c 4 $hostip | grep -e rtt | cut -d "/" -f5-5)
        t3=$(sudo nmap -sS $hostip | grep " open ")
        echo -e $t1 " " $t2 "ms\n" $t3 "\n"
    done
}

# watchport HOST PORT - Watch TCP port PORT on machine HOST.
watchport() {
    while true; do
        clear
        nmap "$1" -PN -p "$2"
        sleep 5
    done
}

# rdns [TARGET] - Perform reverse DNS lookups.
rdns() {
    local net
    if [[ -n "$1" ]]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Performing reverse DNS lookups in $net..."
    nmap -R -sL $net |\
    awk '{if ($3 != "not") print "Host " $3 " is " $2}' | grep '('
    # You could add "--dns-servers x.x.x.x" after the "-sL" if you need the
    # lookups to be performed on a specific DNS server.
}
#+end_src

#+begin_src shell
# Resume getting a partially-downloaded file.
alias wget='wget -c'

# Anonymous wget (using Privoxy and Tor).
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror='wget -v --tries=0 --continue --force-directories --mirror --no-parent'

alias download_web_site='wget --random-wait -r -p -e robots=off -U mozilla'
#+end_src

#+begin_src shell
# Pöwer off.
alias off='sudo /sbin/shutdown -h now'
#+end_src

*** Org

#+begin_src shell
org_test() {
    (
        cd "$HOME"/Public/Repositories/org-mode
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest \
            emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

*** Grep

#+begin_note
~GREP_OPTIONS~ causes problems because it *applies in scripts* that may be relying
on the exact set of options that they pass to ~grep~; it's even officially
*deprecated* since ~grep~ 2.21.  It is better to make ~grep~ itself an alias (and also
~egrep~ and ~fgrep~ if you use them).
#+end_note

#+begin_src shell
# Display the matched pattern in color.
alias grep='grep --color=auto'
alias egrep='grep -E --color=auto'
alias fgrep='grep -F --color=auto'
#+end_src

#+begin_warning
If you use ~--color=always~, it'll use color even when piping, which confuses
things.
#+end_warning

Change the color of ~grep~:

#+begin_src shell
# export GREP_COLOR='0;33;1;44'         # Bold Yellow on blue.
export GREP_COLORS="sl=:cx=:mt=01;33;1;44:ms=01;33;1;44:mc=01;33;1;44:fn=35:ln=32:bn=32:se=36"
#+end_src

- sl :: *Matching Lines* ("selected" lines)
- cx :: Context Lines
- mt :: *Matching Text*
- ms ::
- mc ::
- fn :: File Name
- ln :: Line Number
- bn :: Byte Number
- se :: Separator

Paste in a GREP_COLORS string to preview it.
Tweak the style the way you want, with a live preview of how it'll look!
See https://dom.hastin.gs/files/grep-colors/

#+begin_note
The colors are defined by the environment variable ~GREP_COLORS~ (used in ~grep~
2.5.2 and later versions). The *deprecated* environment variable ~GREP_COLOR~ (used
in ~grep~ 2.5.1) is still supported, but its setting does not have priority.

But apparently, this is not the case on my system. ~GREP_COLOR~ is the one that
works?  (... That's when there is no mt specification in the GREP_COLORS env
var...)
#+end_note

#+begin_src shell
# Grep through the running processes.
alias pgrep='pgrep -fl'
alias 'ps?'='ps ax | grep '
#+end_src

*** Ripgrep

#+begin_src shell
alias rg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold'"
alias srg="rg --colors 'match:bg:yellow' --colors 'match:fg:black' --colors 'match:style:bold' --sort-files"
#+end_src

*** Ag, the Silver Searcher

[[https://blog.kowalczyk.info/software/the-silver-searcher-for-windows.html][The Silver Searcher windows port]]

#+begin_src shell :tangle no
have ag && alias grep=ag
#+end_src

*** GraphicsMagick

See also https://image.online-convert.com/fr...

#+begin_src shell
# GraphicsMagick.
alias GIF='gm convert -verbose -interlace LINE'
alias thumb='gm convert -geometry 100x100 -interlace LINE -verbose'
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize() {
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES; do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # Obscure but useful string operations.
        # (See http://www.arachnoid.com/linux/shell_programming.html.)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

*** Other things to sort

#+begin_src shell
export GS_OPTIONS='-sPAPERSIZE=a4'
alias pdfmerge='gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./pdf-joined.pdf' # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

#+begin_src shell
# clean [-r] - Remove useless files (recursively).
clean() {
    if [[ "$1" = "-r" ]]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" \
             -o -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" \
             -o -name "*.~BASE~" -o -name ".*.~BASE~" \) \
             -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}
#+end_src

#+begin_src shell
# swap FILE1 FILE2 - Swap FILE1 and FILE2.
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap() {
    if [[ $# != 2 ]]; then
        return 2
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f "$1" $tmpfile
    mv -f "$2" "$1"
    mv -f $tmpfile "$2"
    return 0
}
#+end_src

#+begin_src shell
saneperms() {
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod "${1:=644}"
}
#+end_src

#+begin_src shell
# # Search for various types or README file in dir and display them in $PAGER.
# readme() {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }
#+end_src

#+begin_src shell
safetmp() {
    test -d "$HOME" || exit 1
    test -d "$HOME"/tmp || mkdir "$HOME"/tmp
    echo "$HOME/tmp/safetmp.$(hostname).$(date +%s).$$"
}
#+end_src

#+begin_src shell
# Immediately opens the first match.
texman() {
    locate "$*" | grep pdf | grep texlive | head -1 | xargs open
}

texlist() {
    locate "$*" | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)"
}
#+end_src

*** Extra

#+begin_src shell :tangle no
console() {
    if [[ $# > 0 ]]; then
        query=$(echo "$*" | tr -s ' ' '|')
        tail -f /var/log/system.log | grep -i --color=auto -E "$query"
    else
        tail -f /var/log/system.log
    fi
}
#+end_src

*** Alert

Add an "alert" alias for *long running commands*.

#+begin_src shell
alert() {
    $@
    echo -e "\a"                        # Beep.
}
#+end_src

#+begin_src shell
alias alert='notify-send --urgency=low -i "$([[ $? = 0 ]] && echo terminal || echo error)" "$(history | tail -n1 | sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

Use like so:

: sleep 10; alert

** Directories

#+begin_src shell
# When entering a directory, list the contents.
cd() {
    builtin cd "$@" && ls --color=auto -F
}
#+end_src

* Getting started

** Prerequisites for Windows

Install [[https://www.cygwin.com/][Cygwin]] (http://mirrors.kernel.org).

*** ~PATH~

After Cygwin is installed, modify the System ~PATH~ variable: prepend it with
=C:\cygwin64\bin= (before ~%SystemRoot%\system32~).

#+begin_warning
If you add other directories (such as =~/bin= or =~/winbin=) in the ~PATH~ before
Cygwin, please check that those directories don't contain =cygwin1.dll= or
such. That was why I had troubles running ~git~ commands...
#+end_warning

In =c:/cygwin64/etc/profile=,

- =/usr/local/bin= is appended to the ~PATH~!!

  And, except when root, it is almost always wrong to have =/usr/local/bin= after
  any system path.

- ~TZ~ (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from =c:/cygwin/Cygwin.bat=!!

*** HOME, the user's home directory

Add an ~HOME~ environment variable (with no trailing backslash!).

Programs like ~ssh~ don't rely on your environment variable ~HOME~ for the location
of your *home directory*.

Starting with Cygwin 1.7.34, the recommended way to do this is to add a custom
~db_home~ setting (comment the example line) to =/etc/nsswitch.conf=.

#+begin_note
If you installed Cygwin prior to 1.7.34 or have run its ~mkpasswd~ utility so that
you have an =/etc/passwd= file, you can change your Cygwin ~HOME~ directory by
editing your user's entry in that file. Your ~HOME~ directory is the penultimate
element on your user's line in =/etc/passwd= (the ~HOME~ environment variable is set
from that field).
#+end_note

*** Packages

*************** TODO See http://www.4thinker.com/cygwin-setup.html
*************** END

[[http://cygwin.com/cgi-bin2/package-grep.cgi][Cygwin Package Search]]

In order to *install Cygwin's packages* through the terminal instead of running
the setup every single time you need one, you can install ~apt-cyg~.  As
a requirement, you'll need to install ~lynx~ through the cygwin setup first.
After that, just run the following commands:

#+begin_src shell
lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg > apt-cyg
install apt-cyg /bin
#+end_src

- Archive
  + [X] ~unzip~
  + [X] ~zip~ (used by the "Org to ODT" exporter)

- Database
  + [X] ~freetds~ (for ~tsql~)

- Devel
  + [ ] ~autoconf~
  + [ ] ~bzr~
  + [ ] ~ctags~ (Exuberant Ctags)
  + [ ] ~gcc-core~ (C compiler)
  + [ ] ~gcc4~ (needed for installing some Perl packages, for CSV2Ledger)
  + [X] ~gdb~
  + [X] ~git~
  + [X] ~make~ (for making info for Git Org mode)
  + [X] ~meld~ (for diffing -- requires ~xinit~)
  + [ ] ~mercurial~ (for ~hg~ command, used by Beamer)
  + [X] ~patch~
  + [X] ~patchutils~
  + [X] ~subversion~ (for ~svn~ command)

- Editors
  + [X] ~emacs~
  + [X] ~emacs-el~ (needed to get more up-to-date sources, such as for Org)
  + [X] ~emacs-w32~ (for graphical Cygwin Emacs with the w32 graphics toolkit)

- Graphics
  + [X] ~ghostscript~ (needed by various utilities -- ~texlive~ for example)
  + [ ] ~gnuplot~
  + [X] ~graphviz~ (~dot~)
  + [X] ~poppler~ (for ~pdftotext~)

- Interpreters
  + [ ] ~m4~

- Libs
  + [ ] ~libbz2-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiconv~
  + [ ] ~libicu-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiodbc-devel~ (needed for installing RODBC inside R)

- Math
  + [X] ~R~

- Net
  + [X] ~bind-utils~ (for ~dig~, ~host~, ~nslookup~, etc.)
  + [X] ~curl~
  + [X] ~inetutils~ (for getting ~telnet~ to work with expect)
  + [ ] ~nc~ (see socat)
  + [ ] ~openssh~
  + [ ] ~ping~ (Note: Allow to "Run this program as an administrator")
  + [ ] ~rsync~
  + [X] ~sitecopy~
  + [ ] ~socat~ (see ~nc~)

- Perl
  + [ ] ~perl~

- Publishing
  + [X] ~texlive~ (= TeX only, not LaTeX!  It requires ~fontconfig~ and ~ghostscript~)
  + [X] ~texlive-collection-binextra~ (for ~latexmk~)
  + [X] ~texlive-collection-fontsextra~ (for =libertine.sty=)
  + [X] ~texlive-collection-fontsrecommended~ (for =marvosym.sty=, etc.)
  + [X] ~texlive-collection-genericrecommended~ (for =ulem.sty=, etc.)
  + [X] ~texlive-collection-langfrench~ (for ~frenchb~)
  + [X] ~texlive-collection-latex~
  + [X] ~texlive-collection-latexextra~ (for =draftwatermark.sty=, etc.)
  + [X] ~texlive-collection-science~ (for =siunitx.sty=, etc.)

- Python
  + [X] ~python~

- Ruby
  + [ ] ~ruby~

- Shells
  + [ ] ~rxvt~
  + [X] ~zsh~

- System
  + [X] ~procps-ng~ (to get ~top~ and ~pkill~)
  + [ ] ~psmisc~ (to get ~killall~)

- Tcl
  + [ ] ~expect~

- Text
  + [ ] ~antiword~
  + [X] ~aspell~ (Note that the Win32 binary has *much* more dictionaries! Use that
    one instead if you need "nl" language...)
  + [ ] ~jq~ (for displaying JSON)
  + [ ] ~most~
  + [ ] ~opensp~ (for ~nsgmls~ validator)
  + [X] ~texinfo~ (for ~makeinfo~)
  + [ ] ~tidy~

- Utils
  + [X] ~colordiff~ (for ~svn~)
  + [ ] ~dos2unix~
  + [ ] ~fdupes~
  + [ ] ~file~ to determine file type
  + [ ] ~flog~ (logger, to syslog)
  + [X] ~gnupg~ (for ~gpg~) -- requiring ~libusb0~ (though you don't need to install
    the Win32 driver which is adviced!)
  + [X] ~moreutils~ (provides ~sponge~)
  + [X] ~ncurses~ (provides ~tput~ and the ~clear~ command used by the TeX Live
    installer, though you can use ~C-l~ to get the same result)
  + [ ] ~screen~
  + [ ] ~sgrep~ (installs the XPath command ~xmllint~, with ~libxml2~)
  + [X] ~the_silver_searcher~ (ag)
  + [X] ~tig~ (Git browser)
  + [X] ~xmlstarlet~

- X11
  + [ ] ~fontconfig~ (needed by XeTeX)
  + [X] ~xinit~ (needed by ~meld~)
    See [[id:02ba0b6b-f205-42e2-a801-4271aa4691eb][Display]].

- Web
  + [ ] ~wget~

Many Unix commands have already newer and more feature-rich
replacements:

- df :: pydf
- less :: most
- tail :: multitail
- top :: htop
- tracepath :: mtr
- traceroute :: mtr

*** Terminal emulators

For a better Emacs experience than with the Cygwin console, use:

- MinTTY
- (u)rxvt
- xterm

#+begin_tip
*~Alt-F2~ opens a new terminal window*

*~Shift-PageUp~ and ~Shift-PageDown~!*

For rapidly paging through previous lines of output, you can press ~Shift-PageUp~
and ~Shift-PageDown~, just like the Linux console.

*Searching text in scrollback buffer (in Cygwin MinTTY)*

In mintty, ~Alt-F3~ opens a search bar with an input field for a search string.
Matches are highlighted in the scrollback buffer.  ~Enter~ / ~Shift+Enter~ find the
~next~ / ~previous~ position of the match and scrolls the scrollback buffer
accordingly.  The appearance of the search bar and the matching highlight
colours can be customized.

See [[https://mintty.github.io/mintty.1.html][man page]].
#+end_tip

*** Terminal types

- ~dumb~
- ~cygwin~
- ~emacs~
- ~screen~
- ~xterm~
- ~xterm-256color~
- ~eterm-color~

Set the *terminal type* explicitly to get a nice *256 color* palette (instead of the
ugly default 8 colors):

#+begin_src shell :tangle no
export TERM=xterm-256color
#+end_src

#+begin_tip
In fact, we are advised to *NOT* set ~TERM~ variable in dotfiles that are related to
the *shell*, as opposed to dotfiles related to the *terminal emulator* program.
This is because a shell may be used with multiple terminal emulators, and
setting ~TERM~ there is obviously a misplacement mistake, an all too common one...
The proper place to override the ~TERM~ value is in a terminal emulator dotfile,
something like =~/.minttyrc=.
#+end_tip

Initialize the terminal according to the type of terminal in the environmental
variable ~TERM~.

#+begin_src shell
# tput init                             # This resets the Solarized color theme!!!
#+end_src

#+begin_note
This command should be included in everyone's =.profile= after the environmental
variable ~TERM~ has been exported.
#+end_note

#+begin_seealso
Use the script ~colortest~ (on Linux distros) to output the default colors.
#+end_seealso

See what your color palet is for the terminal session:

#+begin_src shell :tangle no
tput colors
#+end_src

*** GnuPG

When first running ~gpg~:

- Directory =~/.gnupg= created
- New configuration file =~/.gnupg/gpg.conf= created
- Keyring =~/.gnupg/secring.gpg= created
- Keyring =~/.gnupg/pubring.gpg= created

*** Suppress the Cygwin DOS path warning

When first running ~M-x ediff-buffers~, I got this Cygwin warning:

#+begin_example
MS-DOS style path detected: c:/Users/...
Preferred POSIX equivalent is: /cygdrive/c/Users/...
CYGWIN environment variable option "nodosfilewarning" turns off this warning.
Consult the user's guide for more details about POSIX paths:
  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
#+end_example

Though, setting it in =.bashrc= or something like that does not work. A good
place to set it is in the global *Windows environment variables*.

** TODO Basic installation (OBSOLETE)

Shell-Leuven is installed by doing the following:

1. *Clone the repository:*

   #+begin_src shell
   git clone git@github.com:fniessen/dotfiles.git ~/.dotfiles
   ~/.dotfiles/install
   #+end_src

2. *Source Shell-Leuven configuration files*

   #+begin_src shell
   . ~/.bash_profile
   #+end_src

   #+begin_src shell
   . ~/.zshrc
   #+end_src

Once you open up a new terminal window with Bash or Zsh, it should load with
Shell-Leuven's configuration.

** Custom directory

If you'd like to change the install directory with the ~ZSH~ environment variable,
either by running

: export ZSH=/your/path

before installing,

* FAQ

** How to fix "zsh compinit: insecure directories"?

Stripping these directories of the group write permission:

#+begin_src shell
compaudit | xargs chmod g-w
#+end_src

will do the trick, see [[http://www.wezm.net/technical/2008/09/zsh-cygwin-and-insecure-directories/][zsh, Cygwin and Insecure Directories]].

** How to run Windows Emacs without showing a terminal window?

Use the ~run~ command:

#+begin_src shell
C:\cygwin64\bin\run.exe /usr/bin/emacs
#+end_src
